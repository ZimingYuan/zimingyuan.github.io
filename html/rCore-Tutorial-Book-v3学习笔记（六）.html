<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="rCore-Tutorial-Book-v3学习笔记（六）" />
  <meta name="keywords" content="" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 "LXGW Bright", Georgia, serif;
    --font-h: 1.4rem/1.5 "LXGW Bright", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" type="text/css" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css"/>
  <title>rCore-Tutorial-Book-v3学习笔记（六）</title>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">所有文章</a></li>
            <li><a href="/technique.html">技术</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li><a href="/friends.html">友链</a></li>
            <li><a href="/html/关于.html">关于</a></li>
            <li><a href="https://www.travellings.cn/go.html" target="_blank">开往</a></li>
            <li class="float-right">
              <div style="position: relative; display: inline-block;">
                <input type="search" placeholder="搜索标题" style="margin: 0; padding-right: 2em;">
                <button style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); border: none; background: transparent; margin: 0;" onclick="search()">
                  <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M15.7955 15.8111L21 21M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>
                </button>
              </div>
            </li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">rCore-Tutorial-Book-v3学习笔记（六）</h1>
<hr>
</header>
<h3 id="概述">概述</h3>
<p>第六部分是实现基本的文件数据结构、标准输入输出文件和管道文件。相对来讲比较简单，不过因为每个进程的文件描述符表需要用一个既能动态扩增又能直接索引的数据结构，所以我顺便自己实现了一个简单的vector，并利用相同的思想实现了一个队列，使用非常简单，所以又把queue.h换掉了。</p>
<h3 id="内容">内容</h3>
<p>首先是vector和queue，我采用了倍增扩容的方法，即容量满了以后扩大一倍。为了保证空间足够，需要将其包含的数据类型的大小作为属性存入结构体，开辟空间和复制操作的时候都需要乘以该属性，这里以vector和queue的push函数为例：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="dt">void</span> vector_push(<span class="kw">struct</span> vector *v, <span class="dt">void</span> *d) {</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="cf">if</span> (v-&gt;size == v-&gt;capacity) {</span>
<span id="cb1-3"><a href="#cb1-3"></a>        v-&gt;capacity &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a>        <span class="dt">char</span> *t = bd_malloc(v-&gt;capacity * v-&gt;dsize);</span>
<span id="cb1-5"><a href="#cb1-5"></a>        memcpy(t, v-&gt;buffer, v-&gt;size * v-&gt;dsize);</span>
<span id="cb1-6"><a href="#cb1-6"></a>        bd_free(v-&gt;buffer); v-&gt;buffer = t;</span>
<span id="cb1-7"><a href="#cb1-7"></a>    }</span>
<span id="cb1-8"><a href="#cb1-8"></a>    memcpy(v-&gt;buffer + (v-&gt;size++) * v-&gt;dsize, d, v-&gt;dsize);</span>
<span id="cb1-9"><a href="#cb1-9"></a>}</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="dt">void</span> queue_push(<span class="kw">struct</span> queue *q, <span class="dt">void</span> *d) {</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="cf">if</span> (q-&gt;size == q-&gt;capacity) {</span>
<span id="cb1-12"><a href="#cb1-12"></a>        q-&gt;capacity &lt;&lt;= <span class="dv">1</span>;</span>
<span id="cb1-13"><a href="#cb1-13"></a>        <span class="dt">char</span> *t = bd_malloc(q-&gt;capacity * q-&gt;dsize);</span>
<span id="cb1-14"><a href="#cb1-14"></a>        memcpy(t, q-&gt;buffer, q-&gt;tail * q-&gt;dsize);</span>
<span id="cb1-15"><a href="#cb1-15"></a>        memcpy(t + (q-&gt;capacity - (q-&gt;size - q-&gt;front)) * q-&gt;dsize,</span>
<span id="cb1-16"><a href="#cb1-16"></a>                q-&gt;buffer + q-&gt;front * q-&gt;dsize,</span>
<span id="cb1-17"><a href="#cb1-17"></a>                (q-&gt;size - q-&gt;front) * q-&gt;dsize);</span>
<span id="cb1-18"><a href="#cb1-18"></a>        q-&gt;front = q-&gt;capacity - (q-&gt;size - q-&gt;front);</span>
<span id="cb1-19"><a href="#cb1-19"></a>        bd_free(q-&gt;buffer); q-&gt;buffer = t;</span>
<span id="cb1-20"><a href="#cb1-20"></a>    }</span>
<span id="cb1-21"><a href="#cb1-21"></a>    memcpy(q-&gt;buffer + q-&gt;tail * q-&gt;dsize, d, q-&gt;dsize);</span>
<span id="cb1-22"><a href="#cb1-22"></a>    q-&gt;tail = (q-&gt;tail + <span class="dv">1</span>) % q-&gt;capacity; q-&gt;size++;</span>
<span id="cb1-23"><a href="#cb1-23"></a>}</span></code></pre></div>
<p>vector的操作很直观，queue要麻烦一些，为了节省空间，queue用的是循环队列，当队列满时，头索引和尾索引必然相等，因为尾索引是向右增加，头索引是像左减少的，所以扩容的时候需要将原缓冲区最左侧到尾索引的数据复制到新缓冲区的最左侧，将原缓冲区头索引到最右侧的数据复制到新缓冲区的最右侧，这时候就得计算好复制到新缓冲区的起始位置。</p>
<p>然后是文件描述符的设计，rCore很好地利用了rust语言的面向对象特性，让File对象“继承”（我不确定rust语言里这个行为叫什么，大概类似于java里继承抽象类）管道、磁盘文件、设备等对象，这样File对象就只要实现一些最基本的方法和属性，比如定义文件写和文件读函数的指针，具体的属性和方法，如管道释放方法、管道读写权限、管道对应缓冲区、磁盘文件索引之类就通过“继承”赋予给File对象；xv6就比较朴素，在文件描述符里对应了多种多样的属性，但是没有定义函数指针，而是由统一的读写函数通过文件描述符里的文件类型属性判断。</p>
<p>我则综合了两者，给文件描述符定义了包括读、写、释放、复制多个函数的指针，这样在读、写、释放的系统调用中就不用判断文件类型，而是调用对应的函数指针即可，同时也在文件描述符中额外定义了一个void类型的指针，用来指向这个文件“绑定”的数据，比如是管道文件，这个指针就指向一个管道。在调用文件处理函数指针的时候把文件指针传进去，由不同的函数来对这个“绑定”指针进行不同的解释，算是一种伪泛型吧。</p>
<p>这里还有一点要注意的，就是文件的引用计数问题。这个问题对于rCore和xv6的意义不同。对于rCore来说，这个计数不是针对于单个的文件描述符，而是针对于文件描述符所产生的跨进程资源。比如管道文件，虽然每个进程各自持有，释放也各自释放就行，但是管道包含一个用来传输数据的缓冲队列，这个缓冲队列就是跨进程资源。这就需要引用计数，对于每个缓冲队列记录自己有多少个“管口”，当所有“管口”被关闭时，即没有管道引用它时，就要释放这个缓冲队列。这里rust又拿下一城：拥有内置了引用计数功能的智能指针，不需要显式地处理引用计数问题。再看看xv6，xv6是父子进程共享一个文件描述符，所以引用计数是文件描述符的一个属性，每次进程fork都会增加一次引用，释放文件会减少一次引用，当引用为0时将文件描述符及其对应的资源释放。</p>
<p>我在文件描述符和进程的关系上遵循的是rCore，即每个进程持有一个独立的文件描述符，而把引用计数属性放在需要被释放的结构体中，比如这里就给管道添加了引用计数属性，同时定义了管道释放和复制的方法对其指向的缓冲区引用计数进行修改，这一步就比较像xv6，然后把这两个函数填入文件描述符的函数指针中，由fork函数和文件关闭函数调用。</p>
<p>这里给出管道相关的创建、读写、复制、释放函数：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a>usize pipe_read(File *self, <span class="dt">char</span> *buffer, usize len) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>    Pipe *p = (Pipe *)self-&gt;bind;</span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; len; i++) {</span>
<span id="cb2-4"><a href="#cb2-4"></a>        <span class="cf">while</span> (queue_empty(&amp;p-&gt;q)) {</span>
<span id="cb2-5"><a href="#cb2-5"></a>            <span class="cf">if</span> (p-&gt;wrefcnt == <span class="dv">0</span>) {</span>
<span id="cb2-6"><a href="#cb2-6"></a>                buffer[i] = <span class="ch">&#39;\0&#39;</span>; <span class="cf">return</span> i;</span>
<span id="cb2-7"><a href="#cb2-7"></a>            }</span>
<span id="cb2-8"><a href="#cb2-8"></a>            suspend_current_and_run_next();</span>
<span id="cb2-9"><a href="#cb2-9"></a>        }</span>
<span id="cb2-10"><a href="#cb2-10"></a>        buffer[i] = *(<span class="dt">char</span> *)queue_front(&amp;p-&gt;q); queue_pop(&amp;p-&gt;q);</span>
<span id="cb2-11"><a href="#cb2-11"></a>    }</span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="cf">return</span> len;</span>
<span id="cb2-13"><a href="#cb2-13"></a>}</span>
<span id="cb2-14"><a href="#cb2-14"></a>usize pipe_write(File *self, <span class="dt">char</span> *buffer, usize len) {</span>
<span id="cb2-15"><a href="#cb2-15"></a>    Pipe *p = (Pipe *)self-&gt;bind;</span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="cf">for</span> (usize i = <span class="dv">0</span>; i &lt; len; i++) queue_push(&amp;p-&gt;q, buffer + i);</span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="cf">return</span> len;</span>
<span id="cb2-18"><a href="#cb2-18"></a>}</span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="dt">void</span> pipe_copy(File *self) {</span>
<span id="cb2-20"><a href="#cb2-20"></a>    Pipe *p = (Pipe *)self-&gt;bind;</span>
<span id="cb2-21"><a href="#cb2-21"></a>    <span class="cf">if</span> (self-&gt;read == illegal_rw) p-&gt;wrefcnt++; p-&gt;refcnt++;</span>
<span id="cb2-22"><a href="#cb2-22"></a>}</span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="dt">void</span> pipe_close(File *self) {</span>
<span id="cb2-24"><a href="#cb2-24"></a>    Pipe *p = (Pipe *)self-&gt;bind;</span>
<span id="cb2-25"><a href="#cb2-25"></a>    <span class="cf">if</span> (self-&gt;read == illegal_rw) p-&gt;wrefcnt--;</span>
<span id="cb2-26"><a href="#cb2-26"></a>    self-&gt;occupied = <span class="dv">0</span>; p-&gt;refcnt--;</span>
<span id="cb2-27"><a href="#cb2-27"></a>    <span class="cf">if</span> (p-&gt;refcnt == <span class="dv">0</span>) {</span>
<span id="cb2-28"><a href="#cb2-28"></a>        queue_free(&amp;p-&gt;q); bd_free(p);</span>
<span id="cb2-29"><a href="#cb2-29"></a>    }</span>
<span id="cb2-30"><a href="#cb2-30"></a>}</span>
<span id="cb2-31"><a href="#cb2-31"></a><span class="dt">void</span> make_pipe(usize *p) {</span>
<span id="cb2-32"><a href="#cb2-32"></a>    Pipe* t = bd_malloc(<span class="kw">sizeof</span>(Pipe));</span>
<span id="cb2-33"><a href="#cb2-33"></a>    queue_new(&amp;t-&gt;q, <span class="dv">1</span>); t-&gt;refcnt = <span class="dv">2</span>; t-&gt;wrefcnt = <span class="dv">1</span>;</span>
<span id="cb2-34"><a href="#cb2-34"></a>    File *f = alloc_fd(p); f-&gt;bind = (<span class="dt">void</span> *)t;</span>
<span id="cb2-35"><a href="#cb2-35"></a>    f-&gt;read = pipe_read; f-&gt;write = illegal_rw;</span>
<span id="cb2-36"><a href="#cb2-36"></a>    f-&gt;copy = pipe_copy; f-&gt;close = pipe_close;</span>
<span id="cb2-37"><a href="#cb2-37"></a>    f = alloc_fd(p + <span class="dv">1</span>); f-&gt;bind = (<span class="dt">void</span> *)t;</span>
<span id="cb2-38"><a href="#cb2-38"></a>    f-&gt;read = illegal_rw; f-&gt;write = pipe_write;</span>
<span id="cb2-39"><a href="#cb2-39"></a>    f-&gt;copy = pipe_copy; f-&gt;close = pipe_close;</span>
<span id="cb2-40"><a href="#cb2-40"></a>} </span></code></pre></div>
<p>我这里Pipe结构体和rCore不太一样，rCore里Pipe对象的意思是“管口”，有额外的PipeRingBuffer对象表示管道本身。我这里Pipe就是管道本身，文件描述符中bind属性指向它，所以文件描述符本身就充当“管口”了。管道中还有一个wrefcnt属性表示写引用计数，在读函数中如果判断写引用计数为0，说明管道中不会再有新数据了，则直接返回已经读取的全部数据。</p>
<p>在复制和释放管道文件的时候，判断释放应该修改写引用计数的方法是判断该文件的读函数是否指向<code>illegal_rw</code>，这个函数是一个直接返回错误的函数，用来填充该文件不支持的操作对应函数指针，如果管道文件的读函数指向<code>illegal_rw</code>，说明这个管道文件不支持读取，是写管口，此时就应该修改写引用计数。</p>
<footer>
    <hr>
    <center>
        Powered by <a href="https://github.com/ZimingYuan/Yblogs" target="_blank">Yblogs</a><br>
        转载请注明出处 © 2025 VnYzm的博客<br>
        <span id="busuanzi_container_site_uv">2025年10月7日以来总访问量为<span id="busuanzi_value_site_uv"></span>次</span>
    </center>
</footer>
</body>
</html>
