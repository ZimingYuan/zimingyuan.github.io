<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="题解归档：2016年4月" />
  <meta name="keywords" content="" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-h: 1.4rem/1.5 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <title>题解归档：2016年4月</title>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">主页</a></li>
            <li><a href="/html/随笔.html">随笔</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li><a href="/friends.html">友链</a></li>
            <li class="float-right sticky"><button style="margin: 0" onclick="search()">Go</button></li>
            <li class="float-right sticky"><input type="search" placeholder="搜索标题" style="margin: 0"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">题解归档：2016年4月</h1>
<hr>
</header>
<h3 id="bzoj1257cqoi2007余数之和sum2016.4.1">bzoj1257[CQOI2007]余数之和sum（2016.4.1）</h3>
<h4 id="题意">题意</h4>
<p>给出正整数n和k，计算j(n, k)=k mod 1 + k mod 2 + k mod 3 + … + k mod n的值。</p>
<h4 id="题解">题解</h4>
<p>思路很巧妙。先划分一下，第一步对≤√k的n暴力求。因为a%b也等于a-a div b(用pascal的术语，表整除)*b，所以第二步对于1到√k的每个数i，求一个区间[l,r]使得区间里每个数被k整除后商为i，然后就可以用数列求和公式求k div [l,r]*[l,r]的和，再用k减后做个累加即可，但要注意区间不要和之前在第一步求过的重叠。因为一个数%大于自己的数等于自己，所以可以对大于k的n直接做乘法。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">long</span><span class="pp"> </span><span class="dt">long</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="dt">int</span> main(){</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="dt">long</span> <span class="dt">long</span> n,k; scanf(<span class="st">&quot;</span><span class="sc">%lld%lld</span><span class="st">&quot;</span>,&amp;n,&amp;k); <span class="dt">long</span> <span class="dt">long</span> ans=<span class="dv">0</span>;</span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="dt">long</span> <span class="dt">long</span> sz=(<span class="dt">long</span> <span class="dt">long</span>)sqrt(k)+<span class="dv">1</span>;</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="cf">if</span>(n&lt;=sz){</span>
<span id="cb1-12"><a href="#cb1-12"></a>        inc(i,<span class="dv">1</span>,n)ans+=k%i;</span>
<span id="cb1-13"><a href="#cb1-13"></a>    }<span class="cf">else</span>{</span>
<span id="cb1-14"><a href="#cb1-14"></a>        inc(i,<span class="dv">1</span>,sz)ans+=k%i;</span>
<span id="cb1-15"><a href="#cb1-15"></a>        inc(j,<span class="dv">1</span>,k/sz){</span>
<span id="cb1-16"><a href="#cb1-16"></a>            <span class="dt">long</span> <span class="dt">long</span> l=max(k/(j+<span class="dv">1</span>)+<span class="dv">1</span>,sz+<span class="dv">1</span>),r=min(min(k/j,k),n); <span class="cf">if</span>(l&gt;r)<span class="cf">continue</span>;</span>
<span id="cb1-17"><a href="#cb1-17"></a>            ans+=(k*(r-l+<span class="dv">1</span>)-j*(l+r)*(r-l+<span class="dv">1</span>)/<span class="dv">2</span>);</span>
<span id="cb1-18"><a href="#cb1-18"></a>        }</span>
<span id="cb1-19"><a href="#cb1-19"></a>        <span class="cf">if</span>(n&gt;k)ans+=k*(n-k);</span>
<span id="cb1-20"><a href="#cb1-20"></a>    }</span>
<span id="cb1-21"><a href="#cb1-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans);</span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-23"><a href="#cb1-23"></a>}</span></code></pre></div>
<h3 id="bzoj1303cqoi2009中位数图2016.4.1">bzoj1303[CQOI2009]中位数图（2016.4.1）</h3>
<h4 id="题意-1">题意</h4>
<p>给出1~n的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是b。</p>
<h4 id="题解-1">题解</h4>
<p>首先将数组中所有小于b的数置为-1，等于的置为0，大于的置为1。然后对b及其右边的数的前缀和（b的位置到该位置所有数的和）出现个数建一个数组r，对b左边的数的每个后缀和（该位置到b的位置所有数的和）的相反数在r中的数相乘就是答案。实际上，这种把数转化成1、-1、0的方法十分常用，但是我不会。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="dt">int</span> l[<span class="dv">400000</span>],r[<span class="dv">400000</span>],s,n,b,a[<span class="dv">200000</span>],p;</span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="dt">int</span> main(){</span>
<span id="cb2-10"><a href="#cb2-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;b);</span>
<span id="cb2-11"><a href="#cb2-11"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb2-12"><a href="#cb2-12"></a>        <span class="dt">int</span> a1; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a1); <span class="cf">if</span>(a1==b)a[i]=<span class="dv">0</span>,p=i; <span class="cf">if</span>(a1&lt;b)a[i]=-<span class="dv">1</span>; <span class="cf">if</span>(a1&gt;b)a[i]=<span class="dv">1</span>;</span>
<span id="cb2-13"><a href="#cb2-13"></a>    }</span>
<span id="cb2-14"><a href="#cb2-14"></a>    l[p+<span class="dv">1</span>]=<span class="dv">0</span>; dec(i,p,<span class="dv">1</span>)l[i]=l[i+<span class="dv">1</span>]+a[i];</span>
<span id="cb2-15"><a href="#cb2-15"></a>    memset(r,<span class="dv">0</span>,<span class="kw">sizeof</span>(r)); s=<span class="dv">0</span>; inc(i,p,n)s=s+a[i],r[s+n]++;</span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="dt">int</span> ans=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,p)ans+=r[-l[i]+n];</span>
<span id="cb2-17"><a href="#cb2-17"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);</span>
<span id="cb2-18"><a href="#cb2-18"></a>}</span></code></pre></div>
<h3 id="bzoj1202hnoi2005狡猾的商人2016.4.1">bzoj1202[HNOI2005]狡猾的商人（2016.4.1）</h3>
<h4 id="题意-2">题意</h4>
<p>账本上记录了n个月以来的收入情况，其中第i 个月的收入额为Ai 。所谓一段时间内的总收入，就是这段时间内每个月的收入额的总和。给出m段时间内的总收入，判断账本是否合法。</p>
<h4 id="题解-2">题解</h4>
<p>太神了，并查集还能这么用。每月作为一个节点，同时保存父节点表示的月份到该月份的盈利是多少，每次读入一个区间，如果左右端点在同一个集合内，就直接比较两个节点的权值差（因为路径压缩时已经使它们的父节点相同），注意路径压缩时要先递归再维护权值。如果左右端点在不同集合，则合并，设所在子树被合并的那个端点为a2，另一个为a1，a2的根节点为a5，给出的信息为a3，则a5的权值变为w[a5]=w[a1]-w[a2]+a3。因为：设a1根节点为a4，s[i]表示i的前缀和，则w[a1]=s[a1]-s[a4] w[a2]=s[a2]-s[a5] a3=s[a2]-s[a1] 显然s[a5]-s[a4]=w[a1]-w[a2]+a3=w[a5]。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="dt">int</span> fa[<span class="dv">1000</span>],w[<span class="dv">1000</span>];</span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">if</span>(x==fa[x])<span class="cf">return</span> x;<span class="cf">else</span>{<span class="dt">int</span> y=find(fa[x]); w[x]+=w[fa[x]]; <span class="cf">return</span> fa[x]=y;};}</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="dt">int</span> main(){</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="dt">int</span> t,n,m; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;t);</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="cf">while</span>(t--){</span>
<span id="cb3-12"><a href="#cb3-12"></a>        scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">0</span>,n)fa[i]=i,w[i]=<span class="dv">0</span>; <span class="dt">bool</span> f=<span class="dv">0</span>;</span>
<span id="cb3-13"><a href="#cb3-13"></a>        inc(i,<span class="dv">1</span>,m){</span>
<span id="cb3-14"><a href="#cb3-14"></a>            <span class="dt">int</span> a1,a2,a3; scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a1,&amp;a2,&amp;a3); a1--;</span>
<span id="cb3-15"><a href="#cb3-15"></a>            <span class="dt">int</span> a4=find(a1),a5=find(a2);</span>
<span id="cb3-16"><a href="#cb3-16"></a>            <span class="cf">if</span>(a4==a5&amp;&amp;a3!=w[a2]-w[a1]){printf(<span class="st">&quot;false</span><span class="sc">\n</span><span class="st">&quot;</span>);f=<span class="dv">1</span>;<span class="cf">break</span>;}</span>
<span id="cb3-17"><a href="#cb3-17"></a>            <span class="cf">if</span>(a4!=a5)w[a5]=w[a1]-w[a2]+a3,fa[a5]=a4;</span>
<span id="cb3-18"><a href="#cb3-18"></a>        }</span>
<span id="cb3-19"><a href="#cb3-19"></a>        <span class="cf">if</span>(!f)printf(<span class="st">&quot;true</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb3-20"><a href="#cb3-20"></a>    }</span>
<span id="cb3-21"><a href="#cb3-21"></a>}</span></code></pre></div>
<h3 id="bzoj1306cqoi2009match循环赛2016.4.5">bzoj1306[CQOI2009]match循环赛（2016.4.5）</h3>
<h4 id="题意-3">题意</h4>
<p>n支队伍打单循环赛，赢的得3分，平局各得1分，输的不得分。已知n支队伍最终得分，求多少种可能的分数表。</p>
<h4 id="题解-3">题解</h4>
<p>爆搜，加入各种奇怪剪枝，比如：剩下的比赛全赢分数都不到要求就返回、当前分数超过了要求……还有一个重要的就是如果当前已经是最后一场就直接算出比赛结果，这个剪枝虽然表面上没什么用但实际上可以把程序从TLE的边缘拯救回来。这种题对我这种从不鸟常数的就是灾难。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="dt">int</span> s2[<span class="dv">10</span>],ans[<span class="dv">10</span>],tot,n,sz;</span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> z){</span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="cf">if</span>(z==sz){inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(s2[i]!=ans[i])<span class="cf">return</span>; tot++; <span class="cf">return</span>;}<span class="cf">if</span>(x&gt;n||y&gt;n)<span class="cf">return</span>;</span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="cf">if</span>(y!=n||(y==n&amp;&amp;ans[x]-s2[x]==<span class="dv">3</span>)){</span>
<span id="cb4-11"><a href="#cb4-11"></a>        s2[x]+=<span class="dv">3</span>;</span>
<span id="cb4-12"><a href="#cb4-12"></a>        <span class="cf">if</span>(s2[x]+<span class="dv">3</span>*(n-y)&gt;=ans[x]&amp;&amp;s2[y]+<span class="dv">3</span>*(n-x)&gt;=ans[y]&amp;&amp;s2[x]&lt;=ans[x]&amp;&amp;s2[y]&lt;=ans[y])y==n?dfs(x+<span class="dv">1</span>,x+<span class="dv">2</span>,z+<span class="dv">1</span>):dfs(x,y+<span class="dv">1</span>,z+<span class="dv">1</span>);</span>
<span id="cb4-13"><a href="#cb4-13"></a>        s2[x]-=<span class="dv">3</span>;</span>
<span id="cb4-14"><a href="#cb4-14"></a>    }</span>
<span id="cb4-15"><a href="#cb4-15"></a>    <span class="cf">if</span>(y!=n||(y==n&amp;&amp;ans[x]-s2[x]==<span class="dv">1</span>)){</span>
<span id="cb4-16"><a href="#cb4-16"></a>        s2[x]++; s2[y]++;</span>
<span id="cb4-17"><a href="#cb4-17"></a>        <span class="cf">if</span>(s2[x]+<span class="dv">3</span>*(n-y)&gt;=ans[x]&amp;&amp;s2[y]+<span class="dv">3</span>*(n-x)&gt;=ans[y]&amp;&amp;s2[x]&lt;=ans[x]&amp;&amp;s2[y]&lt;=ans[y])y==n?dfs(x+<span class="dv">1</span>,x+<span class="dv">2</span>,z+<span class="dv">1</span>):dfs(x,y+<span class="dv">1</span>,z+<span class="dv">1</span>);</span>
<span id="cb4-18"><a href="#cb4-18"></a>        s2[x]--; s2[y]--;</span>
<span id="cb4-19"><a href="#cb4-19"></a>    }</span>
<span id="cb4-20"><a href="#cb4-20"></a>    <span class="cf">if</span>(ans[x]==s2[x]||y!=n){</span>
<span id="cb4-21"><a href="#cb4-21"></a>        s2[y]+=<span class="dv">3</span>;</span>
<span id="cb4-22"><a href="#cb4-22"></a>        <span class="cf">if</span>(s2[x]+<span class="dv">3</span>*(n-y)&gt;=ans[x]&amp;&amp;s2[y]+<span class="dv">3</span>*(n-x)&gt;=ans[y]&amp;&amp;s2[x]&lt;=ans[x]&amp;&amp;s2[y]&lt;=ans[y])y==n?dfs(x+<span class="dv">1</span>,x+<span class="dv">2</span>,z+<span class="dv">1</span>):dfs(x,y+<span class="dv">1</span>,z+<span class="dv">1</span>);</span>
<span id="cb4-23"><a href="#cb4-23"></a>        s2[y]-=<span class="dv">3</span>;</span>
<span id="cb4-24"><a href="#cb4-24"></a>    }</span>
<span id="cb4-25"><a href="#cb4-25"></a>}</span>
<span id="cb4-26"><a href="#cb4-26"></a><span class="dt">int</span> main(){</span>
<span id="cb4-27"><a href="#cb4-27"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;ans[i]);</span>
<span id="cb4-28"><a href="#cb4-28"></a>    memset(s2,<span class="dv">0</span>,<span class="kw">sizeof</span>(s2)); tot=<span class="dv">0</span>; sz=(n*n-n)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb4-29"><a href="#cb4-29"></a>    dfs(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">0</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,tot);</span>
<span id="cb4-30"><a href="#cb4-30"></a>}</span></code></pre></div>
<h3 id="bzoj20382009国家集训队小z的袜子hose2016.4.5">bzoj2038[2009国家集训队]小Z的袜子(hose)（2016.4.5）</h3>
<h4 id="题意-4">题意</h4>
<p>把N只袜子从1到N编号，每次求从编号为L到R的袜子中抽两只，有多大的概率抽到颜色相同的袜子。</p>
<h4 id="题解-4">题解</h4>
<p>不知道要用什么数据结构，但是可以用一个全局的数组保存每个颜色当前数量，使由区间[l,r]推出[l,r±1]的答案和[l±1,r]的复杂度为O(1)，对这种问题，可以用复杂度为O(nsqrt(n))的莫队算法解决。</p>
<p>莫队算法是一种离线算法，将询问按某种顺序排序，使得均摊复杂度为O(nsqrt(n))，那怎么排序呢？如果按左端点排序，那么r将有可能多次大幅度摆动，使复杂度退化成O(n^2)，正解是对端点分块，让后按左端点所在块为第一关键字排序，右端点为第二关键字排序。这样子当两个询问l在同一块时，l只有可能移sqrt(n)次。l在同一块的多次询问q只能右移n次，l在不同块时r可能左移n次，但因为只有sqrt(n)块，所以需移n次的操作都只有sqrt(n)次，因此均摊复杂度是O(sqrt(n))。所有的均摊复杂度都是玄学……</p>
<p>因为中间结果没有强制转化成long long，wa了好几发，本弱太弱了！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">struct</span> nd1{</span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="dt">int</span> l,pl,r,id; ll ans;</span>
<span id="cb5-11"><a href="#cb5-11"></a>};</span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="dt">bool</span> cmp1(nd1 a,nd1 b){</span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="cf">if</span>(a.pl!=b.pl)<span class="cf">return</span> a.pl&lt;b.pl; <span class="cf">if</span>(a.r!=b.r)<span class="cf">return</span> a.r&lt;b.r;</span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="cf">return</span> a.l&lt;b.l;</span>
<span id="cb5-15"><a href="#cb5-15"></a>}</span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="dt">bool</span> cmp2(nd1 a,nd1 b){</span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="cf">return</span> a.id&lt;b.id;</span>
<span id="cb5-18"><a href="#cb5-18"></a>}</span>
<span id="cb5-19"><a href="#cb5-19"></a>nd1 a1[<span class="dv">100000</span>];<span class="dt">int</span> col[<span class="dv">100000</span>],pos[<span class="dv">100000</span>],n,m,l,r;ll ans,s[<span class="dv">100000</span>];</span>
<span id="cb5-20"><a href="#cb5-20"></a><span class="kw">inline</span> <span class="dt">void</span> update(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb5-21"><a href="#cb5-21"></a>    ans-=(s[col[x]]*(s[col[x]]-<span class="dv">1</span>));s[col[x]]+=(ll)y;ans+=(s[col[x]]*(s[col[x]]-<span class="dv">1</span>));</span>
<span id="cb5-22"><a href="#cb5-22"></a>}</span>
<span id="cb5-23"><a href="#cb5-23"></a>ll gcd(ll a,ll b){<span class="cf">return</span> b==<span class="dv">0</span>?a:gcd(b,a%b);}</span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="dt">int</span> main(){</span>
<span id="cb5-25"><a href="#cb5-25"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;col[i]); <span class="dt">int</span> sz=(<span class="dt">int</span>)sqrt(n);</span>
<span id="cb5-26"><a href="#cb5-26"></a>    inc(i,<span class="dv">1</span>,n)pos[i]=(i-<span class="dv">1</span>)/sz+<span class="dv">1</span>;</span>
<span id="cb5-27"><a href="#cb5-27"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb5-28"><a href="#cb5-28"></a>        <span class="dt">int</span> a,b;scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b);a1[i]=(nd1){a,pos[a],b,i,<span class="dv">0</span>};</span>
<span id="cb5-29"><a href="#cb5-29"></a>    }</span>
<span id="cb5-30"><a href="#cb5-30"></a>    sort(a1+<span class="dv">1</span>,a1+<span class="dv">1</span>+m,cmp1); l=<span class="dv">1</span>; r=<span class="dv">0</span>; ans=<span class="dv">0</span>; memset(s,<span class="dv">0</span>,<span class="kw">sizeof</span>(s));</span>
<span id="cb5-31"><a href="#cb5-31"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb5-32"><a href="#cb5-32"></a>        <span class="cf">while</span>(r&lt;a1[i].r)update(r+<span class="dv">1</span>,<span class="dv">1</span>),r++;</span>
<span id="cb5-33"><a href="#cb5-33"></a>        <span class="cf">while</span>(l&gt;a1[i].l)update(l-<span class="dv">1</span>,<span class="dv">1</span>),l--;</span>
<span id="cb5-34"><a href="#cb5-34"></a>        <span class="cf">while</span>(r&gt;a1[i].r)update(r,-<span class="dv">1</span>),r--;</span>
<span id="cb5-35"><a href="#cb5-35"></a>        <span class="cf">while</span>(l&lt;a1[i].l)update(l,-<span class="dv">1</span>),l++;</span>
<span id="cb5-36"><a href="#cb5-36"></a>        a1[i].ans=ans;</span>
<span id="cb5-37"><a href="#cb5-37"></a>    }</span>
<span id="cb5-38"><a href="#cb5-38"></a>    sort(a1+<span class="dv">1</span>,a1+<span class="dv">1</span>+m,cmp2);</span>
<span id="cb5-39"><a href="#cb5-39"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb5-40"><a href="#cb5-40"></a>        <span class="cf">if</span>(a1[i].ans==<span class="dv">0</span>)printf(<span class="st">&quot;0/1</span><span class="sc">\n</span><span class="st">&quot;</span>);<span class="cf">else</span>{</span>
<span id="cb5-41"><a href="#cb5-41"></a>            ll a2=gcd(a1[i].ans,(ll)(a1[i].r-a1[i].l+<span class="dv">1</span>)*(a1[i].r-a1[i].l));</span>
<span id="cb5-42"><a href="#cb5-42"></a>            printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">/</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,a1[i].ans/a2,(ll)(a1[i].r-a1[i].l+<span class="dv">1</span>)*(a1[i].r-a1[i].l)/a2);</span>
<span id="cb5-43"><a href="#cb5-43"></a>        }</span>
<span id="cb5-44"><a href="#cb5-44"></a>    }</span>
<span id="cb5-45"><a href="#cb5-45"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-46"><a href="#cb5-46"></a>}</span></code></pre></div>
<h3 id="bzoj2662beijing-wc2012冻结2016.4.6">bzoj2662[BeiJing wc2012]冻结（2016.4.6）</h3>
<h4 id="题意-5">题意</h4>
<p>有 N 个城市，M 条双向的道路，有K次机会使通过某条道路时时间变慢 50%。注意在一条道路上最多只能使用一次机会，且不必使用完所有机会。 求从城市1 到城市N最少需要多长时间。（每条双向边等价于两条单向边）</p>
<h4 id="题解-5">题解</h4>
<p>分层图最短路。这道题数据弱，可以按次数拆点，但bzoj2763就不行了，正解是在作spfa时“拆点”，把d弄成二维数组。虽然感觉上是一样的，但时间却相差很大，不知道为什么。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="pp">#define turn</span>(x,y)<span class="pp"> </span>(y-<span class="dv">1</span>)*n+x</span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; <span class="dt">int</span> ess,g[<span class="dv">100</span>]; e es[<span class="dv">200000</span>];</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess;}</span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="dt">int</span> n,m,k,s,t,d[<span class="dv">100</span>][<span class="dv">100</span>]; <span class="dt">bool</span> inq[<span class="dv">100</span>][<span class="dv">100</span>];</span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="kw">struct</span> nd{<span class="dt">int</span> x,y;}; queue &lt;nd&gt; q;</span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="dt">void</span> spfa(){</span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="cf">while</span>(! q.empty())q.pop(); inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,k+<span class="dv">1</span>)d[i][j]=INF;</span>
<span id="cb6-16"><a href="#cb6-16"></a>    d[<span class="dv">1</span>][<span class="dv">1</span>]=<span class="dv">0</span>; q.push((nd){<span class="dv">1</span>,<span class="dv">1</span>}); inq[<span class="dv">1</span>][<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb6-17"><a href="#cb6-17"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb6-18"><a href="#cb6-18"></a>        nd x=q.front(); q.pop(); inq[x.x][x.y]=<span class="dv">0</span>;</span>
<span id="cb6-19"><a href="#cb6-19"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x.x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t][x.y]&gt;d[x.x][x.y]+es[i].w){</span>
<span id="cb6-20"><a href="#cb6-20"></a>            d[es[i].t][x.y]=d[x.x][x.y]+es[i].w;</span>
<span id="cb6-21"><a href="#cb6-21"></a>            <span class="cf">if</span>(! inq[es[i].t][x.y])q.push((nd){es[i].t,x.y}),inq[es[i].t][x.y]=<span class="dv">1</span>;</span>
<span id="cb6-22"><a href="#cb6-22"></a>        }</span>
<span id="cb6-23"><a href="#cb6-23"></a>        <span class="cf">if</span>(x.y&lt;=k)<span class="cf">for</span>(<span class="dt">int</span> i=g[x.x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t][x.y+<span class="dv">1</span>]&gt;d[x.x][x.y]+(es[i].w&gt;&gt;<span class="dv">1</span>)){</span>
<span id="cb6-24"><a href="#cb6-24"></a>            d[es[i].t][x.y+<span class="dv">1</span>]=d[x.x][x.y]+(es[i].w&gt;&gt;<span class="dv">1</span>);</span>
<span id="cb6-25"><a href="#cb6-25"></a>            <span class="cf">if</span>(! inq[es[i].t][x.y+<span class="dv">1</span>])q.push((nd){es[i].t,x.y+<span class="dv">1</span>}),inq[es[i].t][x.y+<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb6-26"><a href="#cb6-26"></a>        }</span>
<span id="cb6-27"><a href="#cb6-27"></a>    }</span>
<span id="cb6-28"><a href="#cb6-28"></a>}</span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="dt">int</span> main(){</span>
<span id="cb6-30"><a href="#cb6-30"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m,&amp;k); ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb6-31"><a href="#cb6-31"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb6-32"><a href="#cb6-32"></a>        <span class="dt">int</span> a,b,c;scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); pe(a,b,c),pe(b,a,c);</span>
<span id="cb6-33"><a href="#cb6-33"></a>    }</span>
<span id="cb6-34"><a href="#cb6-34"></a>    spfa(); <span class="dt">int</span> min=INF; inc(i,<span class="dv">1</span>,k+<span class="dv">1</span>)<span class="cf">if</span>(d[n][i]&lt;min)min=d[n][i];</span>
<span id="cb6-35"><a href="#cb6-35"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,min);</span>
<span id="cb6-36"><a href="#cb6-36"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-37"><a href="#cb6-37"></a>}</span></code></pre></div>
<h3 id="bzoj2763jloi2011飞行路线2016.4.6">bzoj2763[JLOI2011]飞行路线（2016.4.6）</h3>
<h4 id="题意-6">题意</h4>
<p>n个城市，这些城市分别标记为0到n-1，一共有m种航线，每种航线连接两个城市（双向），并且航线有一定的价格，途中可以进行转机。规定可以免费在最多k种航线上搭乘飞机。已知起点终点和k，求这次出行最少花费多少？</p>
<h4 id="题解-6">题解</h4>
<p>同bzoj2662，但这次乱搞会TLE，本弱太弱了！</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="pp">#define turn</span>(x,y)<span class="pp"> </span>(y-<span class="dv">1</span>)*n+x</span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; <span class="dt">int</span> ess,g[<span class="dv">15000</span>]; e es[<span class="dv">200000</span>];</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess;}</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="dt">int</span> n,m,k,s,t,d[<span class="dv">15000</span>][<span class="dv">11</span>]; <span class="dt">bool</span> inq[<span class="dv">15000</span>][<span class="dv">11</span>];</span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="kw">struct</span> nd{<span class="dt">int</span> x,y;}; queue &lt;nd&gt; q;</span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="dt">void</span> spfa(){</span>
<span id="cb7-15"><a href="#cb7-15"></a>    <span class="cf">while</span>(! q.empty())q.pop(); inc(i,<span class="dv">0</span>,n-<span class="dv">1</span>)inc(j,<span class="dv">1</span>,k+<span class="dv">1</span>)d[i][j]=INF;</span>
<span id="cb7-16"><a href="#cb7-16"></a>    d[s][<span class="dv">1</span>]=<span class="dv">0</span>; q.push((nd){s,<span class="dv">1</span>}); inq[s][<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb7-17"><a href="#cb7-17"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb7-18"><a href="#cb7-18"></a>        nd x=q.front(); q.pop(); inq[x.x][x.y]=<span class="dv">0</span>;</span>
<span id="cb7-19"><a href="#cb7-19"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x.x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t][x.y]&gt;d[x.x][x.y]+es[i].w){</span>
<span id="cb7-20"><a href="#cb7-20"></a>            d[es[i].t][x.y]=d[x.x][x.y]+es[i].w; <span class="cf">if</span>(! inq[es[i].t][x.y])q.push((nd){es[i].t,x.y}),inq[es[i].t][x.y]=<span class="dv">1</span>;</span>
<span id="cb7-21"><a href="#cb7-21"></a>        }</span>
<span id="cb7-22"><a href="#cb7-22"></a>        <span class="cf">if</span>(x.y&lt;=k)<span class="cf">for</span>(<span class="dt">int</span> i=g[x.x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t][x.y+<span class="dv">1</span>]&gt;d[x.x][x.y]){</span>
<span id="cb7-23"><a href="#cb7-23"></a>            d[es[i].t][x.y+<span class="dv">1</span>]=d[x.x][x.y]; <span class="cf">if</span>(! inq[es[i].t][x.y+<span class="dv">1</span>])q.push((nd){es[i].t,x.y+<span class="dv">1</span>}),inq[es[i].t][x.y+<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb7-24"><a href="#cb7-24"></a>        }</span>
<span id="cb7-25"><a href="#cb7-25"></a>    }</span>
<span id="cb7-26"><a href="#cb7-26"></a>}</span>
<span id="cb7-27"><a href="#cb7-27"></a><span class="dt">int</span> main(){</span>
<span id="cb7-28"><a href="#cb7-28"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;s,&amp;t); ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb7-29"><a href="#cb7-29"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb7-30"><a href="#cb7-30"></a>        <span class="dt">int</span> a,b,c;scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); pe(a,b,c),pe(b,a,c);</span>
<span id="cb7-31"><a href="#cb7-31"></a>    }</span>
<span id="cb7-32"><a href="#cb7-32"></a>    spfa(); <span class="dt">int</span> min=INF;</span>
<span id="cb7-33"><a href="#cb7-33"></a>    inc(i,<span class="dv">1</span>,k+<span class="dv">1</span>)<span class="cf">if</span>(d[t][i]&lt;min)min=d[t][i];</span>
<span id="cb7-34"><a href="#cb7-34"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,min);</span>
<span id="cb7-35"><a href="#cb7-35"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-36"><a href="#cb7-36"></a>}</span></code></pre></div>
<h3 id="bzoj3190jloi2013赛车2016.4.7">bzoj3190[JLOI2013]赛车（2016.4.7）</h3>
<h4 id="题意-7">题意</h4>
<p>赛场上一共有N辆车。赛道是一条无限长的直线。在这个比赛过程中，如果一辆赛车曾经处于领跑位置的话（即没有其他的赛车跑在他的前面），这辆赛车最后就可以得奖。已知所有赛车的起始位置（离起跑线距离）和速度，求出那些赛车将会得奖。</p>
<h4 id="题解-7">题解</h4>
<p>有人说是类似线性规划，用半平面交，反正我不会，数学考试是线性规划也错得一塌糊涂QAQ。</p>
<p>黄学长用的是维护斜率的方法，按照斜率排个序，依次插入一个单调栈，如果栈顶不满足XX条件（说不清楚，画个图）就弹掉，最后留在栈里的就是答案。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="pp">#define eps </span><span class="fl">1e-8</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">struct</span> nd{</span>
<span id="cb8-9"><a href="#cb8-9"></a>    <span class="dt">int</span> s,v,id;</span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd&amp; a)<span class="at">const</span>{</span>
<span id="cb8-11"><a href="#cb8-11"></a>        <span class="cf">if</span>(v!=a.v)<span class="cf">return</span> v&lt;a.v; <span class="cf">return</span> s&lt;a.s;</span>
<span id="cb8-12"><a href="#cb8-12"></a>    }</span>
<span id="cb8-13"><a href="#cb8-13"></a>};</span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="dt">double</span> solve(nd a,nd b){</span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="cf">return</span> (<span class="dt">double</span>)(a.s-b.s)/(<span class="dt">double</span>)(b.v-a.v);</span>
<span id="cb8-16"><a href="#cb8-16"></a>}</span>
<span id="cb8-17"><a href="#cb8-17"></a>nd nds[<span class="dv">20000</span>],s[<span class="dv">20000</span>]; <span class="dt">int</span> ans[<span class="dv">20000</span>],n,tp;</span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="dt">int</span> main(){</span>
<span id="cb8-19"><a href="#cb8-19"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;nds[i].s),nds[i].id=i; inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;nds[i].v); sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+n);</span>
<span id="cb8-20"><a href="#cb8-20"></a>    tp=<span class="dv">1</span>;s[tp]=nds[<span class="dv">1</span>];ans[tp]=nds[<span class="dv">1</span>].id;</span>
<span id="cb8-21"><a href="#cb8-21"></a>    inc(i,<span class="dv">2</span>,n){</span>
<span id="cb8-22"><a href="#cb8-22"></a>        <span class="cf">while</span>(tp&gt;=<span class="dv">1</span>&amp;&amp;solve(s[tp],nds[i])&lt;-eps)tp--;</span>
<span id="cb8-23"><a href="#cb8-23"></a>        <span class="cf">while</span>(tp&gt;=<span class="dv">2</span>&amp;&amp;solve(s[tp-<span class="dv">1</span>],s[tp])&gt;solve(s[tp],nds[i]))tp--;</span>
<span id="cb8-24"><a href="#cb8-24"></a>        s[++tp]=nds[i]; ans[tp]=nds[i].id;</span>
<span id="cb8-25"><a href="#cb8-25"></a>    }</span>
<span id="cb8-26"><a href="#cb8-26"></a>    sort(ans+<span class="dv">1</span>,ans+<span class="dv">1</span>+tp); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,tp);</span>
<span id="cb8-27"><a href="#cb8-27"></a>    inc(i,<span class="dv">1</span>,tp){</span>
<span id="cb8-28"><a href="#cb8-28"></a>        i==tp?printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans[i]):printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>,ans[i]);</span>
<span id="cb8-29"><a href="#cb8-29"></a>    }</span>
<span id="cb8-30"><a href="#cb8-30"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb8-31"><a href="#cb8-31"></a>}</span></code></pre></div>
<h3 id="bzoj1007hnoi2008水平可见直线2016.4.7">bzoj1007[HNOI2008]水平可见直线（2016.4.7）</h3>
<h4 id="题意-8">题意</h4>
<p>平面上有n条直线L1,L2,…Ln,若在y值为正无穷大处往下看,能见到Li的某个子线段,则称Li为可见的,否则Li为被覆盖的。给出n条直线,已知其斜率和截距,且n条直线两两不重合，求出所有可见的直线。</p>
<h4 id="题解-8">题解</h4>
<p>和bzoj3190差不多，但是因为是比较随意的直线，所以还要多一些判断条件。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="pp">#define eps </span><span class="fl">1e-8</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">struct</span> nd{</span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="dt">int</span> a,b,id;</span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd&amp; x)<span class="at">const</span>{</span>
<span id="cb9-12"><a href="#cb9-12"></a>        <span class="cf">if</span>(a!=x.a)<span class="cf">return</span> a&lt;x.a; <span class="cf">return</span> b&lt;x.b;</span>
<span id="cb9-13"><a href="#cb9-13"></a>    }</span>
<span id="cb9-14"><a href="#cb9-14"></a>};</span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="dt">double</span> solve(nd a,nd b){</span>
<span id="cb9-16"><a href="#cb9-16"></a>    <span class="cf">return</span> (<span class="dt">double</span>)(a.b-b.b)/(<span class="dt">double</span>)(b.a-a.a);</span>
<span id="cb9-17"><a href="#cb9-17"></a>}</span>
<span id="cb9-18"><a href="#cb9-18"></a>nd nds[<span class="dv">100000</span>],s[<span class="dv">100000</span>]; <span class="dt">int</span> ans[<span class="dv">100000</span>],n,tp;</span>
<span id="cb9-19"><a href="#cb9-19"></a><span class="dt">int</span> main(){</span>
<span id="cb9-20"><a href="#cb9-20"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n);inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;nds[i].a),scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;nds[i].b),nds[i].id=i; sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+n);</span>
<span id="cb9-21"><a href="#cb9-21"></a>    tp=<span class="dv">1</span>;s[tp]=nds[<span class="dv">1</span>];ans[tp]=nds[<span class="dv">1</span>].id;</span>
<span id="cb9-22"><a href="#cb9-22"></a>    inc(i,<span class="dv">2</span>,n){</span>
<span id="cb9-23"><a href="#cb9-23"></a>        <span class="cf">if</span>(nds[i].a-s[tp].a==<span class="dv">0</span>)tp--;</span>
<span id="cb9-24"><a href="#cb9-24"></a>        <span class="cf">while</span>(tp&gt;=<span class="dv">2</span>&amp;&amp;solve(s[tp-<span class="dv">1</span>],s[tp])&gt;=solve(s[tp],nds[i]))tp--;</span>
<span id="cb9-25"><a href="#cb9-25"></a>        s[++tp]=nds[i]; ans[tp]=nds[i].id;</span>
<span id="cb9-26"><a href="#cb9-26"></a>    }</span>
<span id="cb9-27"><a href="#cb9-27"></a>    sort(ans+<span class="dv">1</span>,ans+<span class="dv">1</span>+tp);inc(i,<span class="dv">1</span>,tp)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>,ans[i]);</span>
<span id="cb9-28"><a href="#cb9-28"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb9-29"><a href="#cb9-29"></a>}</span></code></pre></div>
<h3 id="bzoj3289mato的文件管理2016.4.8">bzoj3289Mato的文件管理（2016.4.8）</h3>
<h4 id="题意-9">题意</h4>
<p>一共有n份资料，每天随机选一个区间[l,r]，Mato按文件从小到大的顺序看编号在此区间内的这些资料。他先把要看的文件按编号顺序依次拷贝出来，再用排序程序给文件大小排序。求每天排序时的交换次数。</p>
<h4 id="题解-9">题解</h4>
<p>还是莫队，但是转移的时候用树状数组维护逆序对个数，总复杂度为O(nsqrt(n)log2n)。因为是从大到小插入的，所以维护时要用r-l+1减。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="pp">#define lowbit</span>(a)<span class="pp"> </span>a&amp;(-a)</span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">struct</span> nd1{<span class="dt">int</span> x,y;};</span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="dt">bool</span> cmp1(nd1 a,nd1 b){<span class="cf">return</span> a.x&lt;b.x;}</span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="kw">struct</span> nd2{<span class="dt">int</span> l,pl,r; ll ans; <span class="dt">int</span> id;};</span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="dt">bool</span> cmp2(nd2 a,nd2 b){<span class="cf">if</span>(a.pl!=b.pl)<span class="cf">return</span> a.pl&lt;b.pl; <span class="cf">if</span>(a.r!=b.r)<span class="cf">return</span> a.r&lt;b.r; <span class="cf">return</span> a.l&lt;b.l;}</span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="dt">bool</span> cmp3(nd2 a,nd2 b){<span class="cf">return</span> a.id&lt;b.id;}</span>
<span id="cb10-15"><a href="#cb10-15"></a>ll c[<span class="dv">100000</span>],ans,l,r; <span class="dt">int</span> n,q,ls[<span class="dv">100000</span>],pos[<span class="dv">100000</span>]; nd1 f[<span class="dv">100000</span>]; nd2 ask[<span class="dv">100000</span>];</span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="kw">inline</span> <span class="dt">void</span> add(<span class="dt">int</span> x,ll y){<span class="cf">while</span>(x&lt;=n)c[x]+=y,x+=lowbit(x);}</span>
<span id="cb10-17"><a href="#cb10-17"></a><span class="kw">inline</span> ll query(<span class="dt">int</span> x){ll qy=<span class="dv">0</span>; <span class="cf">while</span>(x&gt;=<span class="dv">1</span>)qy+=c[x],x-=lowbit(x); <span class="cf">return</span> qy;}</span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="dt">int</span> main(){</span>
<span id="cb10-19"><a href="#cb10-19"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;f[i].x),f[i].y=i; sort(f+<span class="dv">1</span>,f+n+<span class="dv">1</span>,cmp1);</span>
<span id="cb10-20"><a href="#cb10-20"></a>    inc(i,<span class="dv">1</span>,n)ls[f[i].y]=i; <span class="dt">int</span> sz=(<span class="dt">int</span>)sqrt(n); inc(i,<span class="dv">1</span>,n)pos[i]=(i-<span class="dv">1</span>)/sz+<span class="dv">1</span>;</span>
<span id="cb10-21"><a href="#cb10-21"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;q); inc(i,<span class="dv">1</span>,q){<span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b); ask[i]=(nd2){a,pos[a],b,<span class="dv">0</span>,i};}</span>
<span id="cb10-22"><a href="#cb10-22"></a>    sort(ask+<span class="dv">1</span>,ask+<span class="dv">1</span>+q,cmp2); memset(c,<span class="dv">0</span>,<span class="kw">sizeof</span>(c)); ans=<span class="dv">0</span>; l=<span class="dv">1</span>; r=<span class="dv">0</span>;</span>
<span id="cb10-23"><a href="#cb10-23"></a>    inc(i,<span class="dv">1</span>,q){</span>
<span id="cb10-24"><a href="#cb10-24"></a>        <span class="cf">while</span>(r&lt;ask[i].r){<span class="dt">int</span> x=r+<span class="dv">1</span>; x=n-ls[x]; ll a1=query(x); ans+=a1; add(x+<span class="dv">1</span>,<span class="dv">1</span>); r++;}</span>
<span id="cb10-25"><a href="#cb10-25"></a>        <span class="cf">while</span>(l&gt;ask[i].l){<span class="dt">int</span> x=l-<span class="dv">1</span>; x=n-ls[x]; ll a1=(r-l+<span class="dv">1</span>)-query(x); ans+=a1; add(x+<span class="dv">1</span>,<span class="dv">1</span>); l--;}</span>
<span id="cb10-26"><a href="#cb10-26"></a>        <span class="cf">while</span>(r&gt;ask[i].r){<span class="dt">int</span> x=r; x=n-ls[x]; ll a1=query(x); ans-=a1; add(x+<span class="dv">1</span>,-<span class="dv">1</span>); r--;}</span>
<span id="cb10-27"><a href="#cb10-27"></a>        <span class="cf">while</span>(l&lt;ask[i].l){<span class="dt">int</span> x=l; x=n-ls[x]; ll a1=(r-l)-query(x); ans-=a1; add(x+<span class="dv">1</span>,-<span class="dv">1</span>); l++;}</span>
<span id="cb10-28"><a href="#cb10-28"></a>        ask[i].ans=ans;</span>
<span id="cb10-29"><a href="#cb10-29"></a>    }</span>
<span id="cb10-30"><a href="#cb10-30"></a>    sort(ask+<span class="dv">1</span>,ask+<span class="dv">1</span>+q,cmp3); inc(i,<span class="dv">1</span>,q)printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,ask[i].ans);</span>
<span id="cb10-31"><a href="#cb10-31"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-32"><a href="#cb10-32"></a>}</span></code></pre></div>
<h3 id="bzoj2456mode2016.4.8">bzoj2456mode（2016.4.8）</h3>
<h4 id="题意-10">题意</h4>
<p>给你一个n个数的数列，求出现次数超过n div 2的数（只有1个）。</p>
<h4 id="题解-10">题解</h4>
<p>注意空间只有1M，显然不能开数组。用两个变量，一个存“当前数”，另一个存“当前数”的个数，如果读入的数与“当前数”相同就个数加一，如果不同就减一。如果个数减到0就换“当前数”为现在读入的数。因为如果那个“众数”个数超过ndiv2，所以一定不会被其他数抵消完，能够“坚持”到最后，所以答案就是最后的那个“当前数”。思路真巧。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="dt">int</span> main(){</span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="dt">int</span> n,x,t,tot; tot=<span class="dv">0</span>; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n);</span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="cf">while</span>(n--){</span>
<span id="cb11-6"><a href="#cb11-6"></a>        scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x);</span>
<span id="cb11-7"><a href="#cb11-7"></a>        <span class="cf">if</span>(tot==<span class="dv">0</span>)t=x,tot=<span class="dv">1</span>;<span class="cf">else</span> <span class="cf">if</span>(x==t)tot++;<span class="cf">else</span> tot--;</span>
<span id="cb11-8"><a href="#cb11-8"></a>    }</span>
<span id="cb11-9"><a href="#cb11-9"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,t);</span>
<span id="cb11-10"><a href="#cb11-10"></a>}</span></code></pre></div>
<h3 id="bzoj3504cqoi2014危桥2016.4.8">bzoj3504[Cqoi2014]危桥（2016.4.8）</h3>
<h4 id="题意-11">题意</h4>
<p>有N座岛屿，某些岛屿之间有桥相连，桥上的道路是双向的，但一次只能供一人通行。其中一些桥是危桥。Alice希望在岛屿al和a2之间往返an次（从al到a2再从a2 到al算一次往返）。同时，Bob希望在岛屿bl和b2之间往返bn次。这个过程中，所有危桥最多通行两次，其余的桥可以无限次通行。判断两人能否达成愿望。</p>
<h4 id="题解-11">题解</h4>
<p>网络流，每天边的容量就是这条边可以走几次，建一个超级源连a1b1，a2b2连超级汇，如果最大流大于等于2*(b1+b2)就行。但有可能出现a1流到b2导致原来的不可行被判断成可行，这样我们就需要把b2和b1调换位置，如果结果一样，说明这个方案是真正可行的，具体原因我还不懂，好像是如果两个结果一样，即使真的出现了a1流到b2的情况，也能通过调整变成正确的流动方案，蒟蒻太弱了！</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,c,n;}; e es[<span class="dv">10000</span>]; <span class="dt">int</span> ess,g[<span class="dv">100</span>];</span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c){es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,g[t]}; g[t]=ess;}</span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="dt">char</span> map[<span class="dv">100</span>][<span class="dv">100</span>]; <span class="dt">int</span> n,a1,a2,an,b1,b2,bn,s,t;</span>
<span id="cb12-12"><a href="#cb12-12"></a>queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> h[<span class="dv">100</span>];</span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb12-14"><a href="#cb12-14"></a>    <span class="cf">while</span>(! q.empty())q.pop(); memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); h[s]=<span class="dv">0</span>; q.push(s);</span>
<span id="cb12-15"><a href="#cb12-15"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb12-16"><a href="#cb12-16"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb12-17"><a href="#cb12-17"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==-<span class="dv">1</span>)h[es[i].t]=h[x]+<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb12-18"><a href="#cb12-18"></a>    }</span>
<span id="cb12-19"><a href="#cb12-19"></a>    <span class="cf">if</span>(h[t]==-<span class="dv">1</span>)<span class="cf">return</span> <span class="dv">0</span>;<span class="cf">else</span> <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb12-20"><a href="#cb12-20"></a>}</span>
<span id="cb12-21"><a href="#cb12-21"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> t,<span class="dt">int</span> f){</span>
<span id="cb12-22"><a href="#cb12-22"></a>    <span class="cf">if</span>(x==t)<span class="cf">return</span> f; <span class="dt">int</span> u=<span class="dv">0</span>;</span>
<span id="cb12-23"><a href="#cb12-23"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==h[x]+<span class="dv">1</span>){</span>
<span id="cb12-24"><a href="#cb12-24"></a>        <span class="dt">int</span> w=dfs(es[i].t,t,min(f,es[i].c)); es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; f-=w; u+=w;</span>
<span id="cb12-25"><a href="#cb12-25"></a>        <span class="cf">if</span>(f==<span class="dv">0</span>)<span class="cf">return</span> u;</span>
<span id="cb12-26"><a href="#cb12-26"></a>    }</span>
<span id="cb12-27"><a href="#cb12-27"></a>    <span class="cf">if</span>(u==<span class="dv">0</span>)h[x]=-<span class="dv">1</span>; <span class="cf">return</span> u;</span>
<span id="cb12-28"><a href="#cb12-28"></a>}</span>
<span id="cb12-29"><a href="#cb12-29"></a><span class="dt">int</span> dinic(<span class="dt">int</span> s,<span class="dt">int</span> t){<span class="dt">int</span> f=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))f+=dfs(s,t,INF); <span class="cf">return</span> f;}</span>
<span id="cb12-30"><a href="#cb12-30"></a><span class="dt">int</span> main(){</span>
<span id="cb12-31"><a href="#cb12-31"></a>    <span class="cf">while</span>(scanf(<span class="st">&quot;</span><span class="sc">%d%d%d%d%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;a1,&amp;a2,&amp;an,&amp;b1,&amp;b2,&amp;bn)!=EOF){</span>
<span id="cb12-32"><a href="#cb12-32"></a>        inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,map[i]); a1++; a2++; b1++; b2++; s=<span class="dv">0</span>; t=n+<span class="dv">1</span>;</span>
<span id="cb12-33"><a href="#cb12-33"></a>        ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g)); pe(s,a1,<span class="dv">2</span>*an); pe(s,b1,<span class="dv">2</span>*bn); pe(a2,t,<span class="dv">2</span>*an); pe(b2,t,<span class="dv">2</span>*bn);</span>
<span id="cb12-34"><a href="#cb12-34"></a>        inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">0</span>,n-<span class="dv">1</span>){</span>
<span id="cb12-35"><a href="#cb12-35"></a>            <span class="cf">if</span>(map[i][j]==<span class="ch">&#39;O&#39;</span>)pe(i,j+<span class="dv">1</span>,<span class="dv">2</span>);</span>
<span id="cb12-36"><a href="#cb12-36"></a>            <span class="cf">if</span>(map[i][j]==<span class="ch">&#39;N&#39;</span>)pe(i,j+<span class="dv">1</span>,INF);</span>
<span id="cb12-37"><a href="#cb12-37"></a>        }</span>
<span id="cb12-38"><a href="#cb12-38"></a>        <span class="cf">if</span>(dinic(s,t)&gt;=<span class="dv">2</span>*an+<span class="dv">2</span>*bn){</span>
<span id="cb12-39"><a href="#cb12-39"></a>            ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g)); pe(s,a1,<span class="dv">2</span>*an); pe(s,b2,<span class="dv">2</span>*bn); pe(a2,t,<span class="dv">2</span>*an); pe(b1,t,<span class="dv">2</span>*bn);</span>
<span id="cb12-40"><a href="#cb12-40"></a>            inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">0</span>,n-<span class="dv">1</span>){</span>
<span id="cb12-41"><a href="#cb12-41"></a>                <span class="cf">if</span>(map[i][j]==<span class="ch">&#39;O&#39;</span>)pe(i,j+<span class="dv">1</span>,<span class="dv">2</span>);</span>
<span id="cb12-42"><a href="#cb12-42"></a>                <span class="cf">if</span>(map[i][j]==<span class="ch">&#39;N&#39;</span>)pe(i,j+<span class="dv">1</span>,INF);</span>
<span id="cb12-43"><a href="#cb12-43"></a>            }</span>
<span id="cb12-44"><a href="#cb12-44"></a>            <span class="cf">if</span>(dinic(s,t)&gt;=<span class="dv">2</span>*an+<span class="dv">2</span>*bn)printf(<span class="st">&quot;Yes</span><span class="sc">\n</span><span class="st">&quot;</span>);<span class="cf">else</span> printf(<span class="st">&quot;No</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb12-45"><a href="#cb12-45"></a>        }<span class="cf">else</span> printf(<span class="st">&quot;No</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb12-46"><a href="#cb12-46"></a>    }</span>
<span id="cb12-47"><a href="#cb12-47"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb12-48"><a href="#cb12-48"></a>}</span></code></pre></div>
<h3 id="bzoj2705sdoi2012longge的问题2016.4.8">bzoj2705[SDOI2012]Longge的问题（2016.4.8）</h3>
<h4 id="题意-12">题意</h4>
<p>给定一个整数N，求出<span class="math inline">\(\sum_{i=1}^N{gcd(i, N)}\)</span>。</p>
<h4 id="题解-12">题解</h4>
<p>欧拉函数就是求比一个正整数且和它互质的正整数有几个，我不会，摘黄学长的题解：</p>
<blockquote>
<p>题目中要求出<span class="math inline">\(\sum_{i=1}^N{gcd(i, N)}\)</span>。 枚举n的约数k，令s(k)为满足gcd(m,n)=k,(1&lt;=m&lt;=n)的m的个数，则<span class="math inline">\(ans=\sum_k{k*s(k)},n|k\)</span> 因为gcd(m,n)=k,所以gcd(m/k,n/k)=1,于是s(k)=euler(n/k)</p>
</blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="dt">long</span> <span class="dt">long</span> phi(<span class="dt">long</span> <span class="dt">long</span> x){</span>
<span id="cb13-9"><a href="#cb13-9"></a>    <span class="dt">long</span> <span class="dt">long</span> a1=x,a2=(<span class="dt">long</span> <span class="dt">long</span>)sqrt(x);</span>
<span id="cb13-10"><a href="#cb13-10"></a>    inc(i,<span class="dv">2</span>,a2)<span class="cf">if</span>(x%i==<span class="dv">0</span>){</span>
<span id="cb13-11"><a href="#cb13-11"></a>        a1=a1/i*(i-<span class="dv">1</span>); <span class="cf">while</span>(x%i==<span class="dv">0</span>)x/=i;</span>
<span id="cb13-12"><a href="#cb13-12"></a>    }</span>
<span id="cb13-13"><a href="#cb13-13"></a>    <span class="cf">if</span>(x!=<span class="dv">1</span>)a1=a1/x*(x-<span class="dv">1</span>); <span class="cf">return</span> a1;</span>
<span id="cb13-14"><a href="#cb13-14"></a>}</span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="dt">int</span> main(){</span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="dt">long</span> <span class="dt">long</span> n; scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;n); <span class="dt">long</span> <span class="dt">long</span> m=(<span class="dt">long</span> <span class="dt">long</span>)sqrt(n); <span class="dt">long</span> <span class="dt">long</span> ans=<span class="dv">0</span>;</span>
<span id="cb13-17"><a href="#cb13-17"></a>    inc(i,<span class="dv">1</span>,m)<span class="cf">if</span>(n%i==<span class="dv">0</span>){</span>
<span id="cb13-18"><a href="#cb13-18"></a>        ans+=i*phi(n/i); <span class="cf">if</span>(i*i&lt;=n)ans+=n/i*phi(i);</span>
<span id="cb13-19"><a href="#cb13-19"></a>    }</span>
<span id="cb13-20"><a href="#cb13-20"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans);</span>
<span id="cb13-21"><a href="#cb13-21"></a>}</span></code></pre></div>
<h3 id="bzoj3223tyvj-1729-文艺平衡树2016.4.18">bzoj3223Tyvj 1729 文艺平衡树（2016.4.18）</h3>
<h4 id="题意-13">题意</h4>
<p>一个数列，支持区间翻转操作。</p>
<h4 id="题解-13">题解</h4>
<p>splay裸题。注意涉及到区间操作的一般用splay不用treap。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="pp">#define fa</span>(x)<span class="pp"> </span>nds[x].fa</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="pp">#define ch</span>(x,y)<span class="pp"> </span>nds[x].ch[y]</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="pp">#define tg</span>(x)<span class="pp"> </span>nds[x].tg</span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="pp">#define v</span>(x)<span class="pp"> </span>nds[x].v</span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="pp">#define sz</span>(x)<span class="pp"> </span>nds[x].sz</span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb14-11"><a href="#cb14-11"></a></span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="kw">struct</span> nd{<span class="dt">int</span> fa,ch[<span class="dv">2</span>],v,sz,tg;};</span>
<span id="cb14-13"><a href="#cb14-13"></a>nd nds[<span class="dv">200000</span>]; <span class="dt">int</span> size,root,n,m; <span class="dt">bool</span> first;</span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb14-15"><a href="#cb14-15"></a>    <span class="cf">if</span>(! x)<span class="cf">return</span>; <span class="cf">if</span>(tg(x)){</span>
<span id="cb14-16"><a href="#cb14-16"></a>        <span class="cf">if</span>(ch(x,<span class="dv">0</span>)&amp;&amp;ch(x,<span class="dv">1</span>))swap(ch(x,<span class="dv">0</span>),ch(x,<span class="dv">1</span>)),tg(ch(x,<span class="dv">0</span>))^=<span class="dv">1</span>,tg(ch(x,<span class="dv">1</span>))^=<span class="dv">1</span>;<span class="cf">else</span></span>
<span id="cb14-17"><a href="#cb14-17"></a>        <span class="cf">if</span>(ch(x,<span class="dv">0</span>))ch(x,<span class="dv">1</span>)=ch(x,<span class="dv">0</span>),ch(x,<span class="dv">0</span>)=<span class="dv">0</span>,tg(ch(x,<span class="dv">1</span>))^=<span class="dv">1</span>;<span class="cf">else</span> ch(x,<span class="dv">0</span>)=ch(x,<span class="dv">1</span>),ch(x,<span class="dv">1</span>)=<span class="dv">0</span>,tg(ch(x,<span class="dv">0</span>))^=<span class="dv">1</span>;</span>
<span id="cb14-18"><a href="#cb14-18"></a>        tg(x)^=<span class="dv">1</span>;</span>
<span id="cb14-19"><a href="#cb14-19"></a>    }</span>
<span id="cb14-20"><a href="#cb14-20"></a>}</span>
<span id="cb14-21"><a href="#cb14-21"></a><span class="dt">void</span> update(<span class="dt">int</span> x){<span class="cf">if</span>(! x)<span class="cf">return</span>; sz(x)=sz(ch(x,<span class="dv">0</span>))+sz(ch(x,<span class="dv">1</span>))+<span class="dv">1</span>;}</span>
<span id="cb14-22"><a href="#cb14-22"></a><span class="dt">void</span> rotate(<span class="dt">int</span> x){</span>
<span id="cb14-23"><a href="#cb14-23"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||fa(x)==<span class="dv">0</span>)<span class="cf">return</span>;</span>
<span id="cb14-24"><a href="#cb14-24"></a>    <span class="dt">int</span> a1=fa(x),a2=fa(a1); <span class="dt">bool</span> a3=(x==ch(a1,<span class="dv">1</span>)),a4=(a1==ch(a2,<span class="dv">1</span>));</span>
<span id="cb14-25"><a href="#cb14-25"></a>    <span class="cf">if</span>(a2)ch(a2,a4)=x; <span class="cf">if</span>(ch(x,!a3))fa(ch(x,!a3))=a1; ch(a1,a3)=ch(x,!a3); ch(x,!a3)=a1;</span>
<span id="cb14-26"><a href="#cb14-26"></a>    fa(x)=a2; fa(a1)=x; update(a1); update(x); <span class="cf">if</span>(a2)update(a2);</span>
<span id="cb14-27"><a href="#cb14-27"></a>}</span>
<span id="cb14-28"><a href="#cb14-28"></a><span class="dt">void</span> splay(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb14-29"><a href="#cb14-29"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||y==<span class="dv">0</span>)<span class="cf">return</span>; <span class="dt">int</span> z=fa(y); <span class="cf">if</span>(y==root)root=x;</span>
<span id="cb14-30"><a href="#cb14-30"></a>    <span class="cf">while</span>(fa(x)!=z){</span>
<span id="cb14-31"><a href="#cb14-31"></a>        <span class="cf">if</span>(fa(fa(x))!=z){</span>
<span id="cb14-32"><a href="#cb14-32"></a>            <span class="cf">if</span>((x==ch(fa(x),<span class="dv">1</span>))^(fa(x)==ch(fa(fa(x)),<span class="dv">1</span>)))rotate(x);<span class="cf">else</span> rotate(fa(x));</span>
<span id="cb14-33"><a href="#cb14-33"></a>        }</span>
<span id="cb14-34"><a href="#cb14-34"></a>        rotate(x);</span>
<span id="cb14-35"><a href="#cb14-35"></a>    }</span>
<span id="cb14-36"><a href="#cb14-36"></a>}</span>
<span id="cb14-37"><a href="#cb14-37"></a><span class="dt">int</span> build(<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb14-38"><a href="#cb14-38"></a>    <span class="cf">if</span>(l&gt;r)<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-39"><a href="#cb14-39"></a>    ++size; <span class="dt">int</span> ff=size; <span class="dt">int</span> m=(l+r)&gt;&gt;<span class="dv">1</span>; ch(ff,<span class="dv">0</span>)=build(l,m-<span class="dv">1</span>); ch(ff,<span class="dv">1</span>)=build(m+<span class="dv">1</span>,r);</span>
<span id="cb14-40"><a href="#cb14-40"></a>    <span class="cf">if</span>(ch(ff,<span class="dv">0</span>))fa(ch(ff,<span class="dv">0</span>))=ff; <span class="cf">if</span>(ch(ff,<span class="dv">1</span>))fa(ch(ff,<span class="dv">1</span>))=ff;</span>
<span id="cb14-41"><a href="#cb14-41"></a>    v(ff)=m; tg(ff)=<span class="dv">0</span>; update(ff); <span class="cf">return</span> ff;</span>
<span id="cb14-42"><a href="#cb14-42"></a>}</span>
<span id="cb14-43"><a href="#cb14-43"></a><span class="dt">int</span> find(<span class="dt">int</span> p){</span>
<span id="cb14-44"><a href="#cb14-44"></a>    <span class="dt">int</span> x=root; <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb14-45"><a href="#cb14-45"></a>        <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">0</span>; pushdown(x);</span>
<span id="cb14-46"><a href="#cb14-46"></a>        <span class="dt">int</span> a1=sz(ch(x,<span class="dv">0</span>)); <span class="cf">if</span>(a1+<span class="dv">1</span>==p)<span class="cf">return</span> x;</span>
<span id="cb14-47"><a href="#cb14-47"></a>        <span class="cf">if</span>(a1+<span class="dv">1</span>&lt;p)p-=(a1+<span class="dv">1</span>),x=ch(x,<span class="dv">1</span>);<span class="cf">else</span> x=ch(x,<span class="dv">0</span>);</span>
<span id="cb14-48"><a href="#cb14-48"></a>    }</span>
<span id="cb14-49"><a href="#cb14-49"></a>}</span>
<span id="cb14-50"><a href="#cb14-50"></a><span class="dt">void</span> rever(<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb14-51"><a href="#cb14-51"></a>    <span class="dt">int</span> a1=find(l-<span class="dv">1</span>),a2=find(r+<span class="dv">1</span>); splay(a2,root);</span>
<span id="cb14-52"><a href="#cb14-52"></a>    <span class="cf">if</span>(l&gt;<span class="dv">1</span>)splay(a1,ch(a2,<span class="dv">0</span>)),tg(ch(a1,<span class="dv">1</span>))^=<span class="dv">1</span>;<span class="cf">else</span> tg(ch(a2,<span class="dv">0</span>))=<span class="dv">1</span>;</span>
<span id="cb14-53"><a href="#cb14-53"></a>}</span>
<span id="cb14-54"><a href="#cb14-54"></a><span class="dt">void</span> print(<span class="dt">int</span> x){</span>
<span id="cb14-55"><a href="#cb14-55"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>; pushdown(x);</span>
<span id="cb14-56"><a href="#cb14-56"></a>    print(ch(x,<span class="dv">0</span>));</span>
<span id="cb14-57"><a href="#cb14-57"></a>    <span class="cf">if</span>(v(x)!=n+<span class="dv">1</span>)</span>
<span id="cb14-58"><a href="#cb14-58"></a>        <span class="cf">if</span>(!first)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,v(x)),first=<span class="dv">1</span>;<span class="cf">else</span> printf(<span class="st">&quot; </span><span class="sc">%d</span><span class="st">&quot;</span>,v(x));</span>
<span id="cb14-59"><a href="#cb14-59"></a>    print(ch(x,<span class="dv">1</span>));</span>
<span id="cb14-60"><a href="#cb14-60"></a>}</span>
<span id="cb14-61"><a href="#cb14-61"></a><span class="dt">int</span> main(){</span>
<span id="cb14-62"><a href="#cb14-62"></a>    <span class="co">//freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin);</span></span>
<span id="cb14-63"><a href="#cb14-63"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); size=<span class="dv">0</span>; root=build(<span class="dv">1</span>,n+<span class="dv">1</span>);</span>
<span id="cb14-64"><a href="#cb14-64"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb14-65"><a href="#cb14-65"></a>        <span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b); rever(a,b);</span>
<span id="cb14-66"><a href="#cb14-66"></a>    }</span>
<span id="cb14-67"><a href="#cb14-67"></a>    first=<span class="dv">0</span>; print(root);</span>
<span id="cb14-68"><a href="#cb14-68"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-69"><a href="#cb14-69"></a>}</span></code></pre></div>
<h3 id="bzoj2299haoi2011向量2016.4.18">bzoj2299[HAOI2011]向量（2016.4.18）</h3>
<h4 id="题意-14">题意</h4>
<p>有(a,b), (a,-b), (-a,b), (-a,-b), (b,a), (b,-a), (-b,a), (-b,-a)这些向量，问能否拼出另一个向量(x,y)。</p>
<h4 id="题解-14">题解</h4>
<p>裴蜀定理（我不会）（实际上是与解同余方程的知识相关的）。题目可以转化为用(0,2a)、(2a,0)、(0,2b)、(2b,0)拼成(x,y)、(x+a,y+b)、(x+b,y+a)、(x+a+b,y+a+b)。这样就可以列方程了。题目要求判断方程是否有解，只要求出2a、2b的gcd，然后判断目标两个数能否整除这个gcd即可。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="dt">long</span> <span class="dt">long</span> gcd(<span class="dt">long</span> <span class="dt">long</span> a,<span class="dt">long</span> <span class="dt">long</span> b){<span class="cf">return</span> b==<span class="dv">0</span>?a:gcd(b,a%b);}</span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="kw">inline</span> <span class="dt">bool</span> check(<span class="dt">long</span> <span class="dt">long</span> x,<span class="dt">long</span> <span class="dt">long</span> y,<span class="dt">long</span> <span class="dt">long</span> z){<span class="cf">return</span> x%z==<span class="dv">0</span>&amp;&amp;y%z==<span class="dv">0</span>;}</span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="dt">int</span> main(){</span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="dt">int</span> t; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;t);</span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="cf">while</span>(t--){</span>
<span id="cb15-11"><a href="#cb15-11"></a>        <span class="dt">long</span> <span class="dt">long</span> a,b,x,y; scanf(<span class="st">&quot;</span><span class="sc">%lld%lld%lld%lld</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;x,&amp;y);</span>
<span id="cb15-12"><a href="#cb15-12"></a>        <span class="dt">long</span> <span class="dt">long</span> c=gcd(<span class="dv">2</span>*a,<span class="dv">2</span>*b);</span>
<span id="cb15-13"><a href="#cb15-13"></a>        <span class="cf">if</span>(check(x,y,c)||check(x+a,y+b,c)||check(x+b,y+a,c)||check(x+a+b,y+a+b,c))puts(<span class="st">&quot;Y&quot;</span>);<span class="cf">else</span> puts(<span class="st">&quot;N&quot;</span>);</span>
<span id="cb15-14"><a href="#cb15-14"></a>    }</span>
<span id="cb15-15"><a href="#cb15-15"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-16"><a href="#cb15-16"></a>}</span></code></pre></div>
<h3 id="bzoj3442学习小组2016.4.18">bzoj3442学习小组（2016.4.18）</h3>
<h4 id="题意-15">题意</h4>
<p>共有n个学生，m个学习小组，每个学生只愿意参加其中的一些学习小组，且一个学生最多参加k个学习小组。每个学生参加学习小组财务处都收一定的手续费，不同的学习小组有不同的手续费。若有a个学生参加第i个学习小组，财务处支付奖励Ci*a^2元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱。</p>
<h4 id="题解-15">题解</h4>
<p>s连n个学生，流量为k，费用为0。每个学生向喜欢的小组的连边，流量为1，费用为手续费的相反数。每个小组向t连边，它的费用与流量的平方成正比的边，需要把它拆成k条流量为1，费用为1*ci、3*ci…(2*k-1)的边。本题的难点是要参与学生尽量多，所以我们需要每个学生至少参加一个组，因此每个学生再向t连一条流量为k-1，费用为0的边，就可以了。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="pp">#define visit</span>(i,j)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=g[j];i!=-<span class="dv">1</span>;i=es[i].n)</span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,c,w,n;}; e es[<span class="dv">1000000</span>]; <span class="dt">int</span> ess,g[<span class="dv">400</span>];</span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c,<span class="dt">int</span> w){</span>
<span id="cb16-12"><a href="#cb16-12"></a>    es[++ess]=(e){f,t,c,w,g[f]}; g[f]=ess; es[++ess]=(e){t,f,<span class="dv">0</span>,-w,g[t]}; g[t]=ess;</span>
<span id="cb16-13"><a href="#cb16-13"></a>}</span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="dt">void</span> init(){ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="dt">int</span> d[<span class="dv">400</span>],fr[<span class="dv">400</span>]; queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">bool</span> inq[<span class="dv">400</span>],vis[<span class="dv">400</span>];</span>
<span id="cb16-16"><a href="#cb16-16"></a><span class="dt">bool</span> spfa(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb16-17"><a href="#cb16-17"></a>    <span class="cf">while</span>(! q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis));</span>
<span id="cb16-18"><a href="#cb16-18"></a>    inq[s]=<span class="dv">1</span>; d[s]=<span class="dv">0</span>; vis[s]=<span class="dv">1</span>; q.push(s);</span>
<span id="cb16-19"><a href="#cb16-19"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb16-20"><a href="#cb16-20"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb16-21"><a href="#cb16-21"></a>        visit(i,x)<span class="cf">if</span>(es[i].c&amp;&amp;(! vis[es[i].t]||d[es[i].t]&gt;d[x]+es[i].w)){</span>
<span id="cb16-22"><a href="#cb16-22"></a>            d[es[i].t]=d[x]+es[i].w; vis[es[i].t]=<span class="dv">1</span>; fr[es[i].t]=i;</span>
<span id="cb16-23"><a href="#cb16-23"></a>            <span class="cf">if</span>(! inq[es[i].t])inq[es[i].t]=<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb16-24"><a href="#cb16-24"></a>        }</span>
<span id="cb16-25"><a href="#cb16-25"></a>    }</span>
<span id="cb16-26"><a href="#cb16-26"></a>    <span class="cf">if</span>(! vis[t])<span class="cf">return</span> <span class="dv">0</span>;<span class="cf">else</span> <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb16-27"><a href="#cb16-27"></a>}</span>
<span id="cb16-28"><a href="#cb16-28"></a><span class="dt">int</span> advanced(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb16-29"><a href="#cb16-29"></a>    <span class="dt">int</span> a=INF; <span class="cf">for</span>(<span class="dt">int</span> i=t;i!=s;i=es[fr[i]].f)a=min(a,es[fr[i]].c);</span>
<span id="cb16-30"><a href="#cb16-30"></a>    <span class="dt">int</span> cost=<span class="dv">0</span>; <span class="cf">for</span>(<span class="dt">int</span> i=t;i!=s;i=es[fr[i]].f)es[fr[i]].c-=a,es[fr[i]^<span class="dv">1</span>].c+=a,cost+=(es[fr[i]].w*a);</span>
<span id="cb16-31"><a href="#cb16-31"></a>    <span class="cf">return</span> cost;</span>
<span id="cb16-32"><a href="#cb16-32"></a>}</span>
<span id="cb16-33"><a href="#cb16-33"></a><span class="dt">int</span> maxflowmincost(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb16-34"><a href="#cb16-34"></a>    <span class="dt">int</span> cost=<span class="dv">0</span>; <span class="cf">while</span>(spfa(s,t))</span>
<span id="cb16-35"><a href="#cb16-35"></a>    cost+=advanced(s,t); <span class="cf">return</span> cost;</span>
<span id="cb16-36"><a href="#cb16-36"></a>}</span>
<span id="cb16-37"><a href="#cb16-37"></a><span class="dt">int</span> n,m,k,s,t,a1[<span class="dv">400</span>]; <span class="dt">char</span> a3[<span class="dv">400</span>];</span>
<span id="cb16-38"><a href="#cb16-38"></a><span class="dt">int</span> main(){</span>
<span id="cb16-39"><a href="#cb16-39"></a>    <span class="co">//freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin);</span></span>
<span id="cb16-40"><a href="#cb16-40"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m,&amp;k); s=<span class="dv">0</span>; t=n+m+<span class="dv">1</span>; init(); inc(i,<span class="dv">1</span>,n)pe(s,i,k,<span class="dv">0</span>),pe(i,t,k-<span class="dv">1</span>,<span class="dv">0</span>);</span>
<span id="cb16-41"><a href="#cb16-41"></a>    inc(i,n+<span class="dv">1</span>,n+m){<span class="dt">int</span> a2; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a2); inc(j,<span class="dv">1</span>,n)pe(i,t,<span class="dv">1</span>,(j*<span class="dv">2</span>-<span class="dv">1</span>)*a2);}</span>
<span id="cb16-42"><a href="#cb16-42"></a>    inc(i,<span class="dv">1</span>,m)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a1[i]); inc(i,<span class="dv">1</span>,n){</span>
<span id="cb16-43"><a href="#cb16-43"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,a3); inc(j,<span class="dv">1</span>,m){<span class="cf">if</span>(a3[j-<span class="dv">1</span>]==<span class="ch">&#39;1&#39;</span>)pe(i,n+j,<span class="dv">1</span>,-a1[j]);}</span>
<span id="cb16-44"><a href="#cb16-44"></a>    }</span>
<span id="cb16-45"><a href="#cb16-45"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,maxflowmincost(s,t));</span>
<span id="cb16-46"><a href="#cb16-46"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb16-47"><a href="#cb16-47"></a>}</span></code></pre></div>
<h3 id="bzoj2751haoi2012容易题easy2016.4.19">bzoj2751[HAOI2012]容易题(easy)（2016.4.19）</h3>
<h4 id="题意-16">题意</h4>
<p>已知一个数列A对于所有的A[i]都是1~n的自然数，一些A[i]不能取一些值，求出所有可能的数列的积的和 mod 1000000007的值。</p>
<h4 id="题解-16">题解</h4>
<p>题目中的n≤109实际上是10^9……首先推个方程s[l,r]=s[l,k]*s[k+1,r]（s[l,r]表示l到r的所有l≤i≤r的a[i]的可能取值的和)因此s[1,n]等于所有a[i]的可能取值的和的乘积。因此我们先求出1到n的和，对每个约束条件按i排序，将这个和减掉约束条件中的不能取的数，就是这个a[i]所有可能取值的和。将这些a[i]乘起来，剩下的没限制的a[i]用快速幂解决。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="pp">#define mod </span><span class="dv">1000000007</span></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb17-8"><a href="#cb17-8"></a></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="kw">struct</span> nd{</span>
<span id="cb17-10"><a href="#cb17-10"></a>    ll a,b;</span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd &amp;c)<span class="at">const</span>{</span>
<span id="cb17-12"><a href="#cb17-12"></a>        <span class="cf">if</span>(a!=c.a)<span class="cf">return</span> a&lt;c.a;<span class="cf">else</span> <span class="cf">return</span> b&lt;c.b;</span>
<span id="cb17-13"><a href="#cb17-13"></a>    }</span>
<span id="cb17-14"><a href="#cb17-14"></a>};</span>
<span id="cb17-15"><a href="#cb17-15"></a>ll power(ll a,ll b){</span>
<span id="cb17-16"><a href="#cb17-16"></a>    <span class="cf">if</span>(b==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">1</span>; <span class="cf">if</span>(b==<span class="dv">1</span>)<span class="cf">return</span> a; ll c=power(a,b&gt;&gt;<span class="dv">1</span>)%mod;</span>
<span id="cb17-17"><a href="#cb17-17"></a>    <span class="cf">if</span>(b&amp;<span class="dv">1</span>)<span class="cf">return</span> c*c%mod*a%mod;<span class="cf">else</span> <span class="cf">return</span> c*c%mod;</span>
<span id="cb17-18"><a href="#cb17-18"></a>}</span>
<span id="cb17-19"><a href="#cb17-19"></a>nd ns[<span class="dv">200000</span>];</span>
<span id="cb17-20"><a href="#cb17-20"></a><span class="dt">int</span> main(){</span>
<span id="cb17-21"><a href="#cb17-21"></a>    ll n,m,a1=<span class="dv">0</span>,a2,a3,a4; ll k; scanf(<span class="st">&quot;</span><span class="sc">%lld%lld%lld</span><span class="st">&quot;</span>,&amp;n,&amp;m,&amp;k);</span>
<span id="cb17-22"><a href="#cb17-22"></a>    inc(i,<span class="dv">1</span>,k)scanf(<span class="st">&quot;</span><span class="sc">%lld%lld</span><span class="st">&quot;</span>,&amp;ns[i].a,&amp;ns[i].b); sort(ns+<span class="dv">1</span>,ns+k+<span class="dv">1</span>);</span>
<span id="cb17-23"><a href="#cb17-23"></a>    inc(i,<span class="dv">1</span>,k)<span class="cf">if</span>(i==<span class="dv">1</span>||ns[i].a!=ns[i-<span class="dv">1</span>].a)a1++; a2=n*(n+<span class="dv">1</span>)/<span class="dv">2</span>%mod; a3=a4=<span class="dv">1</span>;</span>
<span id="cb17-24"><a href="#cb17-24"></a>    inc(i,<span class="dv">1</span>,k)<span class="cf">if</span>(i==<span class="dv">1</span>||ns[i].a!=ns[i-<span class="dv">1</span>].a)a4=a4*a3%mod,a3=a2,a3=(a3-ns[i].b)&gt;=<span class="dv">0</span>?(a3-ns[i].b)%mod:(a3-ns[i].b)+mod;</span>
<span id="cb17-25"><a href="#cb17-25"></a>    <span class="cf">else</span> <span class="cf">if</span>(ns[i].b!=ns[i-<span class="dv">1</span>].b)a3=(a3-ns[i].b)&gt;=<span class="dv">0</span>?(a3-ns[i].b)%mod:(a3-ns[i].b)+mod;</span>
<span id="cb17-26"><a href="#cb17-26"></a>    a4=a4*a3%mod; a4=a4*power(a2,m-a1)%mod; printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,a4);</span>
<span id="cb17-27"><a href="#cb17-27"></a>}</span></code></pre></div>
<h3 id="bzoj2843极地旅行社2016.4.20">bzoj2843极地旅行社（2016.4.20）</h3>
<h4 id="题意-17">题意</h4>
<p>一些点，每个点有一个权值。有三种操作：点与点连边，单点修改权值，求两点之间路径上点的权值和（需要判输入是否合法）</p>
<h4 id="题解-17">题解</h4>
<p>以前一直想不通为什么神犇们的模板中LCT在link和cut后都要在根节点打翻转标记。现在明白了，因为只有这样才能保持深度的正确性，以前没有因此炸过是因为我以前都是把LCT拿来当链剖用的，根本不用link和cut~~这道题是LCT模板题也没什么好说的。不过CCZ大爷有更快的做法，就是离线读入所有连边操作，然后建一棵树用链剖，判断输入是否合法就在线用并查集查询与维护。orzCCZ！</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="pp">#define maxn </span><span class="dv">50000</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb18-7"><a href="#cb18-7"></a></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="dt">int</span> fa[maxn],ch[maxn][<span class="dv">2</span>],sm[maxn],v[maxn];<span class="dt">bool</span> rev[maxn];</span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="kw">inline</span> <span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb18-10"><a href="#cb18-10"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>; sm[x]=v[x];</span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="cf">if</span>(ch[x][<span class="dv">0</span>])sm[x]+=sm[ch[x][<span class="dv">0</span>]]; <span class="cf">if</span>(ch[x][<span class="dv">1</span>])sm[x]+=sm[ch[x][<span class="dv">1</span>]];</span>
<span id="cb18-12"><a href="#cb18-12"></a>}</span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="kw">inline</span> <span class="dt">bool</span> is_root(<span class="dt">int</span> x){</span>
<span id="cb18-14"><a href="#cb18-14"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||fa[x]==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb18-15"><a href="#cb18-15"></a>    <span class="cf">return</span> x!=ch[fa[x]][<span class="dv">0</span>]&amp;&amp;x!=ch[fa[x]][<span class="dv">1</span>];</span>
<span id="cb18-16"><a href="#cb18-16"></a>}</span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="kw">inline</span> <span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb18-18"><a href="#cb18-18"></a>    <span class="cf">if</span>(rev[x]){</span>
<span id="cb18-19"><a href="#cb18-19"></a>        swap(ch[x][<span class="dv">0</span>],ch[x][<span class="dv">1</span>]); <span class="cf">if</span>(ch[x][<span class="dv">0</span>])rev[ch[x][<span class="dv">0</span>]]^=<span class="dv">1</span>; <span class="cf">if</span>(ch[x][<span class="dv">1</span>])rev[ch[x][<span class="dv">1</span>]]^=<span class="dv">1</span>; rev[x]^=<span class="dv">1</span>;</span>
<span id="cb18-20"><a href="#cb18-20"></a>    }</span>
<span id="cb18-21"><a href="#cb18-21"></a>}</span>
<span id="cb18-22"><a href="#cb18-22"></a><span class="dt">void</span> rotate(<span class="dt">int</span> x){</span>
<span id="cb18-23"><a href="#cb18-23"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||is_root(x))<span class="cf">return</span>;</span>
<span id="cb18-24"><a href="#cb18-24"></a>    <span class="dt">int</span> a1=fa[x],a2=fa[fa[x]],a3; <span class="dt">bool</span> b1=(x==ch[a1][<span class="dv">1</span>]),b2=(a1==ch[a2][<span class="dv">1</span>]),b3=is_root(a1); a3=ch[x][!b1];</span>
<span id="cb18-25"><a href="#cb18-25"></a>    <span class="cf">if</span>(!b3)ch[a2][b2]=x; fa[x]=a2; ch[a1][b1]=a3; <span class="cf">if</span>(a3)fa[a3]=a1; ch[x][!b1]=a1; fa[a1]=x;</span>
<span id="cb18-26"><a href="#cb18-26"></a>    update(a1); update(x); <span class="cf">if</span>(!b3)update(a2);</span>
<span id="cb18-27"><a href="#cb18-27"></a>}</span>
<span id="cb18-28"><a href="#cb18-28"></a><span class="dt">int</span> dt[maxn],dts,y;</span>
<span id="cb18-29"><a href="#cb18-29"></a><span class="dt">void</span> splay(<span class="dt">int</span> x){</span>
<span id="cb18-30"><a href="#cb18-30"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>; dts=<span class="dv">0</span>; y=x; <span class="cf">while</span>(! is_root(y))dt[++dts]=y,y=fa[y];</span>
<span id="cb18-31"><a href="#cb18-31"></a>    dt[++dts]=y; <span class="cf">while</span>(dts)pushdown(dt[dts]),dts--;</span>
<span id="cb18-32"><a href="#cb18-32"></a>    <span class="cf">while</span>(!is_root(x)){</span>
<span id="cb18-33"><a href="#cb18-33"></a>        <span class="cf">if</span>(!is_root(fa[x]))((x==ch[fa[x]][<span class="dv">1</span>])^(fa[x]==ch[fa[fa[x]]][<span class="dv">1</span>]))?rotate(x):rotate(fa[x]);</span>
<span id="cb18-34"><a href="#cb18-34"></a>        rotate(x);</span>
<span id="cb18-35"><a href="#cb18-35"></a>    }</span>
<span id="cb18-36"><a href="#cb18-36"></a>}</span>
<span id="cb18-37"><a href="#cb18-37"></a><span class="dt">int</span> access(<span class="dt">int</span> x){</span>
<span id="cb18-38"><a href="#cb18-38"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">0</span>; <span class="dt">int</span> t=<span class="dv">0</span>;</span>
<span id="cb18-39"><a href="#cb18-39"></a>    <span class="cf">while</span>(x){splay(x); ch[x][<span class="dv">1</span>]=t; update(x); <span class="cf">if</span>(t)fa[t]=x; t=x; x=fa[x];}</span>
<span id="cb18-40"><a href="#cb18-40"></a>    <span class="cf">return</span> t;</span>
<span id="cb18-41"><a href="#cb18-41"></a>}</span>
<span id="cb18-42"><a href="#cb18-42"></a><span class="dt">bool</span> link(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb18-43"><a href="#cb18-43"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||y==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">0</span>; access(x); splay(x); rev[x]^=<span class="dv">1</span>; fa[x]=y; <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb18-44"><a href="#cb18-44"></a>}</span>
<span id="cb18-45"><a href="#cb18-45"></a><span class="dt">int</span> querysum(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb18-46"><a href="#cb18-46"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||y==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">0</span>; <span class="cf">if</span>(x==y)<span class="cf">return</span> v[x]; access(x); <span class="dt">int</span> a=access(y); splay(x);</span>
<span id="cb18-47"><a href="#cb18-47"></a>    <span class="cf">if</span>(x==a)<span class="cf">return</span> v[a]+sm[ch[a][<span class="dv">1</span>]];<span class="cf">else</span> <span class="cf">return</span> sm[x]+v[a]+sm[ch[a][<span class="dv">1</span>]];</span>
<span id="cb18-48"><a href="#cb18-48"></a>}</span>
<span id="cb18-49"><a href="#cb18-49"></a><span class="dt">void</span> change(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb18-50"><a href="#cb18-50"></a>    splay(x); v[x]=y; update(x);</span>
<span id="cb18-51"><a href="#cb18-51"></a>}</span>
<span id="cb18-52"><a href="#cb18-52"></a><span class="dt">int</span> find(<span class="dt">int</span> x){</span>
<span id="cb18-53"><a href="#cb18-53"></a>    access(x); splay(x); <span class="cf">while</span>(ch[x][<span class="dv">0</span>])x=ch[x][<span class="dv">0</span>]; <span class="cf">return</span> x;</span>
<span id="cb18-54"><a href="#cb18-54"></a>}</span>
<span id="cb18-55"><a href="#cb18-55"></a><span class="dt">int</span> n,m; <span class="dt">char</span> s[<span class="dv">20</span>];</span>
<span id="cb18-56"><a href="#cb18-56"></a><span class="dt">int</span> main(){</span>
<span id="cb18-57"><a href="#cb18-57"></a>    <span class="co">//freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin);</span></span>
<span id="cb18-58"><a href="#cb18-58"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;v[i]),fa[i]=<span class="dv">0</span>,ch[i][<span class="dv">0</span>]=ch[i][<span class="dv">1</span>]=rev[i]=<span class="dv">0</span>,sm[i]=v[i]; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;m);</span>
<span id="cb18-59"><a href="#cb18-59"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb18-60"><a href="#cb18-60"></a>        <span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%s%d%d</span><span class="st">&quot;</span>,s,&amp;a,&amp;b);</span>
<span id="cb18-61"><a href="#cb18-61"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;b&#39;</span>){<span class="cf">if</span>(find(a)==find(b))puts(<span class="st">&quot;no&quot;</span>);<span class="cf">else</span> link(a,b),puts(<span class="st">&quot;yes&quot;</span>);}</span>
<span id="cb18-62"><a href="#cb18-62"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;p&#39;</span>)change(a,b);</span>
<span id="cb18-63"><a href="#cb18-63"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;e&#39;</span>)<span class="cf">if</span>(find(a)!=find(b))puts(<span class="st">&quot;impossible&quot;</span>);<span class="cf">else</span> printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,querysum(a,b));</span>
<span id="cb18-64"><a href="#cb18-64"></a>    }</span>
<span id="cb18-65"><a href="#cb18-65"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-66"><a href="#cb18-66"></a>}</span></code></pre></div>
<h3 id="bzoj2429haoi2006聪明的猴子2016.4.20">bzoj2429[HAOI2006]聪明的猴子（2016.4.20）</h3>
<h4 id="题意-18">题意</h4>
<p>平面上N个点(任意两个点的坐标都不相同)。现已知M个猴子的最大跳跃距离，还知道N个点坐标，统计有多少个猴子可以在所有点上觅食。</p>
<h4 id="题解-18">题解</h4>
<p>题目中隐含了一个条件，就是猴子可以从任意点出发。因此我们可以确定一个点，求出它到所有点的最小距离的最大值，然后判断每只猴子的跳跃距离是否大于等于这个最大值。这正是MST问题，用Kruscal排序后选的第n-1条边的长度就是根到所有点的最小距离的最大值。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="kw">struct</span> e{</span>
<span id="cb19-8"><a href="#cb19-8"></a>    <span class="dt">int</span> f,t,w;</span>
<span id="cb19-9"><a href="#cb19-9"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> e &amp;a)<span class="at">const</span>{<span class="cf">return</span> w&lt;a.w;};</span>
<span id="cb19-10"><a href="#cb19-10"></a>};</span>
<span id="cb19-11"><a href="#cb19-11"></a>e es[<span class="dv">2000000</span>]; <span class="dt">int</span> p[<span class="dv">2000</span>],n,m,a[<span class="dv">2000</span>],x[<span class="dv">2000</span>],y[<span class="dv">2000</span>];</span>
<span id="cb19-12"><a href="#cb19-12"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==p[x]?x:p[x]=find(p[x]);}</span>
<span id="cb19-13"><a href="#cb19-13"></a><span class="dt">int</span> main(){</span>
<span id="cb19-14"><a href="#cb19-14"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;m); inc(i,<span class="dv">1</span>,m)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a[i]); scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;x[i],&amp;y[i]);</span>
<span id="cb19-15"><a href="#cb19-15"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n)es[(i-<span class="dv">1</span>)*n+j]=(e){i,j,(x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i])};</span>
<span id="cb19-16"><a href="#cb19-16"></a>    sort(es+<span class="dv">1</span>,es+<span class="dv">1</span>+n*n); inc(i,<span class="dv">1</span>,n)p[i]=i; <span class="dt">int</span> tot=<span class="dv">0</span>,mx=<span class="dv">0</span>;</span>
<span id="cb19-17"><a href="#cb19-17"></a>    inc(i,<span class="dv">1</span>,n*n){</span>
<span id="cb19-18"><a href="#cb19-18"></a>        <span class="dt">int</span> a1=find(es[i].f),a2=find(es[i].t);</span>
<span id="cb19-19"><a href="#cb19-19"></a>        <span class="cf">if</span>(a1!=a2){</span>
<span id="cb19-20"><a href="#cb19-20"></a>            tot++; p[a2]=a1; <span class="cf">if</span>(tot==n-<span class="dv">1</span>)mx=es[i].w;</span>
<span id="cb19-21"><a href="#cb19-21"></a>        }</span>
<span id="cb19-22"><a href="#cb19-22"></a>    }</span>
<span id="cb19-23"><a href="#cb19-23"></a>    tot=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,m)<span class="cf">if</span>(a[i]*a[i]&gt;=mx)tot++; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,tot);</span>
<span id="cb19-24"><a href="#cb19-24"></a>}</span></code></pre></div>
<h3 id="bzoj2428haoi2006均分数据2016.4.21">bzoj2428[HAOI2006]均分数据（2016.4.21）</h3>
<h4 id="题意-19">题意</h4>
<p>已知N个正整数，将它们分成M组，使各组数据的数值和最平均，即各组的均方差最小，求最小均方差。</p>
<p><span class="math display">\[
\sigma=\sqrt{\frac{\sum_{i=1}^{n}{(x_i-\overline{x})^2}}{n}}
\]</span></p>
<p><span class="math display">\[
\overline{x}=\frac{\sum_{i=1}^{n}{x_i}}{n}
\]</span></p>
<p>其中<span class="math inline">\(\sigma\)</span>为均方差，<span class="math inline">\(\overline{x}\)</span>是各组数据和的平均值，<span class="math inline">\(x_i\)</span>为第i组数据的数值和。</p>
<h4 id="题解-19">题解</h4>
<p>神奇的模拟退火算法！它是爬山算法的加强版。爬山算法是一种贪心算法，对于每个状态，除非随机选出一个后继状态比它好，才会跳过去。但这样有可能“一叶障目不见泰山”，产生错误的答案。但模拟退火不一样，它如果找到一个后继状态比当前状态差，也有一定概率跳过去，但这概率和跳跃次数成反比。这样即使被“一叶障目”，也有机会绕过叶子，找到泰山。</p>
<blockquote>
<p>关于爬山算法与模拟退火，有一个有趣的比喻： 爬山算法：兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。 模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。</p>
</blockquote>
<p>这个算法写法实际上是模拟一个物理降温过程，然而对我这种物理渣~~只能背代码框架了QAQ</p>
<p>回到本题，首先给每个数据随机分到一个组，做5000次模拟退火。当温度比较高时跳跃不稳定，所以贪心一下，随机找一个数据，然后把它放进当前和最小的那个组；当温度渐低后，就随机找一个数据然后随机放组。关于退火的次数，网上题解里是10000，我试过1000会不能过，但是5000能过且比10000要快一倍，所以代码给出的是5000。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb20-9"><a href="#cb20-9"></a></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="dt">int</span> n,m,pos[<span class="dv">100</span>]; <span class="dt">double</span> a[<span class="dv">100</span>],sum[<span class="dv">100</span>],ave,mn,T,ans,pre;</span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="dt">void</span> solve(){</span>
<span id="cb20-12"><a href="#cb20-12"></a>     memset(sum,<span class="dv">0</span>,<span class="kw">sizeof</span>(sum)); inc(i,<span class="dv">1</span>,n)pos[i]=rand()%m+<span class="dv">1</span>,sum[pos[i]]+=a[i]; ans=<span class="dv">0</span>;</span>
<span id="cb20-13"><a href="#cb20-13"></a>     inc(i,<span class="dv">1</span>,m)ans+=(sum[i]-ave)*(sum[i]-ave); T=<span class="dv">10000</span>;</span>
<span id="cb20-14"><a href="#cb20-14"></a>     <span class="cf">while</span>(T&gt;<span class="fl">0.1</span>){</span>
<span id="cb20-15"><a href="#cb20-15"></a>         pre=ans; <span class="dt">int</span> x=rand()%n+<span class="dv">1</span>,y;</span>
<span id="cb20-16"><a href="#cb20-16"></a>         <span class="cf">if</span>(T&gt;<span class="dv">500</span>)y=min_element(sum+<span class="dv">1</span>,sum+<span class="dv">1</span>+m)-sum;<span class="cf">else</span> y=rand()%m+<span class="dv">1</span>; <span class="cf">if</span>(pos[x]==y)<span class="cf">continue</span>;</span>
<span id="cb20-17"><a href="#cb20-17"></a>         ans-=(sum[pos[x]]-ave)*(sum[pos[x]]-ave); ans+=(sum[pos[x]]-a[x]-ave)*(sum[pos[x]]-a[x]-ave);</span>
<span id="cb20-18"><a href="#cb20-18"></a>        ans-=(sum[y]-ave)*(sum[y]-ave); ans+=(sum[y]+a[x]-ave)*(sum[y]+a[x]-ave);</span>
<span id="cb20-19"><a href="#cb20-19"></a>         <span class="cf">if</span>(rand()%<span class="dv">10000</span>+<span class="dv">1</span>&gt;T&amp;&amp;ans&gt;pre)ans=pre;<span class="cf">else</span> sum[pos[x]]-=a[x],sum[y]+=a[x],pos[x]=y;</span>
<span id="cb20-20"><a href="#cb20-20"></a>         T*=<span class="fl">0.9</span>;</span>
<span id="cb20-21"><a href="#cb20-21"></a>     }</span>
<span id="cb20-22"><a href="#cb20-22"></a>     <span class="cf">if</span>(ans&lt;mn)mn=ans;</span>
<span id="cb20-23"><a href="#cb20-23"></a>}</span>
<span id="cb20-24"><a href="#cb20-24"></a><span class="dt">int</span> main(){</span>
<span id="cb20-25"><a href="#cb20-25"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lf</span><span class="st">&quot;</span>,&amp;a[i]),ave+=a[i],swap(a[i],a[rand()%i+<span class="dv">1</span>]);</span>
<span id="cb20-26"><a href="#cb20-26"></a>    ave/=(<span class="dt">double</span>)m; mn=INF; inc(i,<span class="dv">1</span>,<span class="dv">5000</span>)solve();</span>
<span id="cb20-27"><a href="#cb20-27"></a>    printf(<span class="st">&quot;%.2lf&quot;</span>,sqrt(mn/(<span class="dt">double</span>)m));</span>
<span id="cb20-28"><a href="#cb20-28"></a>}</span></code></pre></div>
<h3 id="bzoj4514sdoi2016数字配对2016.4.22">bzoj4514[Sdoi2016]数字配对（2016.4.22）</h3>
<h4 id="题意-20">题意</h4>
<p>有 n 种数字，第 i 种数字是 ai、有 bi 个，权值是 ci。若两个数字 ai、aj 满足ai 是 aj 的倍数且 ai/aj 是一个质数，那么这两个数字可以配对，并获得 ci×cj 的价值。一个数字只能参与一次配对，可以不参与配对。在获得的价值总和不小于 0 的前提下，求最多进行多少次配对。</p>
<h4 id="题解-20">题解</h4>
<p>费用流。本题难点是每个数字只能参加一次配对，很容易建错图。正解是先对每个数字分解质因数，按照质因数个数的奇偶建二分图。原因是质因数奇数个和质因数偶数个的两个数相除的商必定不是质数，巧妙地解决了问题。在判断质数方面，如果朴素判断肯定会T，所以可以先筛法求一个质数表，判断的时候直接枚举能否整除质数。因为√109≤32000，所以质数表只要到32000就行了。不过时间复杂度我不会算，本弱太弱了！</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(ll<span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="pp">#define INF </span><span class="dv">10000000000000000</span></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb21-10"><a href="#cb21-10"></a></span>
<span id="cb21-11"><a href="#cb21-11"></a>ll p[<span class="dv">32000</span>],cnt,mx; <span class="dt">bool</span> vis1[<span class="dv">32000</span>];</span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="dt">void</span> getprime(){</span>
<span id="cb21-13"><a href="#cb21-13"></a>    cnt=<span class="dv">0</span>; memset(vis1,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis1)); inc(i,<span class="dv">2</span>,(ll)sqrt(mx))<span class="cf">if</span>(! vis1[i]){</span>
<span id="cb21-14"><a href="#cb21-14"></a>        p[++cnt]=i; <span class="cf">for</span>(ll j=i;j&lt;=(ll)sqrt(mx);j+=i)vis1[j]=<span class="dv">1</span>;</span>
<span id="cb21-15"><a href="#cb21-15"></a>    }</span>
<span id="cb21-16"><a href="#cb21-16"></a>}</span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="kw">inline</span> <span class="dt">bool</span> is_prime(ll x){</span>
<span id="cb21-18"><a href="#cb21-18"></a>    <span class="cf">if</span>(x==<span class="dv">1</span>)<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb21-19"><a href="#cb21-19"></a>    inc(i,<span class="dv">1</span>,cnt){<span class="cf">if</span>(p[i]*p[i]&gt;x)<span class="cf">return</span> <span class="dv">1</span>; <span class="cf">if</span>(x%p[i]==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb21-20"><a href="#cb21-20"></a>}</span>
<span id="cb21-21"><a href="#cb21-21"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t;ll c,w;<span class="dt">int</span> n;}; e es[<span class="dv">1000000</span>]; <span class="dt">int</span> ess,g[<span class="dv">1000</span>];</span>
<span id="cb21-22"><a href="#cb21-22"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,ll c,ll w){</span>
<span id="cb21-23"><a href="#cb21-23"></a>    es[++ess]=(e){f,t,c,w,g[f]}; g[f]=ess; es[++ess]=(e){t,f,<span class="dv">0</span>,-w,g[t]}; g[t]=ess;</span>
<span id="cb21-24"><a href="#cb21-24"></a>}</span>
<span id="cb21-25"><a href="#cb21-25"></a><span class="dt">void</span> init(){ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb21-26"><a href="#cb21-26"></a>queue &lt;<span class="dt">int</span>&gt; q; ll d[<span class="dv">1000</span>],cost,flow; <span class="dt">int</span> fr[<span class="dv">1000</span>]; <span class="dt">bool</span> inq[<span class="dv">1000</span>],vis2[<span class="dv">1000</span>];</span>
<span id="cb21-27"><a href="#cb21-27"></a><span class="dt">bool</span> spfa(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb21-28"><a href="#cb21-28"></a>    <span class="cf">while</span>(! q.empty())q.pop(); memset(vis2,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis2)); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq));</span>
<span id="cb21-29"><a href="#cb21-29"></a>    q.push(s); vis2[s]=<span class="dv">1</span>; inq[s]=<span class="dv">1</span>; d[s]=<span class="dv">0</span>;</span>
<span id="cb21-30"><a href="#cb21-30"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb21-31"><a href="#cb21-31"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb21-32"><a href="#cb21-32"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;(!vis2[es[i].t]||d[es[i].t]&lt;d[x]+es[i].w)){</span>
<span id="cb21-33"><a href="#cb21-33"></a>            vis2[es[i].t]=<span class="dv">1</span>; d[es[i].t]=d[x]+es[i].w; fr[es[i].t]=i;</span>
<span id="cb21-34"><a href="#cb21-34"></a>            <span class="cf">if</span>(!inq[es[i].t])q.push(es[i].t),inq[es[i].t]=<span class="dv">1</span>;</span>
<span id="cb21-35"><a href="#cb21-35"></a>        }</span>
<span id="cb21-36"><a href="#cb21-36"></a>    }</span>
<span id="cb21-37"><a href="#cb21-37"></a>    <span class="cf">if</span>(!vis2[t])<span class="cf">return</span> <span class="dv">0</span>;<span class="cf">else</span> <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb21-38"><a href="#cb21-38"></a>}</span>
<span id="cb21-39"><a href="#cb21-39"></a>ll maxflowmaxcost(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb21-40"><a href="#cb21-40"></a>    flow=<span class="dv">0</span>; cost=<span class="dv">0</span>;</span>
<span id="cb21-41"><a href="#cb21-41"></a>    <span class="cf">while</span>(spfa(s,t)){</span>
<span id="cb21-42"><a href="#cb21-42"></a>        ll a=INF,b=<span class="dv">0</span>;<span class="cf">for</span>(<span class="dt">int</span> i=t;i!=s;i=es[fr[i]].f)a=min(a,es[fr[i]].c);</span>
<span id="cb21-43"><a href="#cb21-43"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=t;i!=s;i=es[fr[i]].f)es[fr[i]].c-=a,es[fr[i]^<span class="dv">1</span>].c+=a,b+=es[fr[i]].w; cost+=b*a; flow+=a;</span>
<span id="cb21-44"><a href="#cb21-44"></a>        <span class="cf">if</span>(cost&lt;<span class="dv">0</span>){flow-=(cost%b==<span class="dv">0</span>?cost/b:cost/b+<span class="dv">1</span>); <span class="cf">break</span>;}</span>
<span id="cb21-45"><a href="#cb21-45"></a>    }</span>
<span id="cb21-46"><a href="#cb21-46"></a>    <span class="cf">return</span> flow;</span>
<span id="cb21-47"><a href="#cb21-47"></a>}</span>
<span id="cb21-48"><a href="#cb21-48"></a>ll a[<span class="dv">1000</span>],b[<span class="dv">1000</span>],c[<span class="dv">1000</span>];<span class="dt">int</span> n,s,t,sing[<span class="dv">1000</span>],doub[<span class="dv">1000</span>],tot,singn,doubn;</span>
<span id="cb21-49"><a href="#cb21-49"></a><span class="dt">int</span> main(){</span>
<span id="cb21-50"><a href="#cb21-50"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;a[i]),mx=max(mx,a[i]);</span>
<span id="cb21-51"><a href="#cb21-51"></a>    inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;b[i]); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;c[i]);</span>
<span id="cb21-52"><a href="#cb21-52"></a>    getprime(); s=<span class="dv">0</span>; t=n+<span class="dv">1</span>; singn=<span class="dv">0</span>; doubn=<span class="dv">0</span>;</span>
<span id="cb21-53"><a href="#cb21-53"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb21-54"><a href="#cb21-54"></a>        <span class="dt">int</span> x=a[i]; tot=<span class="dv">0</span>; inc(j,<span class="dv">1</span>,cnt)<span class="cf">if</span>(x%p[j]==<span class="dv">0</span>){</span>
<span id="cb21-55"><a href="#cb21-55"></a>            <span class="cf">while</span>(x%p[j]==<span class="dv">0</span>)x/=p[j],tot++; <span class="cf">if</span>(x==<span class="dv">1</span>)<span class="cf">break</span>;</span>
<span id="cb21-56"><a href="#cb21-56"></a>        }</span>
<span id="cb21-57"><a href="#cb21-57"></a>        <span class="cf">if</span>(tot&amp;<span class="dv">1</span>)sing[++singn]=i;<span class="cf">else</span> doub[++doubn]=i;</span>
<span id="cb21-58"><a href="#cb21-58"></a>    }</span>
<span id="cb21-59"><a href="#cb21-59"></a>    init(); inc(i,<span class="dv">1</span>,singn)pe(s,sing[i],b[sing[i]],<span class="dv">0</span>); inc(i,<span class="dv">1</span>,doubn)pe(doub[i],t,b[doub[i]],<span class="dv">0</span>);</span>
<span id="cb21-60"><a href="#cb21-60"></a>    inc(i,<span class="dv">1</span>,singn)inc(j,<span class="dv">1</span>,doubn)</span>
<span id="cb21-61"><a href="#cb21-61"></a>        <span class="cf">if</span>(max(a[sing[i]],a[doub[j]])%min(a[sing[i]],a[doub[j]])==<span class="dv">0</span>&amp;&amp;is_prime(max(a[sing[i]],a[doub[j]])/min(a[sing[i]],a[doub[j]])))</span>
<span id="cb21-62"><a href="#cb21-62"></a>            pe(sing[i],doub[j],INF,c[sing[i]]*c[doub[j]]);</span>
<span id="cb21-63"><a href="#cb21-63"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,maxflowmaxcost(s,t));</span>
<span id="cb21-64"><a href="#cb21-64"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb21-65"><a href="#cb21-65"></a>}</span></code></pre></div>
<h3 id="bzoj2049sdoi2008cave-洞穴勘测2016.4.22">bzoj2049[Sdoi2008]Cave 洞穴勘测（2016.4.22）</h3>
<h4 id="题意-21">题意</h4>
<p>一些点，三种操作：点与点连边、点与点分离、询问两个点是否连通。</p>
<h4 id="题解-21">题解</h4>
<p>比bzoj2843还弱的LCT，只要注意记得翻转就行。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="pp">#define maxn </span><span class="dv">50000</span></span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb22-7"><a href="#cb22-7"></a></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="dt">int</span> fa[maxn],ch[maxn][<span class="dv">2</span>],rev[maxn];</span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb22-10"><a href="#cb22-10"></a>    <span class="cf">if</span>(rev[x]){</span>
<span id="cb22-11"><a href="#cb22-11"></a>        swap(ch[x][<span class="dv">0</span>],ch[x][<span class="dv">1</span>]); <span class="cf">if</span>(ch[x][<span class="dv">0</span>])rev[ch[x][<span class="dv">0</span>]]^=<span class="dv">1</span>; <span class="cf">if</span>(ch[x][<span class="dv">1</span>])rev[ch[x][<span class="dv">1</span>]]^=<span class="dv">1</span>; rev[x]^=<span class="dv">1</span>;</span>
<span id="cb22-12"><a href="#cb22-12"></a>    }</span>
<span id="cb22-13"><a href="#cb22-13"></a>}</span>
<span id="cb22-14"><a href="#cb22-14"></a><span class="dt">bool</span> is_root(<span class="dt">int</span> x){</span>
<span id="cb22-15"><a href="#cb22-15"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||fa[x]==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">1</span>; <span class="cf">return</span> x!=ch[fa[x]][<span class="dv">0</span>]&amp;&amp;x!=ch[fa[x]][<span class="dv">1</span>];</span>
<span id="cb22-16"><a href="#cb22-16"></a>}</span>
<span id="cb22-17"><a href="#cb22-17"></a><span class="dt">void</span> rotate(<span class="dt">int</span> x){</span>
<span id="cb22-18"><a href="#cb22-18"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||is_root(x))<span class="cf">return</span>;</span>
<span id="cb22-19"><a href="#cb22-19"></a>    <span class="dt">int</span> a1=fa[x],a2=fa[fa[x]],a3; <span class="dt">bool</span> b1=(x==ch[a1][<span class="dv">1</span>]),b2=(a1==ch[a2][<span class="dv">1</span>]),b3=is_root(a1); a3=ch[x][!b1];</span>
<span id="cb22-20"><a href="#cb22-20"></a>    <span class="cf">if</span>(!b3)ch[a2][b2]=x; fa[x]=a2; ch[a1][b1]=a3; fa[a3]=a1; ch[x][!b1]=a1; fa[a1]=x;</span>
<span id="cb22-21"><a href="#cb22-21"></a>}</span>
<span id="cb22-22"><a href="#cb22-22"></a><span class="dt">int</span> dts,dt[maxn],y;</span>
<span id="cb22-23"><a href="#cb22-23"></a><span class="dt">void</span> splay(<span class="dt">int</span> x){</span>
<span id="cb22-24"><a href="#cb22-24"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span>; dts=<span class="dv">0</span>; y=x; <span class="cf">while</span>(! is_root(y))dt[++dts]=y,y=fa[y];</span>
<span id="cb22-25"><a href="#cb22-25"></a>    dt[++dts]=y; <span class="cf">while</span>(dts)pushdown(dt[dts]),dts--;</span>
<span id="cb22-26"><a href="#cb22-26"></a>    <span class="cf">while</span>(! is_root(x)){</span>
<span id="cb22-27"><a href="#cb22-27"></a>        <span class="cf">if</span>(! is_root(fa[x]))(x==ch[x][<span class="dv">1</span>])^(fa[x]==ch[fa[fa[x]]][<span class="dv">1</span>])?rotate(x):rotate(fa[x]);</span>
<span id="cb22-28"><a href="#cb22-28"></a>        rotate(x);</span>
<span id="cb22-29"><a href="#cb22-29"></a>    }</span>
<span id="cb22-30"><a href="#cb22-30"></a>}</span>
<span id="cb22-31"><a href="#cb22-31"></a><span class="dt">int</span> access(<span class="dt">int</span> x){</span>
<span id="cb22-32"><a href="#cb22-32"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">0</span>; <span class="dt">int</span> t=<span class="dv">0</span>;</span>
<span id="cb22-33"><a href="#cb22-33"></a>    <span class="cf">while</span>(x){splay(x); ch[x][<span class="dv">1</span>]=t; <span class="cf">if</span>(t)fa[t]=x; t=x; x=fa[x];}</span>
<span id="cb22-34"><a href="#cb22-34"></a>    <span class="cf">return</span> t;</span>
<span id="cb22-35"><a href="#cb22-35"></a>}</span>
<span id="cb22-36"><a href="#cb22-36"></a><span class="dt">void</span> link(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb22-37"><a href="#cb22-37"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||y==<span class="dv">0</span>)<span class="cf">return</span>; access(x); splay(x); rev[x]^=<span class="dv">1</span>; fa[x]=y;</span>
<span id="cb22-38"><a href="#cb22-38"></a>}</span>
<span id="cb22-39"><a href="#cb22-39"></a><span class="dt">void</span> cut(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb22-40"><a href="#cb22-40"></a>    <span class="cf">if</span>(x==<span class="dv">0</span>||y==<span class="dv">0</span>)<span class="cf">return</span>; access(x); splay(x); rev[x]^=<span class="dv">1</span>; access(y); splay(y); ch[y][<span class="dv">0</span>]=fa[x]=<span class="dv">0</span>;</span>
<span id="cb22-41"><a href="#cb22-41"></a>}</span>
<span id="cb22-42"><a href="#cb22-42"></a><span class="dt">int</span> find(<span class="dt">int</span> x){</span>
<span id="cb22-43"><a href="#cb22-43"></a>    access(x); splay(x); <span class="cf">while</span>(ch[x][<span class="dv">0</span>])x=ch[x][<span class="dv">0</span>]; <span class="cf">return</span> x;</span>
<span id="cb22-44"><a href="#cb22-44"></a>}</span>
<span id="cb22-45"><a href="#cb22-45"></a><span class="dt">int</span> n,m; <span class="dt">char</span> s[<span class="dv">10</span>];</span>
<span id="cb22-46"><a href="#cb22-46"></a><span class="dt">int</span> main(){</span>
<span id="cb22-47"><a href="#cb22-47"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)fa[i]=ch[i][<span class="dv">0</span>]=ch[i][<span class="dv">1</span>]=<span class="dv">0</span>; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;m);</span>
<span id="cb22-48"><a href="#cb22-48"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb22-49"><a href="#cb22-49"></a>        <span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%s%d%d</span><span class="st">&quot;</span>,s,&amp;a,&amp;b);</span>
<span id="cb22-50"><a href="#cb22-50"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>)link(a,b);</span>
<span id="cb22-51"><a href="#cb22-51"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;D&#39;</span>)cut(a,b);</span>
<span id="cb22-52"><a href="#cb22-52"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>)find(a)==find(b)?puts(<span class="st">&quot;Yes&quot;</span>):puts(<span class="st">&quot;No&quot;</span>);</span>
<span id="cb22-53"><a href="#cb22-53"></a>    }</span>
<span id="cb22-54"><a href="#cb22-54"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb22-55"><a href="#cb22-55"></a>}</span></code></pre></div>
<h3 id="bzoj4518sdoi2016征途2016.4.23">bzoj4518[Sdoi2016]征途（2016.4.23）</h3>
<h4 id="题意-22">题意</h4>
<p>n个数，分成m段使每段和的方差尽可能小。</p>
<h4 id="题解-22">题解</h4>
<p>朴素的dp方程：f[i,m]=f[j,m-1]+(sum[i]-sum[j])2,j∈[1,i-1]（sum[i]-sum[j]不用减平均数的原因是最后可以化简成f[n,m]*m-sum[n]）复杂度为O(n3)会T，因为有个平方，所以考虑斜率优化，化简得到f[j,m-1]比f[k,m-1]好当且仅当((f[j,m-1]+sum[j]2)-(f[k,m-1]+sum[k]2))＜2*sum[i]*(sum[j]-sum[k])，因为递推时是从小到大的顺序，所以sum[j]-sum[k]&lt;0，所以((f[j,m-1]+sum[j]2)-(f[k,m-1]+sum[k]2))/(sum[j]-sum[k])&gt;2*sum[i]，用单调队列即可。多的那一维可以用滚动数组省空间。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="pp">#define maxn </span><span class="dv">5000</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb23-7"><a href="#cb23-7"></a></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="dt">long</span> <span class="dt">long</span> x[maxn],y[maxn],sum[maxn],a[maxn];<span class="dt">int</span> q[maxn],n,m,l,r;</span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="kw">inline</span> <span class="dt">long</span> <span class="dt">long</span> sqr(<span class="dt">long</span> <span class="dt">long</span> x){<span class="cf">return</span> x*x;}</span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="kw">inline</span> <span class="dt">double</span> get(<span class="dt">long</span> <span class="dt">long</span> a1,<span class="dt">long</span> <span class="dt">long</span> a2){</span>
<span id="cb23-11"><a href="#cb23-11"></a>    <span class="cf">return</span> (<span class="dt">double</span>)((x[a1]+sqr(sum[a1]))-(x[a2]+sqr(sum[a2])))/(<span class="dt">double</span>)(sum[a1]-sum[a2]);</span>
<span id="cb23-12"><a href="#cb23-12"></a>}</span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="dt">int</span> main(){</span>
<span id="cb23-14"><a href="#cb23-14"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); sum[<span class="dv">0</span>]=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;a[i]),sum[i]=sum[i-<span class="dv">1</span>]+a[i];</span>
<span id="cb23-15"><a href="#cb23-15"></a>    inc(i,<span class="dv">1</span>,n)x[i]=sqr(sum[i]);</span>
<span id="cb23-16"><a href="#cb23-16"></a>    inc(i,<span class="dv">2</span>,m){</span>
<span id="cb23-17"><a href="#cb23-17"></a>        l=<span class="dv">0</span>,r=<span class="dv">0</span>; memset(y,<span class="dv">0</span>,<span class="kw">sizeof</span>(y)); x[<span class="dv">1</span>]=sqr(sum[<span class="dv">1</span>]); q[l]=<span class="dv">1</span>;</span>
<span id="cb23-18"><a href="#cb23-18"></a>        inc(j,<span class="dv">2</span>,n){</span>
<span id="cb23-19"><a href="#cb23-19"></a>            <span class="cf">while</span>(l&lt;r&amp;&amp;get(q[l],q[l+<span class="dv">1</span>])&lt;<span class="dv">2</span>*sum[j])l++;</span>
<span id="cb23-20"><a href="#cb23-20"></a>            <span class="cf">while</span>(l&lt;r&amp;&amp;get(q[r-<span class="dv">1</span>],q[r])&gt;get(q[r],j))r--;</span>
<span id="cb23-21"><a href="#cb23-21"></a>            q[++r]=j; y[j]=x[q[l]]+sqr(sum[j]-sum[q[l]]);</span>
<span id="cb23-22"><a href="#cb23-22"></a>        } swap(x,y);</span>
<span id="cb23-23"><a href="#cb23-23"></a>    }</span>
<span id="cb23-24"><a href="#cb23-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,(x[n])*(<span class="dt">long</span> <span class="dt">long</span>)m-sqr(sum[n]));</span>
<span id="cb23-25"><a href="#cb23-25"></a>}</span></code></pre></div>
<h3 id="bzoj1264ahoi2006基因匹配match2016.4.23">bzoj1264[AHOI2006]基因匹配Match（2016.4.23）</h3>
<h4 id="题意-23">题意</h4>
<p>某种序列由n种数组成，每种数在该序列中正好出现5次。对于两个这样的序列s1和s2，如果存在一个序列u同时成为s1和s2的子序列，则称u是s1和s2的公共子序列。子序列的概念：若从一个序列s中任意抽取一些数字，将它们仍按在s中的顺序排列成一个新串u，则称u是s的一个子序列。已知两个等长DNA序列s1和s2，求s1和s2最长公共子序列的长度。</p>
<h4 id="题解-23">题解</h4>
<p>dp+树状数组，题解太难写，摘抄一下</p>
<blockquote>
<p>LCS的决策+1的条件是a[i]==b[j] 于是我们记录a序列中每个数的5个位置 扫一下b[i] 对于每个b[i]找到b[i]在a中的5个位置 这5个位置的每个f[pos]值都可以被b[i]更新 于是找到f[1]到f[pos-1]的最大值+1 更新f[pos]即可 这个用树状数组维护 时间复杂度O(nlogn)</p>
</blockquote>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb24-9"><a href="#cb24-9"></a></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="dt">int</span> c[<span class="dv">200000</span>],n,a[<span class="dv">40000</span>][<span class="dv">6</span>],an[<span class="dv">40000</span>],f[<span class="dv">200000</span>],ans;</span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="kw">inline</span> <span class="dt">int</span> query(<span class="dt">int</span> x){<span class="dt">int</span> q=<span class="dv">0</span>; <span class="cf">while</span>(x)q=max(q,c[x]),x-=lb(x); <span class="cf">return</span> q;}</span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="kw">inline</span> <span class="dt">void</span> update(<span class="dt">int</span> x,<span class="dt">int</span> y){<span class="cf">while</span>(x&lt;=n*<span class="dv">5</span>)c[x]=max(c[x],y),x+=lb(x);}</span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="dt">int</span> main(){</span>
<span id="cb24-14"><a href="#cb24-14"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); memset(an,<span class="dv">0</span>,<span class="kw">sizeof</span>(an)); memset(c,<span class="dv">0</span>,<span class="kw">sizeof</span>(c));</span>
<span id="cb24-15"><a href="#cb24-15"></a>    inc(i,<span class="dv">1</span>,n*<span class="dv">5</span>){<span class="dt">int</span> x; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x); a[x][++an[x]]=i;} ans=<span class="dv">0</span>;</span>
<span id="cb24-16"><a href="#cb24-16"></a>    memset(f,<span class="dv">0</span>,<span class="kw">sizeof</span>(f));</span>
<span id="cb24-17"><a href="#cb24-17"></a>    inc(i,<span class="dv">1</span>,n*<span class="dv">5</span>){</span>
<span id="cb24-18"><a href="#cb24-18"></a>        <span class="dt">int</span> x; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x);</span>
<span id="cb24-19"><a href="#cb24-19"></a>        dec(j,<span class="dv">5</span>,<span class="dv">1</span>){</span>
<span id="cb24-20"><a href="#cb24-20"></a>            <span class="dt">int</span> y=a[x][j]; f[y]=max(f[y],query(y-<span class="dv">1</span>)+<span class="dv">1</span>);</span>
<span id="cb24-21"><a href="#cb24-21"></a>            update(y,f[y]); ans=max(ans,f[y]);</span>
<span id="cb24-22"><a href="#cb24-22"></a>        }</span>
<span id="cb24-23"><a href="#cb24-23"></a>    }</span>
<span id="cb24-24"><a href="#cb24-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);</span>
<span id="cb24-25"><a href="#cb24-25"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb24-26"><a href="#cb24-26"></a>}</span></code></pre></div>
<h3 id="bzoj2661beijing-wc2012连连看2016.4.24">bzoj2661[BeiJing wc2012]连连看（2016.4.24）</h3>
<h4 id="题意-24">题意</h4>
<p>给出一个闭区间[a,b]中的全部整数，如果其中某两个数x,y（设x&gt;y）的平方差x2-y2是一个完全平方数z2，并且y与z互质，那么就可以将x和y一起消除，同时得到x+y点分数。求消除的数对尽可能多的前提下分数的最大值。</p>
<h4 id="题解-24">题解</h4>
<p>每个数拆成两个点，s和左侧点连流量为1，费用为0的边；右侧点和t连流量为1，费用为0的边。如果i，j合法，则同时向左侧i向右侧j及左侧j向右侧i连流量为1，费用为i+j的边。这道题和bzoj4514不同，因为每个数只出现一次，所以当左侧i和右侧j被消掉时，左侧j和右侧i也会在下一次消掉，其它的数就无法再和它们相消了。而bzoj4514每个数都有多个，可能一边没消尽，如果用这道题的做法就可能会出现另一个数把它已经被消掉的部分重复消掉，导致结果不刚好为正解的2倍。因此bzoj4514不能拆点，而这道题就可以拆点，答案就分别为算法跑出来的最大流和最大“费用”除以2。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="pp">#define maxn </span><span class="dv">5000</span></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb25-11"><a href="#cb25-11"></a></span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t;<span class="dt">int</span> c,w;<span class="dt">int</span> n;}; e es[<span class="dv">2000000</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb25-13"><a href="#cb25-13"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c,<span class="dt">int</span> w){</span>
<span id="cb25-14"><a href="#cb25-14"></a>    es[++ess]=(e){f,t,c,w,g[f]}; g[f]=ess; es[++ess]=(e){t,f,<span class="dv">0</span>,-w,g[t]}; g[t]=ess;</span>
<span id="cb25-15"><a href="#cb25-15"></a>}</span>
<span id="cb25-16"><a href="#cb25-16"></a><span class="dt">void</span> init(){ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb25-17"><a href="#cb25-17"></a>queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> d[maxn],cost,flow,fr[maxn]; <span class="dt">bool</span> inq[maxn],vis[maxn];</span>
<span id="cb25-18"><a href="#cb25-18"></a><span class="dt">bool</span> spfa(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb25-19"><a href="#cb25-19"></a>    <span class="cf">while</span>(! q.empty())q.pop(); memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq));</span>
<span id="cb25-20"><a href="#cb25-20"></a>    q.push(s); vis[s]=<span class="dv">1</span>; inq[s]=<span class="dv">1</span>; d[s]=<span class="dv">0</span>;</span>
<span id="cb25-21"><a href="#cb25-21"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb25-22"><a href="#cb25-22"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb25-23"><a href="#cb25-23"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;(!vis[es[i].t]||d[es[i].t]&lt;d[x]+es[i].w)){</span>
<span id="cb25-24"><a href="#cb25-24"></a>            vis[es[i].t]=<span class="dv">1</span>; d[es[i].t]=d[x]+es[i].w; fr[es[i].t]=i;</span>
<span id="cb25-25"><a href="#cb25-25"></a>            <span class="cf">if</span>(!inq[es[i].t])q.push(es[i].t),inq[es[i].t]=<span class="dv">1</span>;</span>
<span id="cb25-26"><a href="#cb25-26"></a>        }</span>
<span id="cb25-27"><a href="#cb25-27"></a>    }</span>
<span id="cb25-28"><a href="#cb25-28"></a>    <span class="cf">if</span>(!vis[t])<span class="cf">return</span> <span class="dv">0</span>;<span class="cf">else</span> <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb25-29"><a href="#cb25-29"></a>}</span>
<span id="cb25-30"><a href="#cb25-30"></a><span class="dt">void</span> advanced(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb25-31"><a href="#cb25-31"></a>    <span class="dt">int</span> a=INF; <span class="cf">for</span>(<span class="dt">int</span> i=t;i!=s;i=es[fr[i]].f)a=min(a,es[fr[i]].c); flow+=a;</span>
<span id="cb25-32"><a href="#cb25-32"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=t;i!=s;i=es[fr[i]].f)es[fr[i]].c-=a,es[fr[i]^<span class="dv">1</span>].c+=a,cost+=a*es[fr[i]].w;</span>
<span id="cb25-33"><a href="#cb25-33"></a>}</span>
<span id="cb25-34"><a href="#cb25-34"></a><span class="dt">void</span> maxflowmaxcost(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb25-35"><a href="#cb25-35"></a>    <span class="cf">while</span>(spfa(s,t))advanced(s,t);</span>
<span id="cb25-36"><a href="#cb25-36"></a>}</span>
<span id="cb25-37"><a href="#cb25-37"></a><span class="dt">int</span> n,s,t,l,r;</span>
<span id="cb25-38"><a href="#cb25-38"></a><span class="dt">int</span> gcd(<span class="dt">int</span> a,<span class="dt">int</span> b){<span class="cf">return</span> b==<span class="dv">0</span>?a:gcd(b,a%b);}</span>
<span id="cb25-39"><a href="#cb25-39"></a><span class="dt">bool</span> check(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb25-40"><a href="#cb25-40"></a>    <span class="cf">if</span>(x&lt;=y)<span class="cf">return</span> <span class="dv">0</span>; <span class="dt">double</span> z=sqrt(x*x-y*y); <span class="cf">if</span>(z!=(<span class="dt">double</span>)((<span class="dt">int</span>)z))<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb25-41"><a href="#cb25-41"></a>    <span class="dt">int</span> zz=(<span class="dt">int</span>)z; <span class="cf">if</span>(gcd(y,zz)!=<span class="dv">1</span>)<span class="cf">return</span> <span class="dv">0</span>; <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb25-42"><a href="#cb25-42"></a>}</span>
<span id="cb25-43"><a href="#cb25-43"></a><span class="dt">int</span> main(){</span>
<span id="cb25-44"><a href="#cb25-44"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;l,&amp;r); n=l-<span class="dv">1</span>; s=<span class="dv">0</span>; t=<span class="dv">2</span>*(r-l+<span class="dv">1</span>)+<span class="dv">1</span>;</span>
<span id="cb25-45"><a href="#cb25-45"></a>    init(); inc(i,l,r)pe(s,i-n,<span class="dv">1</span>,<span class="dv">0</span>),pe(i-n+(r-l+<span class="dv">1</span>),t,<span class="dv">1</span>,<span class="dv">0</span>);</span>
<span id="cb25-46"><a href="#cb25-46"></a>    inc(i,l,r)inc(j,l,r)<span class="cf">if</span>(check(i,j))pe(i-n,j-n+(r-l+<span class="dv">1</span>),<span class="dv">1</span>,i+j),pe(j-n,i-n+(r-l+<span class="dv">1</span>),<span class="dv">1</span>,i+j); maxflowmaxcost(s,t);</span>
<span id="cb25-47"><a href="#cb25-47"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">&quot;</span>,flow&gt;&gt;<span class="dv">1</span>,cost&gt;&gt;<span class="dv">1</span>);</span>
<span id="cb25-48"><a href="#cb25-48"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb25-49"><a href="#cb25-49"></a>}</span></code></pre></div>
<h3 id="bzoj4034haoi2015t22016.4.25">bzoj4034[HAOI2015]T2（2016.4.25）</h3>
<h4 id="题意-25">题意</h4>
<p>N点树，以点 1 为根，且树点有边权。三种操作：把某个节点点权增加 a 、某个节点为根的子树中所有点的点权都增加 a 、询问某个节点到根的路径中所有点的点权和。</p>
<h4 id="题解-25">题解</h4>
<p>本题链剖可过。第二个操作只要每次在构造链的时候找到子树中在链中位置最大的节点，然后区间修改就行。听说正解是DFS序，不过我不会。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="pp">#define maxn </span><span class="dv">200000</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb26-8"><a href="#cb26-8"></a></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;}</span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="dt">int</span> l[maxn*<span class="dv">4</span>],r[maxn*<span class="dv">4</span>],ch[maxn*<span class="dv">4</span>][<span class="dv">2</span>],fa[maxn],dep[maxn],pos[maxn],top[maxn],sz[maxn],sgs,mx[maxn];</span>
<span id="cb26-12"><a href="#cb26-12"></a>ll v[maxn][<span class="dv">2</span>],sm[maxn*<span class="dv">4</span>],tg[maxn*<span class="dv">4</span>];</span>
<span id="cb26-13"><a href="#cb26-13"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb26-14"><a href="#cb26-14"></a>    sz[x]=<span class="dv">1</span>; <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]){</span>
<span id="cb26-15"><a href="#cb26-15"></a>        fa[es[i].t]=x; dep[es[i].t]=dep[x]+<span class="dv">1</span>; dfs(es[i].t); sz[x]+=sz[es[i].t];</span>
<span id="cb26-16"><a href="#cb26-16"></a>    }</span>
<span id="cb26-17"><a href="#cb26-17"></a>}</span>
<span id="cb26-18"><a href="#cb26-18"></a><span class="dt">void</span> buildchain(<span class="dt">int</span> x,<span class="dt">int</span> ps){</span>
<span id="cb26-19"><a href="#cb26-19"></a>    pos[x]=mx[x]=++sgs; v[sgs][<span class="dv">1</span>]=v[x][<span class="dv">0</span>]; top[x]=ps; <span class="dt">int</span> mx1=<span class="dv">0</span>,mx2=<span class="dv">0</span>;</span>
<span id="cb26-20"><a href="#cb26-20"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]&amp;&amp;mx2&lt;sz[es[i].t])mx2=sz[es[i].t],mx1=es[i].t;</span>
<span id="cb26-21"><a href="#cb26-21"></a>    <span class="cf">if</span>(mx1)buildchain(mx1,ps),mx[x]=max(mx[x],mx[mx1]);</span>
<span id="cb26-22"><a href="#cb26-22"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]&amp;&amp;es[i].t!=mx1)</span>
<span id="cb26-23"><a href="#cb26-23"></a>        buildchain(es[i].t,es[i].t),mx[x]=max(mx[x],mx[es[i].t]);</span>
<span id="cb26-24"><a href="#cb26-24"></a>}</span>
<span id="cb26-25"><a href="#cb26-25"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb26-26"><a href="#cb26-26"></a>    <span class="cf">if</span>(x&amp;&amp;tg[x]){</span>
<span id="cb26-27"><a href="#cb26-27"></a>        <span class="dt">int</span> lc=ch[x][<span class="dv">0</span>],rc=ch[x][<span class="dv">1</span>];</span>
<span id="cb26-28"><a href="#cb26-28"></a>        <span class="cf">if</span>(lc)sm[lc]+=(r[lc]-l[lc]+<span class="dv">1</span>)*tg[x],tg[lc]+=tg[x];</span>
<span id="cb26-29"><a href="#cb26-29"></a>        <span class="cf">if</span>(rc)sm[rc]+=(r[rc]-l[rc]+<span class="dv">1</span>)*tg[x],tg[rc]+=tg[x];</span>
<span id="cb26-30"><a href="#cb26-30"></a>        tg[x]=<span class="dv">0</span>;</span>
<span id="cb26-31"><a href="#cb26-31"></a>    }</span>
<span id="cb26-32"><a href="#cb26-32"></a>}</span>
<span id="cb26-33"><a href="#cb26-33"></a><span class="dt">void</span> build(<span class="dt">int</span> x,<span class="dt">int</span> L,<span class="dt">int</span> R){</span>
<span id="cb26-34"><a href="#cb26-34"></a>    <span class="cf">if</span>(L==R)sm[x]=v[L][<span class="dv">1</span>],ch[x][<span class="dv">0</span>]=ch[x][<span class="dv">1</span>]=<span class="dv">0</span>,l[x]=r[x]=L;<span class="cf">else</span>{</span>
<span id="cb26-35"><a href="#cb26-35"></a>        ch[x][<span class="dv">0</span>]=x&lt;&lt;<span class="dv">1</span>,l[x]=L,ch[x][<span class="dv">1</span>]=x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,r[x]=R; <span class="dt">int</span> M=(L+R)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb26-36"><a href="#cb26-36"></a>        build(ch[x][<span class="dv">0</span>],L,M); build(ch[x][<span class="dv">1</span>],M+<span class="dv">1</span>,R); sm[x]=sm[ch[x][<span class="dv">0</span>]]+sm[ch[x][<span class="dv">1</span>]];</span>
<span id="cb26-37"><a href="#cb26-37"></a>    }</span>
<span id="cb26-38"><a href="#cb26-38"></a>}</span>
<span id="cb26-39"><a href="#cb26-39"></a>ll query(<span class="dt">int</span> x,<span class="dt">int</span> L,<span class="dt">int</span> R){</span>
<span id="cb26-40"><a href="#cb26-40"></a>    pushdown(x);</span>
<span id="cb26-41"><a href="#cb26-41"></a>    <span class="cf">if</span>(L&lt;=l[x]&amp;&amp;r[x]&lt;=R)<span class="cf">return</span> sm[x];<span class="cf">else</span>{</span>
<span id="cb26-42"><a href="#cb26-42"></a>        ll q=<span class="dv">0</span>;<span class="dt">int</span> M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(L&lt;=M)q+=query(ch[x][<span class="dv">0</span>],L,R); <span class="cf">if</span>(M&lt;R)q+=query(ch[x][<span class="dv">1</span>],L,R);</span>
<span id="cb26-43"><a href="#cb26-43"></a>        <span class="cf">return</span> q;</span>
<span id="cb26-44"><a href="#cb26-44"></a>    }</span>
<span id="cb26-45"><a href="#cb26-45"></a>}</span>
<span id="cb26-46"><a href="#cb26-46"></a><span class="dt">void</span> add(<span class="dt">int</span> x,<span class="dt">int</span> L,<span class="dt">int</span> R,ll val){</span>
<span id="cb26-47"><a href="#cb26-47"></a>    pushdown(x);</span>
<span id="cb26-48"><a href="#cb26-48"></a>    <span class="cf">if</span>(L&lt;=l[x]&amp;&amp;r[x]&lt;=R)tg[x]+=val,sm[x]+=(r[x]-l[x]+<span class="dv">1</span>)*val;<span class="cf">else</span>{</span>
<span id="cb26-49"><a href="#cb26-49"></a>        <span class="dt">int</span> M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(L&lt;=M)add(ch[x][<span class="dv">0</span>],L,R,val); <span class="cf">if</span>(M&lt;R)add(ch[x][<span class="dv">1</span>],L,R,val);</span>
<span id="cb26-50"><a href="#cb26-50"></a>        sm[x]=sm[ch[x][<span class="dv">0</span>]]+sm[ch[x][<span class="dv">1</span>]];</span>
<span id="cb26-51"><a href="#cb26-51"></a>    }</span>
<span id="cb26-52"><a href="#cb26-52"></a>}</span>
<span id="cb26-53"><a href="#cb26-53"></a><span class="kw">inline</span> ll querysum(<span class="dt">int</span> x){ll q=<span class="dv">0</span>; <span class="cf">while</span>(x)q+=query(<span class="dv">1</span>,pos[top[x]],pos[x]),x=fa[top[x]]; <span class="cf">return</span> q;}</span>
<span id="cb26-54"><a href="#cb26-54"></a><span class="dt">void</span> init1(){ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb26-55"><a href="#cb26-55"></a><span class="dt">void</span> init2(){dep[<span class="dv">1</span>]=fa[<span class="dv">1</span>]=<span class="dv">0</span>; dfs(<span class="dv">1</span>); sgs=<span class="dv">0</span>; buildchain(<span class="dv">1</span>,<span class="dv">1</span>); build(<span class="dv">1</span>,<span class="dv">1</span>,sgs);}</span>
<span id="cb26-56"><a href="#cb26-56"></a><span class="dt">int</span> n,m;</span>
<span id="cb26-57"><a href="#cb26-57"></a><span class="dt">int</span> main(){</span>
<span id="cb26-58"><a href="#cb26-58"></a>    <span class="co">//freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin);</span></span>
<span id="cb26-59"><a href="#cb26-59"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;v[i][<span class="dv">0</span>]); init1();</span>
<span id="cb26-60"><a href="#cb26-60"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b); pe(a,b);} init2();</span>
<span id="cb26-61"><a href="#cb26-61"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb26-62"><a href="#cb26-62"></a>        <span class="dt">int</span> opt,x;ll y; scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;opt,&amp;x);</span>
<span id="cb26-63"><a href="#cb26-63"></a>        <span class="cf">if</span>(opt==<span class="dv">1</span>)scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;y),add(<span class="dv">1</span>,pos[x],pos[x],y);</span>
<span id="cb26-64"><a href="#cb26-64"></a>        <span class="cf">if</span>(opt==<span class="dv">2</span>)scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;y),add(<span class="dv">1</span>,pos[x],mx[x],y);</span>
<span id="cb26-65"><a href="#cb26-65"></a>        <span class="cf">if</span>(opt==<span class="dv">3</span>)printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,querysum(x));</span>
<span id="cb26-66"><a href="#cb26-66"></a>    }</span>
<span id="cb26-67"><a href="#cb26-67"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb26-68"><a href="#cb26-68"></a>}</span></code></pre></div>
<h3 id="bzoj2243sdoi2011染色2016.4.27">bzoj2243[SDOI2011]染色（2016.4.27）</h3>
<h4 id="题意-26">题意</h4>
<p>n点无根树，2类操作：将节点a到节点b路径上所有点都染成颜色c、询问节点a到节点b路径上的颜色段数量。</p>
<h4 id="题解-26">题解</h4>
<p>有点恶心的链剖，可以用包含区间颜色段数，左端点颜色，右端点颜色的结构体存储查询的结果。首先是线段树节点除了要保存区间颜色段数还要保存左右端点颜色，再者是查询的时候要注意合并区间：在线段树查询时，如果递归左端点，就左合并递归结果，如果右端点就右合并；在树链查询时，从下往上左合并查询结果，两段分开处理，当两段都查询完时将一段的结果中的左右端点颜色交换，然后合并。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="pp">#define maxn </span><span class="dv">200000</span></span>
<span id="cb27-6"><a href="#cb27-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb27-7"><a href="#cb27-7"></a></span>
<span id="cb27-8"><a href="#cb27-8"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn];<span class="dt">int</span> ess,g[maxn];</span>
<span id="cb27-9"><a href="#cb27-9"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;}</span>
<span id="cb27-10"><a href="#cb27-10"></a><span class="dt">int</span> fa[maxn],sz[maxn],dep[maxn],pos[maxn],top[maxn],v[maxn][<span class="dv">2</span>],sgs;</span>
<span id="cb27-11"><a href="#cb27-11"></a><span class="dt">int</span> l[maxn*<span class="dv">4</span>],r[maxn*<span class="dv">4</span>],ch[maxn*<span class="dv">4</span>][<span class="dv">2</span>],ll[maxn*<span class="dv">4</span>],rr[maxn*<span class="dv">4</span>],sm[maxn*<span class="dv">4</span>],tg[maxn*<span class="dv">4</span>];</span>
<span id="cb27-12"><a href="#cb27-12"></a><span class="kw">struct</span> nd{</span>
<span id="cb27-13"><a href="#cb27-13"></a>    <span class="dt">int</span> sm,l,r;</span>
<span id="cb27-14"><a href="#cb27-14"></a>    <span class="dt">void</span> plusr(nd d){</span>
<span id="cb27-15"><a href="#cb27-15"></a>        sm=sm+d.sm+(r==d.l?-<span class="dv">1</span>:<span class="dv">0</span>); r=d.r;</span>
<span id="cb27-16"><a href="#cb27-16"></a>    }</span>
<span id="cb27-17"><a href="#cb27-17"></a>    <span class="dt">void</span> plusl(nd d){</span>
<span id="cb27-18"><a href="#cb27-18"></a>        sm=sm+d.sm+(d.r==l?-<span class="dv">1</span>:<span class="dv">0</span>); l=d.l;</span>
<span id="cb27-19"><a href="#cb27-19"></a>    }</span>
<span id="cb27-20"><a href="#cb27-20"></a>};</span>
<span id="cb27-21"><a href="#cb27-21"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb27-22"><a href="#cb27-22"></a>    sz[x]=<span class="dv">1</span>; <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]){</span>
<span id="cb27-23"><a href="#cb27-23"></a>        dep[es[i].t]=dep[x]+<span class="dv">1</span>; fa[es[i].t]=x; dfs(es[i].t); sz[x]+=sz[es[i].t];</span>
<span id="cb27-24"><a href="#cb27-24"></a>    }</span>
<span id="cb27-25"><a href="#cb27-25"></a>}</span>
<span id="cb27-26"><a href="#cb27-26"></a><span class="dt">void</span> buildchain(<span class="dt">int</span> x,<span class="dt">int</span> ps){</span>
<span id="cb27-27"><a href="#cb27-27"></a>    pos[x]=++sgs; top[x]=ps; v[sgs][<span class="dv">1</span>]=v[x][<span class="dv">0</span>]; <span class="dt">int</span> mx1,mx2=<span class="dv">0</span>;</span>
<span id="cb27-28"><a href="#cb27-28"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]&amp;&amp;mx2&lt;sz[es[i].t])mx2=sz[es[i].t],mx1=es[i].t;</span>
<span id="cb27-29"><a href="#cb27-29"></a>    <span class="cf">if</span>(mx2)buildchain(mx1,ps);</span>
<span id="cb27-30"><a href="#cb27-30"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]&amp;&amp;es[i].t!=mx1)buildchain(es[i].t,es[i].t);</span>
<span id="cb27-31"><a href="#cb27-31"></a>}</span>
<span id="cb27-32"><a href="#cb27-32"></a><span class="dt">int</span> lca(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb27-33"><a href="#cb27-33"></a>    <span class="cf">for</span>(;top[x]!=top[y];x=fa[top[x]])<span class="cf">if</span>(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span>
<span id="cb27-34"><a href="#cb27-34"></a>    <span class="cf">return</span> dep[x]&lt;dep[y]?x:y;</span>
<span id="cb27-35"><a href="#cb27-35"></a>}</span>
<span id="cb27-36"><a href="#cb27-36"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb27-37"><a href="#cb27-37"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span>; <span class="cf">if</span>(!ch[x][<span class="dv">0</span>]&amp;&amp;!ch[x][<span class="dv">1</span>])sm[x]=<span class="dv">0</span>;</span>
<span id="cb27-38"><a href="#cb27-38"></a>    sm[x]=sm[ch[x][<span class="dv">0</span>]]+sm[ch[x][<span class="dv">1</span>]]+(rr[ch[x][<span class="dv">0</span>]]==ll[ch[x][<span class="dv">1</span>]]?-<span class="dv">1</span>:<span class="dv">0</span>);</span>
<span id="cb27-39"><a href="#cb27-39"></a>    ll[x]=ll[ch[x][<span class="dv">0</span>]]; rr[x]=rr[ch[x][<span class="dv">1</span>]];</span>
<span id="cb27-40"><a href="#cb27-40"></a>}</span>
<span id="cb27-41"><a href="#cb27-41"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb27-42"><a href="#cb27-42"></a>    <span class="cf">if</span>(!x||tg[x]==-<span class="dv">1</span>)<span class="cf">return</span>; <span class="dt">int</span> lc=ch[x][<span class="dv">0</span>],rc=ch[x][<span class="dv">1</span>];</span>
<span id="cb27-43"><a href="#cb27-43"></a>    <span class="cf">if</span>(lc)sm[lc]=<span class="dv">1</span>,ll[lc]=rr[lc]=tg[x],tg[lc]=tg[x];</span>
<span id="cb27-44"><a href="#cb27-44"></a>    <span class="cf">if</span>(rc)sm[rc]=<span class="dv">1</span>,ll[rc]=rr[rc]=tg[x],tg[rc]=tg[x]; tg[x]=-<span class="dv">1</span>;</span>
<span id="cb27-45"><a href="#cb27-45"></a>}</span>
<span id="cb27-46"><a href="#cb27-46"></a><span class="dt">void</span> build(<span class="dt">int</span> x,<span class="dt">int</span> L,<span class="dt">int</span> R){</span>
<span id="cb27-47"><a href="#cb27-47"></a>    <span class="cf">if</span>(L==R)l[x]=r[x]=L,ch[x][<span class="dv">0</span>]=ch[x][<span class="dv">1</span>]=<span class="dv">0</span>,ll[x]=rr[x]=v[L][<span class="dv">1</span>],tg[x]=-<span class="dv">1</span>,sm[x]=<span class="dv">1</span>;<span class="cf">else</span>{</span>
<span id="cb27-48"><a href="#cb27-48"></a>        <span class="dt">int</span> M=(L+R)&gt;&gt;<span class="dv">1</span>; ch[x][<span class="dv">0</span>]=x&lt;&lt;<span class="dv">1</span>; ch[x][<span class="dv">1</span>]=x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>; l[x]=L; r[x]=R; tg[x]=-<span class="dv">1</span>;</span>
<span id="cb27-49"><a href="#cb27-49"></a>        build(ch[x][<span class="dv">0</span>],L,M); build(ch[x][<span class="dv">1</span>],M+<span class="dv">1</span>,R); update(x);</span>
<span id="cb27-50"><a href="#cb27-50"></a>    }</span>
<span id="cb27-51"><a href="#cb27-51"></a>}</span>
<span id="cb27-52"><a href="#cb27-52"></a>nd query(<span class="dt">int</span> x,<span class="dt">int</span> L,<span class="dt">int</span> R){</span>
<span id="cb27-53"><a href="#cb27-53"></a>    pushdown(x); <span class="cf">if</span>(L&lt;=l[x]&amp;&amp;r[x]&lt;=R)<span class="cf">return</span> (nd){sm[x],ll[x],rr[x]};</span>
<span id="cb27-54"><a href="#cb27-54"></a>    <span class="dt">int</span> M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; nd q;</span>
<span id="cb27-55"><a href="#cb27-55"></a>    <span class="cf">if</span>(L&lt;=M){</span>
<span id="cb27-56"><a href="#cb27-56"></a>        q=query(ch[x][<span class="dv">0</span>],L,R); <span class="cf">if</span>(M&lt;R)q.plusr(query(ch[x][<span class="dv">1</span>],L,R));</span>
<span id="cb27-57"><a href="#cb27-57"></a>    }<span class="cf">else</span> <span class="cf">if</span>(M&lt;R)q=(query(ch[x][<span class="dv">1</span>],L,R));</span>
<span id="cb27-58"><a href="#cb27-58"></a>    <span class="cf">return</span> q;</span>
<span id="cb27-59"><a href="#cb27-59"></a>}</span>
<span id="cb27-60"><a href="#cb27-60"></a><span class="dt">void</span> change(<span class="dt">int</span> x,<span class="dt">int</span> L,<span class="dt">int</span> R,<span class="dt">int</span> col){</span>
<span id="cb27-61"><a href="#cb27-61"></a>    pushdown(x); <span class="cf">if</span>(L&lt;=l[x]&amp;&amp;r[x]&lt;=R){ll[x]=rr[x]=tg[x]=col,sm[x]=<span class="dv">1</span>; <span class="cf">return</span>;}</span>
<span id="cb27-62"><a href="#cb27-62"></a>    <span class="dt">int</span> M=(l[x]+r[x])&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(L&lt;=M)change(ch[x][<span class="dv">0</span>],L,R,col);</span>
<span id="cb27-63"><a href="#cb27-63"></a>    <span class="cf">if</span>(M&lt;R)change(ch[x][<span class="dv">1</span>],L,R,col); update(x);</span>
<span id="cb27-64"><a href="#cb27-64"></a>}</span>
<span id="cb27-65"><a href="#cb27-65"></a><span class="dt">void</span> init1(){ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb27-66"><a href="#cb27-66"></a><span class="dt">void</span> init2(){fa[<span class="dv">1</span>]=<span class="dv">0</span>; dep[<span class="dv">1</span>]=<span class="dv">0</span>; dfs(<span class="dv">1</span>); sgs=<span class="dv">0</span>; buildchain(<span class="dv">1</span>,<span class="dv">1</span>); build(<span class="dv">1</span>,<span class="dv">1</span>,sgs);}</span>
<span id="cb27-67"><a href="#cb27-67"></a><span class="dt">int</span> querysum(<span class="dt">int</span> a,<span class="dt">int</span> b){</span>
<span id="cb27-68"><a href="#cb27-68"></a>    <span class="cf">if</span>(a==b)<span class="cf">return</span> query(<span class="dv">1</span>,pos[a],pos[b]).sm; <span class="dt">int</span> c=lca(a,b);</span>
<span id="cb27-69"><a href="#cb27-69"></a>    nd q1; <span class="dt">bool</span> f=<span class="dv">0</span>;</span>
<span id="cb27-70"><a href="#cb27-70"></a>    <span class="cf">while</span>(dep[top[a]]&gt;dep[top[c]]){</span>
<span id="cb27-71"><a href="#cb27-71"></a>        <span class="cf">if</span>(!f)q1=query(<span class="dv">1</span>,pos[top[a]],pos[a]),f=<span class="dv">1</span>;<span class="cf">else</span> q1.plusl(query(<span class="dv">1</span>,pos[top[a]],pos[a]));</span>
<span id="cb27-72"><a href="#cb27-72"></a>        a=fa[top[a]];</span>
<span id="cb27-73"><a href="#cb27-73"></a>    }</span>
<span id="cb27-74"><a href="#cb27-74"></a>    <span class="cf">if</span>(!f)q1=query(<span class="dv">1</span>,pos[c],pos[a]),f=<span class="dv">1</span>;<span class="cf">else</span> q1.plusl(query(<span class="dv">1</span>,pos[c],pos[a]));</span>
<span id="cb27-75"><a href="#cb27-75"></a>    nd q2; f=<span class="dv">0</span>;</span>
<span id="cb27-76"><a href="#cb27-76"></a>    <span class="cf">while</span>(dep[top[b]]&gt;dep[top[c]]){</span>
<span id="cb27-77"><a href="#cb27-77"></a>        <span class="cf">if</span>(! f)q2=query(<span class="dv">1</span>,pos[top[b]],pos[b]),f=<span class="dv">1</span>;<span class="cf">else</span> q2.plusl(query(<span class="dv">1</span>,pos[top[b]],pos[b]));</span>
<span id="cb27-78"><a href="#cb27-78"></a>        b=fa[top[b]];</span>
<span id="cb27-79"><a href="#cb27-79"></a>    }</span>
<span id="cb27-80"><a href="#cb27-80"></a>    <span class="cf">if</span>(! f)q2=query(<span class="dv">1</span>,pos[c],pos[b]),f=<span class="dv">1</span>;<span class="cf">else</span> q2.plusl(query(<span class="dv">1</span>,pos[c],pos[b]));</span>
<span id="cb27-81"><a href="#cb27-81"></a>    swap(q1.l,q1.r); q1.plusr(q2); <span class="cf">return</span> q1.sm;</span>
<span id="cb27-82"><a href="#cb27-82"></a>}</span>
<span id="cb27-83"><a href="#cb27-83"></a><span class="dt">void</span> changecol(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> col){</span>
<span id="cb27-84"><a href="#cb27-84"></a>    <span class="cf">if</span>(a==b){change(<span class="dv">1</span>,pos[a],pos[b],col);} <span class="dt">int</span> c=lca(a,b);</span>
<span id="cb27-85"><a href="#cb27-85"></a>    <span class="cf">while</span>(dep[top[a]]&gt;dep[top[c]])change(<span class="dv">1</span>,pos[top[a]],pos[a],col),a=fa[top[a]];</span>
<span id="cb27-86"><a href="#cb27-86"></a>    change(<span class="dv">1</span>,pos[c],pos[a],col);</span>
<span id="cb27-87"><a href="#cb27-87"></a>    <span class="cf">while</span>(dep[top[b]]&gt;dep[top[c]])change(<span class="dv">1</span>,pos[top[b]],pos[b],col),b=fa[top[b]];</span>
<span id="cb27-88"><a href="#cb27-88"></a>    change(<span class="dv">1</span>,pos[c],pos[b],col);</span>
<span id="cb27-89"><a href="#cb27-89"></a>}</span>
<span id="cb27-90"><a href="#cb27-90"></a><span class="dt">int</span> n,m; <span class="dt">char</span> op[<span class="dv">3</span>];</span>
<span id="cb27-91"><a href="#cb27-91"></a><span class="dt">int</span> main(){</span>
<span id="cb27-92"><a href="#cb27-92"></a>    <span class="co">//freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin);</span></span>
<span id="cb27-93"><a href="#cb27-93"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;v[i][<span class="dv">0</span>]); init1();</span>
<span id="cb27-94"><a href="#cb27-94"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b); pe(a,b);} init2();</span>
<span id="cb27-95"><a href="#cb27-95"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb27-96"><a href="#cb27-96"></a>        <span class="dt">int</span> a,b,c; scanf(<span class="st">&quot;</span><span class="sc">%s%d%d</span><span class="st">&quot;</span>,op,&amp;a,&amp;b);</span>
<span id="cb27-97"><a href="#cb27-97"></a>        <span class="cf">if</span>(op[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>){printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,querysum(a,b));}</span>
<span id="cb27-98"><a href="#cb27-98"></a>        <span class="cf">if</span>(op[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>){scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;c); changecol(a,b,c);}</span>
<span id="cb27-99"><a href="#cb27-99"></a>    }</span>
<span id="cb27-100"><a href="#cb27-100"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb27-101"><a href="#cb27-101"></a>}</span></code></pre></div>
<h3 id="bzoj1296scoi2009粉刷匠2016.4.27">bzoj1296[SCOI2009]粉刷匠（2016.4.27）</h3>
<h4 id="题意-27">题意</h4>
<p>粉刷N条木板，每条木板M 个格子，每个格子要被刷成红色或蓝色。每次只能选择一条木板上一段连续的格子涂上一种颜色。 每个格子最多只能被粉刷一次。 如果只能粉刷 T 次，求最多能正确粉刷的格子数。未被粉刷或者颜色错的格子算错误粉刷。</p>
<h4 id="题解-27">题解</h4>
<p>非常容易想的DP，但是我竟然调了0.5h+一个中午，不是一般的弱啊~~首先f[i][j][k]表示现在考虑第i行第j列，正在第k次粉刷，转移就考虑不粉刷跳到f[i][j+1][k]或粉刷x格跳到f[i][j+x][k+1]+max(红色j+1到j+x,蓝色j+1到j+x)。我主要错在几个方面：一是奇怪的打错；二是当j==m时，如果不涂往下一行跳转，j要变成0而不是1，因为是从j+1开始涂的；三是dp数组里因为有一个“正在第k次粉刷”，所以第三维要开到2500而不是50。错得好傻逼啊QAQ</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb28-7"><a href="#cb28-7"></a></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="dt">int</span> n,m,k; <span class="dt">int</span> w[<span class="dv">60</span>][<span class="dv">60</span>],b[<span class="dv">60</span>][<span class="dv">60</span>],f[<span class="dv">60</span>][<span class="dv">60</span>][<span class="dv">3000</span>]; <span class="dt">char</span> s[<span class="dv">60</span>];</span>
<span id="cb28-9"><a href="#cb28-9"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> z){</span>
<span id="cb28-10"><a href="#cb28-10"></a>    <span class="cf">if</span>(x==n+<span class="dv">1</span>||z==k+<span class="dv">1</span>)<span class="cf">return</span> <span class="dv">0</span>; <span class="cf">if</span>(f[x][y][z]!=-<span class="dv">1</span>)<span class="cf">return</span> f[x][y][z];</span>
<span id="cb28-11"><a href="#cb28-11"></a>    f[x][y][z]=<span class="dv">0</span>; f[x][y][z]=max(f[x][y][z],dfs(y==m?x+<span class="dv">1</span>:x,y==m?<span class="dv">0</span>:y+<span class="dv">1</span>,z));</span>
<span id="cb28-12"><a href="#cb28-12"></a>    inc(i,y+<span class="dv">1</span>,m)</span>
<span id="cb28-13"><a href="#cb28-13"></a>    f[x][y][z]=max(f[x][y][z],dfs(x,i,z+<span class="dv">1</span>)+max(w[x][i]-w[x][y],b[x][i]-b[x][y]));</span>
<span id="cb28-14"><a href="#cb28-14"></a>    <span class="cf">return</span> f[x][y][z];</span>
<span id="cb28-15"><a href="#cb28-15"></a>}</span>
<span id="cb28-16"><a href="#cb28-16"></a><span class="dt">int</span> main(){</span>
<span id="cb28-17"><a href="#cb28-17"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m,&amp;k);</span>
<span id="cb28-18"><a href="#cb28-18"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb28-19"><a href="#cb28-19"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s);</span>
<span id="cb28-20"><a href="#cb28-20"></a>        inc(j,<span class="dv">0</span>,m-<span class="dv">1</span>)<span class="cf">if</span>(s[j]==<span class="ch">&#39;1&#39;</span>)w[i][j+<span class="dv">1</span>]=w[i][j]+<span class="dv">1</span>,b[i][j+<span class="dv">1</span>]=b[i][j];</span>
<span id="cb28-21"><a href="#cb28-21"></a>                    <span class="cf">else</span> b[i][j+<span class="dv">1</span>]=b[i][j]+<span class="dv">1</span>,w[i][j+<span class="dv">1</span>]=w[i][j];</span>
<span id="cb28-22"><a href="#cb28-22"></a>    }</span>
<span id="cb28-23"><a href="#cb28-23"></a>    memset(f,-<span class="dv">1</span>,<span class="kw">sizeof</span>(f)); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dfs(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>));</span>
<span id="cb28-24"><a href="#cb28-24"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb28-25"><a href="#cb28-25"></a>}</span></code></pre></div>
<footer>
    <hr>
    <center>
        Powered by <a href="https://github.com/ZimingYuan/Yblogs" target="_blank">Yblogs</a><br>
        转载请注明出处<br>
        © 2025 VnYzm的博客
    </center>
</footer>
</body>
</html>
