<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="SpinalWorkshop实验笔记（二）" />
  <meta name="keywords" content="spinalworkshop, spinalhdl, fpga" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 "LXGW Bright", Georgia, serif;
    --font-h: 1.4rem/1.5 "LXGW Bright", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" type="text/css" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css"/>
  <title>SpinalWorkshop实验笔记（二）</title>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">所有文章</a></li>
            <li><a href="/technique.html">技术</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li><a href="/friends.html">友链</a></li>
            <li><a href="/html/关于.html">关于</a></li>
            <li><a href="https://www.travellings.cn/go.html" target="_blank">开往</a></li>
            <li class="float-right">
              <div style="position: relative; display: inline-block;">
                <input type="search" placeholder="搜索标题" style="margin: 0; padding-right: 2em;">
                <button style="position: absolute; right: 0; top: 50%; transform: translateY(-50%); border: none; background: transparent; margin: 0;" onclick="search()">
                  <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M15.7955 15.8111L21 21M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>
                </button>
              </div>
            </li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">SpinalWorkshop实验笔记（二）</h1>
<hr>
</header>
<h3 id="概述">概述</h3>
<p>本文涉及Function、Apb3Decoder、Timer、BlackBoxAndClock四个实验。<a href="https://github.com/SpinalHDL/SpinalWorkshop">实验地址</a></p>
<h3 id="内容">内容</h3>
<h4 id="function">Function</h4>
<p>本实验的电路分两个阶段：</p>
<ul>
<li>识别字符串：用从Flow中获得的字符匹配参数字符串</li>
<li>获得数据：匹配成功后，从字符串后面获得一定量的字节构成一个整数输出</li>
</ul>
<p>难点在于识别字符串。在前面的prime实验我们知道SpinalHDL的类型不能转换为scala基础类型，所以字符串索引无法使用。这个时候我们就要借鉴前面的思路：逐个比较，结果合并。对于一个SpinalHDL类型的索引，我们不能将其转换为scala基础类型，但我们可以和scala基础类型比较，比较结果就是SpinalHDL类型了。所以我们可以构造一个scala的int类型的表（整数区间）作为中介，判断是否存在表中有一个元素和当前索引相等，同时这个元素用来索引参数字符串得到的字符和当前Flow中得到的字符相等：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb1-1"><a href="#cb1-1"></a>  <span class="kw">def</span> <span class="fu">patternDetector</span>(str : String) = <span class="kw">new</span> Area{</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="kw">val</span> hit = False</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="co">// TODO</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="kw">val</span> cnt = <span class="fu">Counter</span>(str.<span class="fu">length</span>)</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="fu">when</span> (io.<span class="fu">cmd</span>.<span class="fu">valid</span>) {</span>
<span id="cb1-6"><a href="#cb1-6"></a>      <span class="fu">when</span>((<span class="dv">0</span> until str.<span class="fu">length</span>).<span class="fu">map</span>(x =&gt; cnt === x &amp;&amp; io.<span class="fu">cmd</span>.<span class="fu">payload</span> === <span class="fu">str</span>(x)).<span class="fu">orR</span>) {</span>
<span id="cb1-7"><a href="#cb1-7"></a>        <span class="fu">when</span> (cnt.<span class="fu">willOverflowIfInc</span>) {</span>
<span id="cb1-8"><a href="#cb1-8"></a>          hit := True</span>
<span id="cb1-9"><a href="#cb1-9"></a>          cnt.<span class="fu">clear</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>        } otherwise {</span>
<span id="cb1-11"><a href="#cb1-11"></a>          cnt.<span class="fu">increment</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>        }</span>
<span id="cb1-13"><a href="#cb1-13"></a>      } otherwise {</span>
<span id="cb1-14"><a href="#cb1-14"></a>        cnt.<span class="fu">clear</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>      }</span>
<span id="cb1-16"><a href="#cb1-16"></a>    }</span>
<span id="cb1-17"><a href="#cb1-17"></a>  }</span></code></pre></div>
<p>注意这里不能写成循环形式：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb2-1"><a href="#cb2-1"></a>  <span class="kw">for</span> (i &lt;- <span class="dv">0</span> until str.<span class="fu">length</span>) {</span>
<span id="cb2-2"><a href="#cb2-2"></a>      <span class="fu">when</span> (x =&gt; cnt === x &amp;&amp; io.<span class="fu">cmd</span>.<span class="fu">payload</span> === <span class="fu">str</span>(x)) {</span>
<span id="cb2-3"><a href="#cb2-3"></a>        <span class="fu">when</span> (cnt.<span class="fu">willOverflowIfInc</span>) {</span>
<span id="cb2-4"><a href="#cb2-4"></a>          hit := True</span>
<span id="cb2-5"><a href="#cb2-5"></a>          cnt.<span class="fu">clear</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>        } otherwise {</span>
<span id="cb2-7"><a href="#cb2-7"></a>          cnt.<span class="fu">increment</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>        }</span>
<span id="cb2-9"><a href="#cb2-9"></a>      } otherwise {</span>
<span id="cb2-10"><a href="#cb2-10"></a>        cnt.<span class="fu">clear</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>      }</span>
<span id="cb2-12"><a href="#cb2-12"></a>  }</span></code></pre></div>
<p>虽然表面上是等价的，都是把循环/区间展开，但是在下面这种情况下cnt在循环中会改变，整个意思就变了。而电路中又没有break语句用，这个地方如果是在软件中的话应该是非常明显的bug，但硬件上我就花了很长时间才发现，说明还是经验太少了。</p>
<p>获得数据阶段就不是很难了：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb3-1"><a href="#cb3-1"></a>  <span class="kw">def</span> <span class="fu">valueLoader</span>(start : Bool,that : Data)= <span class="kw">new</span> Area{</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="fu">require</span>(<span class="fu">widthOf</span>(that) % <span class="fu">widthOf</span>(io.<span class="fu">cmd</span>.<span class="fu">payload</span>) == <span class="dv">0</span>) <span class="co">//You can make the assumption that the &#39;that&#39; width is alwas an mulitple of 8</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="co">// TODO</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="kw">val</span> bytecnt = <span class="fu">widthOf</span>(that) / <span class="fu">widthOf</span>(io.<span class="fu">cmd</span>.<span class="fu">payload</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="kw">val</span> hit = <span class="fu">Reg</span>(False) <span class="fu">setWhen</span>(start)</span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="kw">val</span> cnt = <span class="fu">Counter</span>(bytecnt)</span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="kw">val</span> data = <span class="fu">Reg</span>(<span class="fu">Bits</span>(<span class="fu">widthOf</span>(that) bits))</span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="fu">when</span> (hit &amp;&amp; io.<span class="fu">cmd</span>.<span class="fu">valid</span>) {</span>
<span id="cb3-9"><a href="#cb3-9"></a>      data.<span class="fu">subdivideIn</span>(bytecnt slices)(cnt) := io.<span class="fu">cmd</span>.<span class="fu">payload</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>      hit.<span class="fu">clearWhen</span>(cnt.<span class="fu">willOverflowIfInc</span>)</span>
<span id="cb3-11"><a href="#cb3-11"></a>      cnt.<span class="fu">increment</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    }</span>
<span id="cb3-13"><a href="#cb3-13"></a>    that := data</span>
<span id="cb3-14"><a href="#cb3-14"></a>  }</span></code></pre></div>
<p>注意<code>data.subdivideIn(bytecnt slices)(cnt) := io.cmd.payload</code>切片后索引的变量cnt必须符合切片的块数，比如切片块数是8，cnt就必须是3位二进制数。奇怪的是，当that的位数为8的时候，bytecnt等于1，声明出的Counter的范围只有一个数：0。相当于是0位二进制数，非常反直觉的定义，一开始我很纠结，后来发现并不影响结果，但还是觉得很别扭。</p>
<h4 id="apb3decoder">Apb3Decoder</h4>
<p>这个实验评测需要用到python，注意用来评测的python库cocotb的版本必须是1.4.0及以下的，不然会有兼容性问题。</p>
<p>这个实验主要是要明白这个译码器做什么的，其实很简单，就是在一组子设备中找到对应地址区间的子设备，这个子设备的片选信号等于输入设备（父设备）的片选信号，同时父设备的三个接收信号PRDATA、PREADY和PSLERROR需要接收子设备的相应信号；其他设备就直接连：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb4-1"><a href="#cb4-1"></a>  <span class="co">//TODO fully asynchronous apb3 decoder</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  io.<span class="fu">input</span>.<span class="fu">PRDATA</span> := io.<span class="fu">outputs</span>(<span class="dv">0</span>).<span class="fu">PRDATA</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>  io.<span class="fu">input</span>.<span class="fu">PREADY</span> := io.<span class="fu">outputs</span>(<span class="dv">0</span>).<span class="fu">PREADY</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">if</span> (apbConfig.<span class="fu">useSlaveError</span>) {</span>
<span id="cb4-5"><a href="#cb4-5"></a>    io.<span class="fu">input</span>.<span class="fu">PSLVERROR</span> := io.<span class="fu">outputs</span>(<span class="dv">0</span>).<span class="fu">PSLVERROR</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  }</span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="kw">for</span> (i &lt;- <span class="dv">0</span> until outputsMapping.<span class="fu">length</span>) {</span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="fu">when</span> (<span class="fu">outputsMapping</span>(i).<span class="fu">hit</span>(io.<span class="fu">input</span>.<span class="fu">PADDR</span>)) {</span>
<span id="cb4-9"><a href="#cb4-9"></a>      io.<span class="fu">outputs</span>(i).<span class="fu">PSEL</span> := io.<span class="fu">input</span>.<span class="fu">PSEL</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>      io.<span class="fu">input</span>.<span class="fu">PRDATA</span> := io.<span class="fu">outputs</span>(i).<span class="fu">PRDATA</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>      io.<span class="fu">input</span>.<span class="fu">PREADY</span> := io.<span class="fu">outputs</span>(i).<span class="fu">PREADY</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>      <span class="kw">if</span> (apbConfig.<span class="fu">useSlaveError</span>) {</span>
<span id="cb4-13"><a href="#cb4-13"></a>        io.<span class="fu">input</span>.<span class="fu">PSLVERROR</span> := io.<span class="fu">outputs</span>(i).<span class="fu">PSLVERROR</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>      }</span>
<span id="cb4-15"><a href="#cb4-15"></a>    } otherwise {</span>
<span id="cb4-16"><a href="#cb4-16"></a>      io.<span class="fu">outputs</span>(i).<span class="fu">PSEL</span> := <span class="dv">0</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>    }</span>
<span id="cb4-18"><a href="#cb4-18"></a>    io.<span class="fu">outputs</span>(i).<span class="fu">PENABLE</span> := io.<span class="fu">input</span>.<span class="fu">PENABLE</span></span>
<span id="cb4-19"><a href="#cb4-19"></a>    io.<span class="fu">outputs</span>(i).<span class="fu">PADDR</span> := io.<span class="fu">input</span>.<span class="fu">PADDR</span></span>
<span id="cb4-20"><a href="#cb4-20"></a>    io.<span class="fu">outputs</span>(i).<span class="fu">PWRITE</span> := io.<span class="fu">input</span>.<span class="fu">PWRITE</span></span>
<span id="cb4-21"><a href="#cb4-21"></a>    io.<span class="fu">outputs</span>(i).<span class="fu">PWDATA</span> := io.<span class="fu">input</span>.<span class="fu">PWDATA</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>  }</span></code></pre></div>
<p>这里需要注意io.input的三个接收信号在使用时不能空置，即使是在整个for循环中一个子设备都没对上，也要强行赋一个值，不然会报latch error。文档里latch error介绍的是组合逻辑回路错误，实际上出现这种错误更多的原因是线路空置。一个类似的错误是寄存器没有初始化，这种错误一般不会像上面那种可以在生成电路时检测出来，而是直接导致逻辑错误。在普通评测时只会输出一个错误的值，而用python评测时会输出高阻的xxx。可能和两者后端的模拟器有关，前者时verilator，后者是icarus verilog。显然是后者更容易检查出错误，不过我觉得SpinalHDL应该出一个寄存器没赋初值就报错的生成选项，从根本上杜绝这种错误。</p>
<h4 id="timer">Timer</h4>
<p>这个实验有两个重点，一个是BusSlaveFactory对象的使用。我一开始一直不明白这个对象是干嘛用的，毕竟是fpga初学者。目前看来的作用应该是为地址映射提供便利，像前面pwm实验中就有根据地址读写电路内寄存器的需求，用了这个对象映射一个地址就是一句话的事；另一个是一连串信号源的处理，父模块可以将一连串信号都传入子模块由子模块来进行计算和连接：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb5-1"><a href="#cb5-1"></a>   <span class="kw">def</span> <span class="fu">driveFrom</span>(busCtrl : BusSlaveFactory,baseAddress : BigInt)(ticks : Seq[Bool],clears : Seq[Bool]) = <span class="kw">new</span> Area {</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="co">//TODO phase 2</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="kw">val</span> clear = False</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="kw">val</span> ticksEnable = busCtrl.<span class="fu">createReadAndWrite</span>(<span class="fu">Bits</span>(ticks.<span class="fu">length</span> bits), baseAddress + <span class="dv">0</span>, <span class="dv">0</span>) <span class="fu">init</span>(<span class="dv">0</span>)</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="kw">val</span> clearsEnable = busCtrl.<span class="fu">createReadAndWrite</span>(<span class="fu">Bits</span>(clears.<span class="fu">length</span> bits), baseAddress + <span class="dv">0</span>, <span class="dv">16</span>) <span class="fu">init</span>(<span class="dv">0</span>)</span>
<span id="cb5-7"><a href="#cb5-7"></a>    busCtrl.<span class="fu">driveAndRead</span>(io.<span class="fu">limit</span>, baseAddress + <span class="dv">4</span>)</span>
<span id="cb5-8"><a href="#cb5-8"></a>    clear.<span class="fu">setWhen</span>(busCtrl.<span class="fu">isWriting</span>(baseAddress + <span class="dv">4</span>))</span>
<span id="cb5-9"><a href="#cb5-9"></a>    busCtrl.<span class="fu">read</span>(io.<span class="fu">value</span>, baseAddress + <span class="dv">8</span>)</span>
<span id="cb5-10"><a href="#cb5-10"></a>    clear.<span class="fu">setWhen</span>(busCtrl.<span class="fu">isWriting</span>(baseAddress + <span class="dv">8</span>))</span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a>    io.<span class="fu">tick</span> := (ticksEnable &amp; ticks.<span class="fu">asBits</span>).<span class="fu">orR</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>    io.<span class="fu">clear</span> := (clearsEnable &amp; clears.<span class="fu">asBits</span>).<span class="fu">orR</span> | clear</span>
<span id="cb5-14"><a href="#cb5-14"></a>  }</span></code></pre></div>
<p>createReadAndWrite创建一个可读可写的寄存器并映射；driveAndRead是映射一个已有的端口，并设置为可读可写；read也是映射一个已有的端口，但设置为只读。isWriting用于捕获对地址的写请求。</p>
<p>计时器的电路代码非常简单：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb6-1"><a href="#cb6-1"></a>  <span class="co">//TODO phase 1</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="kw">val</span> v = <span class="fu">Counter</span>(width bits)</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="fu">when</span> (io.<span class="fu">clear</span>) {</span>
<span id="cb6-4"><a href="#cb6-4"></a>    v.<span class="fu">clear</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>  } <span class="fu">elsewhen</span> (io.<span class="fu">tick</span> &amp;&amp; v =/= io.<span class="fu">limit</span>) {</span>
<span id="cb6-6"><a href="#cb6-6"></a>    v.<span class="fu">increment</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>  }</span>
<span id="cb6-8"><a href="#cb6-8"></a>  io.<span class="fu">full</span> := v === io.<span class="fu">limit</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>  io.<span class="fu">value</span> := v</span></code></pre></div>
<h4 id="blackboxandclock">BlackBoxAndClock</h4>
<p>本实验的重点是blackbox的使用，这部分SpinalHDL的<a href="https://spinalhdl.github.io/SpinalDoc-RTD/master/SpinalHDL/Structuring/blackbox.html">文档</a>写得非常详细，所以实际上不难：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb7-1"><a href="#cb7-1"></a>  <span class="co">// TODO define Generics</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="fu">addGeneric</span>(<span class="st">&quot;wordWidth&quot;</span>, wordWidth)</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="fu">addGeneric</span>(<span class="st">&quot;addressWidth&quot;</span>, addressWidth)</span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="co">// TODO define IO</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>  <span class="kw">val</span> io = <span class="kw">new</span> Bundle {</span>
<span id="cb7-7"><a href="#cb7-7"></a>    <span class="kw">val</span> wr = <span class="kw">new</span> Bundle {</span>
<span id="cb7-8"><a href="#cb7-8"></a>      <span class="kw">val</span> clk = in Bool</span>
<span id="cb7-9"><a href="#cb7-9"></a>      <span class="kw">val</span> en   = in Bool</span>
<span id="cb7-10"><a href="#cb7-10"></a>      <span class="kw">val</span> addr = in <span class="fu">UInt</span>(addressWidth bit)</span>
<span id="cb7-11"><a href="#cb7-11"></a>      <span class="kw">val</span> data = in <span class="fu">Bits</span>(wordWidth bit)</span>
<span id="cb7-12"><a href="#cb7-12"></a>    }</span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="kw">val</span> rd = <span class="kw">new</span> Bundle {</span>
<span id="cb7-14"><a href="#cb7-14"></a>      <span class="kw">val</span> clk = in Bool</span>
<span id="cb7-15"><a href="#cb7-15"></a>      <span class="kw">val</span> en   = in Bool</span>
<span id="cb7-16"><a href="#cb7-16"></a>      <span class="kw">val</span> addr = in <span class="fu">UInt</span>(addressWidth bit)</span>
<span id="cb7-17"><a href="#cb7-17"></a>      <span class="kw">val</span> data = out <span class="fu">Bits</span>(wordWidth bit)</span>
<span id="cb7-18"><a href="#cb7-18"></a>    }</span>
<span id="cb7-19"><a href="#cb7-19"></a>  }</span>
<span id="cb7-20"><a href="#cb7-20"></a></span>
<span id="cb7-21"><a href="#cb7-21"></a>  <span class="co">// TODO define ClockDomains mappings</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>  <span class="fu">mapClockDomain</span>(writeClock, io.<span class="fu">wr</span>.<span class="fu">clk</span>)</span>
<span id="cb7-23"><a href="#cb7-23"></a>  <span class="fu">mapClockDomain</span>(readClock, io.<span class="fu">rd</span>.<span class="fu">clk</span>)</span></code></pre></div>
<p>基本上就是分三步走：</p>
<ol type="1">
<li>定义参数，用addGeneric，指定verilog模块中的parameter</li>
<li>定义接口，这里的层次结构要和verilog模块里的端口名相符合，比如上面代码里的io.wr.clk对应的就是verilog里的io_wr_clk，如果要违反命名规范需要特殊设置，文档里也有写</li>
<li>映射时钟，将当前的时钟或者你定义的时钟映射到verilog的时钟端口上</li>
</ol>
<p>然后是电路定义，这个虽然不是重点，但是我却栽了很大的跟头，花了很长时间去研究这个时序。之前verilog课的考试也是栽在时序上。这里我根据波形总结了三条定律：</p>
<ol type="1">
<li><p>对于when (cond) {xxx}这样的语句，xxx的触发在cond变为高电平之后的<strong>下次</strong>时钟上升沿。举例来说，假设第一个上升沿cond变成了高电平，那么xxx的第一次触发在第二个上升沿</p></li>
<li><p>内存的读数据端口会在读地址变化的<strong>下次</strong>时钟上升沿才产生变化</p></li>
<li><p>在时钟上升沿时，首先会对内存读数据端口取值，接着读数据端口更新，最后寄存器产生变化</p></li>
</ol>
<p>这样我们就可以分析下面的代码了：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb8-1"><a href="#cb8-1"></a>  <span class="kw">val</span> sumArea = <span class="kw">new</span> <span class="fu">ClockingArea</span>(sumClock){                                                                              <span class="co">// TODO define the memory read + summing logic</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="kw">val</span> sum = <span class="fu">Reg</span>(io.<span class="fu">sum</span>.<span class="fu">value</span>) <span class="fu">init</span>(<span class="dv">0</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a>    io.<span class="fu">sum</span>.<span class="fu">value</span> := sum</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="kw">val</span> readAddr = <span class="fu">Counter</span>(<span class="fu">widthOf</span>(io.<span class="fu">wr</span>.<span class="fu">addr</span>) bits)</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="kw">var</span> cntEnable = <span class="fu">RegInit</span>(False)</span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="kw">val</span> sumEnable = <span class="fu">RegNext</span>(cntEnable) <span class="fu">init</span>(False)</span>
<span id="cb8-8"><a href="#cb8-8"></a>    ram.<span class="fu">io</span>.<span class="fu">rd</span>.<span class="fu">en</span> := cntEnable</span>
<span id="cb8-9"><a href="#cb8-9"></a>    ram.<span class="fu">io</span>.<span class="fu">rd</span>.<span class="fu">addr</span> := readAddr</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="fu">when</span> (io.<span class="fu">sum</span>.<span class="fu">start</span>) {</span>
<span id="cb8-12"><a href="#cb8-12"></a>      cntEnable.<span class="fu">set</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>      readAddr.<span class="fu">clear</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>      sum.<span class="fu">clearAll</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>    }</span>
<span id="cb8-16"><a href="#cb8-16"></a></span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="fu">when</span> (cntEnable) {</span>
<span id="cb8-18"><a href="#cb8-18"></a>      readAddr.<span class="fu">increment</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>    }</span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="fu">when</span> (sumEnable) {</span>
<span id="cb8-21"><a href="#cb8-21"></a>      sum := sum + ram.<span class="fu">io</span>.<span class="fu">rd</span>.<span class="fu">data</span>.<span class="fu">asUInt</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>      cntEnable.<span class="fu">clearWhen</span>(readAddr.<span class="fu">willOverflowIfInc</span>)</span>
<span id="cb8-23"><a href="#cb8-23"></a>    }</span>
<span id="cb8-24"><a href="#cb8-24"></a>    io.<span class="fu">sum</span>.<span class="fu">done</span>.<span class="fu">clear</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>    io.<span class="fu">sum</span>.<span class="fu">done</span>.<span class="fu">setWhen</span>(sumEnable.<span class="fu">fall</span>(False))</span>
<span id="cb8-26"><a href="#cb8-26"></a>  }</span></code></pre></div>
<p>设io.sum.start被触发是第0时钟上升沿，根据定律1，cntEnable被置1和readAddr清零是第1上升沿。则在第2上升沿，readAddr变为1，且sumEnable紧随cntEnable被置1，又根据定律2，这时ram.io.rd.data才是地址为0的值。在第3上升沿，根据定律3，首先取ram.io.rd.data的值加到sum上，然后ram.io.rd.data更新为地址为1的值，最后readAddr变为2。在第4上升沿，同样地址为1的值被加到sum上，再更新内存读端口，再更新计数器，以此类推。</p>
<p>可以看出，每次加在sum寄存器上的值是当前计数器减2作为地址得到的值，这也是为什么要两个enable的原因。对于结束时的信号，也得仔细分析，设readAddr被加到0xFF的那个上升沿为第0上升沿，这时sum加上了地址为0xFD的内存值，然后端口更新为地址为0xFE的内存值。根据定律1，在第1上升沿，cntEnable清零，同时sum加上地址为0xFE的内存值，端口更新为地址为0xFF的内存值，readAddr更新为0。这时io.sum.done不能置1，因为sum还没加完。在第2上升沿，sumEnable随之清零，同时sum加上地址为0xFF的内存值，端口更新，readAddr已经不会加了，io.sum.done在sumEnable清零的瞬间置1。这里只能用“清零的瞬间”这个条件，因为用高电平还是低电平判断怎么也不合适。</p>
<p>然后有两个注意的地方：</p>
<ul>
<li><p>布尔型寄存器设置初始值要用RegInit或者Reg(Bool) init()，我以前以为Reg(False)就是赋初值为False了，结果并不是，只是说明这个寄存器和False是同类型而已</p></li>
<li><p>关于xxx.fall函数，我看<a href="https://github.com/SpinalHDL/SpinalHDL/blob/dev/core/src/main/scala/spinal/core/Bool.scala">SpinalHDL源代码</a>里有两个重载：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb9-1"><a href="#cb9-1"></a>  <span class="co">/**</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>    <span class="co">*</span> Falling edge detection of this with an initial value</span>
<span id="cb9-3"><a href="#cb9-3"></a>    <span class="co">*</span> <span class="co">@</span>example<span class="re">{{{</span> val res <span class="co">=</span> myBool<span class="co">.</span>fall<span class="co">(</span>False<span class="co">)</span> <span class="re">}}}</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="co">* </span><span class="an">@param initAt </span>the initial value</span>
<span id="cb9-5"><a href="#cb9-5"></a>    <span class="co">*</span> <span class="an">@return </span>a Bool</span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="co">*/</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>  <span class="kw">def</span> <span class="fu">fall</span>(initAt: Bool): Bool = ! <span class="kw">this</span> &amp;&amp; <span class="fu">RegNext</span>(<span class="kw">this</span>).<span class="fu">init</span>(initAt)</span>
<span id="cb9-8"><a href="#cb9-8"></a>  <span class="co">/**</span> Falling edge detection <span class="co">*/</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>  <span class="kw">def</span> <span class="fu">fall</span>(): Bool = ! <span class="kw">this</span> &amp;&amp; <span class="fu">RegNext</span>(<span class="kw">this</span>)</span></code></pre></div>
<p>实现方式是定义一个寄存器作为当前信号的后继，这样当前信号下降的时候后继寄存器还没下降。我一开始没仔细看，选了后面那个没参数的重载。结果那个后继寄存器没初始化！众所周知，没有初始化会导致一些匪夷所思的结果，我就遇到了诸如when (cond) {do A} otherwise {do B}和when (!cond) {do B} otherwise {do A}结果不一样和计数器只能用Reg不能用Counter之类的诡异问题。最后看了波形才明白，原因是后继寄存器一开始为1，所以只要当前信号是低电平都会返回1。我只想吐槽一句，写第二个重载的人是不是SpinalHDL项目组里的内鬼，这不是纯坑爹吗？事实上，我觉得初始值直接默认为假就可以了，根本就没有初始值为真能返回正确结果的情况。</p></li>
</ul>
<footer>
    <hr>
    <center>
        Powered by <a href="https://github.com/ZimingYuan/Yblogs" target="_blank">Yblogs</a><br>
        转载请注明出处 © 2025 VnYzm的博客<br>
        <span id="busuanzi_container_site_uv">2025年10月7日以来总访问量为<span id="busuanzi_value_site_uv"></span>次</span>
    </center>
</footer>
</body>
</html>
