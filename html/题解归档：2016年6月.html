<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="题解归档：2016年6月" />
  <meta name="keywords" content="" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 "LXGW Bright", Georgia, serif;
    --font-h: 1.4rem/1.5 "LXGW Bright", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" type="text/css" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css"/>
  <title>题解归档：2016年6月</title>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">所有文章</a></li>
            <li><a href="/technique.html">技术</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li><a href="/friends.html">友链</a></li>
            <li><a href="/html/关于.html">关于</a></li>
            <li><a href="https://www.travellings.cn/go.html" target="_blank">开往</a></li>
            <li class="float-right sticky"><button style="margin: 0" onclick="search()">
              <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M15.7955 15.8111L21 21M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>
            </button></li>
            <li class="float-right sticky"><input type="search" placeholder="搜索标题" style="margin: 0"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">题解归档：2016年6月</h1>
<hr>
</header>
<h3 id="bzoj1218hnoi2003激光炸弹2016.6.2">bzoj1218[HNOI2003]激光炸弹（2016.6.2）</h3>
<h4 id="题意">题意</h4>
<p>坐标系上有n个目标，每个目标有一个价值，现在求一个边与坐标轴平行，边长为R的正方形，使在其内部（原题是不包括边界，然而实际上不是这样）的目标价值最大。</p>
<h4 id="题解">题解</h4>
<p>预处理一下以横纵坐标为节点的二维前缀和，然后枚举正方形右上角坐标即可。注意可以将坐标系向右上移动一个单位使前缀和不用考虑负数。反思：蒟蒻好弱啊，枚举时i和j的边界都应该是所以节点横坐标最大值与纵坐标最大值的最大值。蒟蒻一开始没注意到这一点，以为自己预处理写错。改来改去，WA来WA去。最后对着标程一点点改才发现问题。QAQ</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#define maxn </span><span class="dv">5500</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="dt">int</span> sum[maxn][maxn],n,mxxy,r,mx;</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="dt">int</span> main(){</span>
<span id="cb1-10"><a href="#cb1-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;r); mxxy=mx=<span class="dv">0</span>;</span>
<span id="cb1-11"><a href="#cb1-11"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb1-12"><a href="#cb1-12"></a>        <span class="dt">int</span> x,y,z; scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y,&amp;z); x++; y++;</span>
<span id="cb1-13"><a href="#cb1-13"></a>        mxxy=max(mxxy,x); mxxy=max(mxxy,y); sum[x][y]+=z;</span>
<span id="cb1-14"><a href="#cb1-14"></a>    }</span>
<span id="cb1-15"><a href="#cb1-15"></a>    inc(i,<span class="dv">1</span>,mxxy)inc(j,<span class="dv">1</span>,mxxy)</span>
<span id="cb1-16"><a href="#cb1-16"></a>        sum[i][j]+=sum[i-<span class="dv">1</span>][j]+sum[i][j-<span class="dv">1</span>]-sum[i-<span class="dv">1</span>][j-<span class="dv">1</span>];</span>
<span id="cb1-17"><a href="#cb1-17"></a>    inc(i,r,mxxy)inc(j,r,mxxy)</span>
<span id="cb1-18"><a href="#cb1-18"></a>        mx=max(mx,sum[i][j]-sum[i][j-r]-sum[i-r][j]+sum[i-r][j-r]);</span>
<span id="cb1-19"><a href="#cb1-19"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,mx); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-20"><a href="#cb1-20"></a>}</span></code></pre></div>
<h3 id="bzoj1295scoi2009最长距离2016.6.2">bzoj1295[SCOI2009]最长距离（2016.6.2）</h3>
<h4 id="题意-1">题意</h4>
<p>N*M块地，如果两块地都没有障碍物，则互相可达。如果两块地互相可达（可经过其他地）则它们之间的距离为它们中心点的欧几里得距离，求如果能移走不大于T个障碍物，土地间的最大距离。N，M≤30</p>
<h4 id="题解-1">题解</h4>
<p>把经过一个障碍物视为边长度为1，求出每两个点之间要跨越的边长度，如果长度小于等于T，就将其欧几里得距离和答案比较。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="pp">#define maxn </span><span class="dv">100</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="dt">int</span> map[maxn][maxn],n,m,k; <span class="dt">double</span> mx;</span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="dt">bool</span> vis[maxn][maxn],inq[maxn][maxn]; <span class="dt">int</span> d[maxn][maxn];</span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="kw">struct</span> qn{<span class="dt">int</span> x,y;}; queue &lt;qn&gt; q;</span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="dt">void</span> spfa(<span class="dt">int</span> sx,<span class="dt">int</span> sy){</span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="cf">while</span>(!q.empty())q.pop(); q.push((qn){sx,sy}); memset(d,-<span class="dv">1</span>,<span class="kw">sizeof</span>(d)); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq));</span>
<span id="cb2-17"><a href="#cb2-17"></a>    memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); d[sx][sy]=map[sx][sy]; inq[sx][sy]=<span class="dv">1</span>;</span>
<span id="cb2-18"><a href="#cb2-18"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb2-19"><a href="#cb2-19"></a>        qn x=q.front(); q.pop(); inq[x.x][x.y]=<span class="dv">0</span>;</span>
<span id="cb2-20"><a href="#cb2-20"></a>        <span class="cf">if</span>(x.x!=<span class="dv">1</span>&amp;&amp;(d[x.x-<span class="dv">1</span>][x.y]==-<span class="dv">1</span>||d[x.x-<span class="dv">1</span>][x.y]&gt;d[x.x][x.y]+map[x.x-<span class="dv">1</span>][x.y])){</span>
<span id="cb2-21"><a href="#cb2-21"></a>            d[x.x-<span class="dv">1</span>][x.y]=d[x.x][x.y]+map[x.x-<span class="dv">1</span>][x.y];</span>
<span id="cb2-22"><a href="#cb2-22"></a>            <span class="cf">if</span>(!inq[x.x-<span class="dv">1</span>][x.y])inq[x.x-<span class="dv">1</span>][x.y]=<span class="dv">1</span>,q.push((qn){x.x-<span class="dv">1</span>,x.y});</span>
<span id="cb2-23"><a href="#cb2-23"></a>        }</span>
<span id="cb2-24"><a href="#cb2-24"></a>        <span class="cf">if</span>(x.y!=<span class="dv">1</span>&amp;&amp;(d[x.x][x.y-<span class="dv">1</span>]==-<span class="dv">1</span>||d[x.x][x.y-<span class="dv">1</span>]&gt;d[x.x][x.y]+map[x.x][x.y-<span class="dv">1</span>])){</span>
<span id="cb2-25"><a href="#cb2-25"></a>            d[x.x][x.y-<span class="dv">1</span>]=d[x.x][x.y]+map[x.x][x.y-<span class="dv">1</span>];</span>
<span id="cb2-26"><a href="#cb2-26"></a>            <span class="cf">if</span>(!inq[x.x][x.y-<span class="dv">1</span>])inq[x.x][x.y-<span class="dv">1</span>]=<span class="dv">1</span>,q.push((qn){x.x,x.y-<span class="dv">1</span>});</span>
<span id="cb2-27"><a href="#cb2-27"></a>        }</span>
<span id="cb2-28"><a href="#cb2-28"></a>        <span class="cf">if</span>(x.x!=n&amp;&amp;(d[x.x+<span class="dv">1</span>][x.y]==-<span class="dv">1</span>||d[x.x+<span class="dv">1</span>][x.y]&gt;d[x.x][x.y]+map[x.x+<span class="dv">1</span>][x.y])){</span>
<span id="cb2-29"><a href="#cb2-29"></a>            d[x.x+<span class="dv">1</span>][x.y]=d[x.x][x.y]+map[x.x+<span class="dv">1</span>][x.y];</span>
<span id="cb2-30"><a href="#cb2-30"></a>            <span class="cf">if</span>(!inq[x.x+<span class="dv">1</span>][x.y])inq[x.x+<span class="dv">1</span>][x.y]=<span class="dv">1</span>,q.push((qn){x.x+<span class="dv">1</span>,x.y});</span>
<span id="cb2-31"><a href="#cb2-31"></a>        }</span>
<span id="cb2-32"><a href="#cb2-32"></a>        <span class="cf">if</span>(x.y!=m&amp;&amp;(d[x.x][x.y+<span class="dv">1</span>]==-<span class="dv">1</span>||d[x.x][x.y+<span class="dv">1</span>]&gt;d[x.x][x.y]+map[x.x][x.y+<span class="dv">1</span>])){</span>
<span id="cb2-33"><a href="#cb2-33"></a>            d[x.x][x.y+<span class="dv">1</span>]=d[x.x][x.y]+map[x.x][x.y+<span class="dv">1</span>];</span>
<span id="cb2-34"><a href="#cb2-34"></a>            <span class="cf">if</span>(!inq[x.x][x.y+<span class="dv">1</span>])inq[x.x][x.y+<span class="dv">1</span>]=<span class="dv">1</span>,q.push((qn){x.x,x.y+<span class="dv">1</span>});</span>
<span id="cb2-35"><a href="#cb2-35"></a>        }</span>
<span id="cb2-36"><a href="#cb2-36"></a>    }</span>
<span id="cb2-37"><a href="#cb2-37"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,m)<span class="cf">if</span>(d[i][j]&lt;=k)vis[i][j]=<span class="dv">1</span>;</span>
<span id="cb2-38"><a href="#cb2-38"></a>}</span>
<span id="cb2-39"><a href="#cb2-39"></a><span class="dt">int</span> main(){</span>
<span id="cb2-40"><a href="#cb2-40"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m,&amp;k); <span class="dt">char</span> c;</span>
<span id="cb2-41"><a href="#cb2-41"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,m){</span>
<span id="cb2-42"><a href="#cb2-42"></a>        <span class="cf">while</span>(!isdigit(c=getchar())); map[i][j]=c-<span class="ch">&#39;0&#39;</span>;</span>
<span id="cb2-43"><a href="#cb2-43"></a>    }</span>
<span id="cb2-44"><a href="#cb2-44"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,m){</span>
<span id="cb2-45"><a href="#cb2-45"></a>        spfa(i,j); inc(i0,<span class="dv">1</span>,n)inc(j0,<span class="dv">1</span>,m)<span class="cf">if</span>(vis[i0][j0])mx=max(mx,sqrt((i0-i)*(i0-i)+(j0-j)*(j0-j)));</span>
<span id="cb2-46"><a href="#cb2-46"></a>    }</span>
<span id="cb2-47"><a href="#cb2-47"></a>    printf(<span class="st">&quot;%.6lf&quot;</span>,mx); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-48"><a href="#cb2-48"></a>}</span></code></pre></div>
<h3 id="bzoj1221hnoi2001软件开发2016.6.2">bzoj1221[HNOI2001]软件开发（2016.6.2）</h3>
<h4 id="题意-2">题意</h4>
<p>n天，每天需要ai条消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。消毒方式有两种，A种方式的消毒需要a天时间，一条费用fA，B种方式的消毒需要b天，一条费用fB，买一块新毛巾的费用为f（新毛巾是已消毒的，当天可以使用），求最小费用。n≤1000</p>
<h4 id="题解-2">题解</h4>
<p>费用流。每天拆成x和y。s向所有x连边表示有的毛巾，所有y向t连边表示用的毛巾，流量为需要毛巾数费用0。xi向yi+a连边，表示a方式消毒，xi向yi+b连边，表示b方式消毒，s向所有y连边，表示买新的，xi向xi+1连边，表示前一天没用的拿到第二天用。反思：费用流关键是要抓住“流量优先”。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="pp">#define maxn </span><span class="dv">3000</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,c,w,n;}; e es[maxn*<span class="dv">40</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c,<span class="dt">int</span> w){</span>
<span id="cb3-12"><a href="#cb3-12"></a>    es[++ess]=(e){f,t,c,w,g[f]}; g[f]=ess; es[++ess]=(e){t,f,<span class="dv">0</span>,-w,g[t]}; g[t]=ess;</span>
<span id="cb3-13"><a href="#cb3-13"></a>}</span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="dt">void</span> init(){ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="dt">int</span> d[maxn],fr[maxn]; <span class="dt">bool</span> inq[maxn]; queue &lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="dt">bool</span> spfa(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb3-17"><a href="#cb3-17"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); memset(d,-<span class="dv">1</span>,<span class="kw">sizeof</span>(d));</span>
<span id="cb3-18"><a href="#cb3-18"></a>    inq[s]=<span class="dv">1</span>; d[s]=<span class="dv">0</span>; q.push(s); fr[s]=-<span class="dv">1</span>;</span>
<span id="cb3-19"><a href="#cb3-19"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb3-20"><a href="#cb3-20"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb3-21"><a href="#cb3-21"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;(d[es[i].t]==-<span class="dv">1</span>||d[es[i].t]&gt;d[x]+es[i].w)){</span>
<span id="cb3-22"><a href="#cb3-22"></a>            d[es[i].t]=d[x]+es[i].w; fr[es[i].t]=i; <span class="cf">if</span>(!inq[es[i].t])inq[es[i].t]=<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb3-23"><a href="#cb3-23"></a>        }</span>
<span id="cb3-24"><a href="#cb3-24"></a>    }</span>
<span id="cb3-25"><a href="#cb3-25"></a>    <span class="cf">return</span> d[t]!=-<span class="dv">1</span>;</span>
<span id="cb3-26"><a href="#cb3-26"></a>}</span>
<span id="cb3-27"><a href="#cb3-27"></a><span class="dt">int</span> advanced(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb3-28"><a href="#cb3-28"></a>    <span class="dt">int</span> a=INF,c=<span class="dv">0</span>;</span>
<span id="cb3-29"><a href="#cb3-29"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=fr[t];i!=-<span class="dv">1</span>;i=fr[es[i].f])a=min(a,es[i].c);</span>
<span id="cb3-30"><a href="#cb3-30"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=fr[t];i!=-<span class="dv">1</span>;i=fr[es[i].f])es[i].c-=a,es[i^<span class="dv">1</span>].c+=a,c+=(a*es[i].w);</span>
<span id="cb3-31"><a href="#cb3-31"></a>    <span class="cf">return</span> c;</span>
<span id="cb3-32"><a href="#cb3-32"></a>}</span>
<span id="cb3-33"><a href="#cb3-33"></a><span class="dt">int</span> maxflowmincost(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb3-34"><a href="#cb3-34"></a>    <span class="dt">int</span> c=<span class="dv">0</span>; <span class="cf">while</span>(spfa(s,t))c+=advanced(s,t); <span class="cf">return</span> c;</span>
<span id="cb3-35"><a href="#cb3-35"></a>}</span>
<span id="cb3-36"><a href="#cb3-36"></a><span class="dt">int</span> n,a,b,f,fa,fb,s,t,x;</span>
<span id="cb3-37"><a href="#cb3-37"></a><span class="dt">int</span> main(){</span>
<span id="cb3-38"><a href="#cb3-38"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;a,&amp;b,&amp;f,&amp;fa,&amp;fb); s=<span class="dv">0</span>; t=<span class="dv">2</span>*n+<span class="dv">1</span>; init();</span>
<span id="cb3-39"><a href="#cb3-39"></a>    inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x),pe(s,i,x,<span class="dv">0</span>),pe(n+i,t,x,<span class="dv">0</span>);</span>
<span id="cb3-40"><a href="#cb3-40"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb3-41"><a href="#cb3-41"></a>        <span class="cf">if</span>(i+a&lt;n)pe(i,n+i+a+<span class="dv">1</span>,INF,fa); <span class="cf">if</span>(i+b&lt;n)pe(i,n+i+b+<span class="dv">1</span>,INF,fb);</span>
<span id="cb3-42"><a href="#cb3-42"></a>        <span class="cf">if</span>(i&lt;n)pe(i,i+<span class="dv">1</span>,INF,<span class="dv">0</span>); pe(s,i+n,INF,f);</span>
<span id="cb3-43"><a href="#cb3-43"></a>    }</span>
<span id="cb3-44"><a href="#cb3-44"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,maxflowmincost(s,t)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-45"><a href="#cb3-45"></a>}</span></code></pre></div>
<h3 id="bzoj1293scoi2009生日礼物2016.6.2">bzoj1293[SCOI2009]生日礼物（2016.6.2）</h3>
<h4 id="题意-3">题意</h4>
<p>数轴上N个点，分为K种。可以有多个点出现在同一个位置上。需要一个最短区间使里面有K种点，求这个区间长度。N≤1000000</p>
<h4 id="题解-3">题解</h4>
<p>先排序，然后用两个指针分别指向区间两个端点，每次l指针往左移并更新答案直到区间里没有K种点，再把r指针向右移直到区间里有K种点，更新一下答案。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="kw">struct</span> ball{<span class="dt">int</span> a,b;}; ball balls[<span class="dv">1000500</span>];</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="dt">bool</span> cmp(ball a,ball b){<span class="cf">return</span> a.a&lt;b.a;}</span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="dt">int</span> n,k,l,r,bs,kn[<span class="dv">70</span>],ks,mn;</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="dt">int</span> main(){</span>
<span id="cb4-12"><a href="#cb4-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k);</span>
<span id="cb4-13"><a href="#cb4-13"></a>    inc(i,<span class="dv">1</span>,k){</span>
<span id="cb4-14"><a href="#cb4-14"></a>        <span class="dt">int</span> x,y; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x); inc(j,<span class="dv">1</span>,x)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;y),balls[++bs]=(ball){y,i};</span>
<span id="cb4-15"><a href="#cb4-15"></a>    }</span>
<span id="cb4-16"><a href="#cb4-16"></a>    sort(balls+<span class="dv">1</span>,balls+<span class="dv">1</span>+bs,cmp); l=<span class="dv">1</span>; r=<span class="dv">0</span>;</span>
<span id="cb4-17"><a href="#cb4-17"></a>    memset(kn,<span class="dv">0</span>,<span class="kw">sizeof</span>(kn)); ks=<span class="dv">0</span>; mn=INF;</span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="cf">while</span>(ks&lt;k){</span>
<span id="cb4-19"><a href="#cb4-19"></a>        <span class="cf">if</span>(r&lt;n){r++; kn[balls[r].b]++; <span class="cf">if</span>(kn[balls[r].b]==<span class="dv">1</span>)ks++;}</span>
<span id="cb4-20"><a href="#cb4-20"></a>        <span class="cf">while</span>(r&lt;n&amp;&amp;balls[r].a==balls[r+<span class="dv">1</span>].a){r++; kn[balls[r].b]++; <span class="cf">if</span>(kn[balls[r].b]==<span class="dv">1</span>)ks++;}</span>
<span id="cb4-21"><a href="#cb4-21"></a>        <span class="cf">if</span>(r==n)<span class="cf">break</span>;</span>
<span id="cb4-22"><a href="#cb4-22"></a>    }</span>
<span id="cb4-23"><a href="#cb4-23"></a>    <span class="cf">if</span>(ks==k)mn=min(mn,balls[r].a-balls[l].a);</span>
<span id="cb4-24"><a href="#cb4-24"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb4-25"><a href="#cb4-25"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;balls[l].a==balls[l+<span class="dv">1</span>].a){kn[balls[l].b]--; <span class="cf">if</span>(kn[balls[l].b]==<span class="dv">0</span>)ks--; l++;}</span>
<span id="cb4-26"><a href="#cb4-26"></a>        <span class="cf">if</span>(l&lt;r){kn[balls[l].b]--; <span class="cf">if</span>(kn[balls[l].b]==<span class="dv">0</span>)ks--; l++;}</span>
<span id="cb4-27"><a href="#cb4-27"></a>        <span class="cf">if</span>(ks==k)mn=min(mn,balls[r].a-balls[l].a);<span class="cf">else</span>{</span>
<span id="cb4-28"><a href="#cb4-28"></a>            <span class="cf">while</span>(ks&lt;k){</span>
<span id="cb4-29"><a href="#cb4-29"></a>                <span class="cf">if</span>(r&lt;n){r++; kn[balls[r].b]++; <span class="cf">if</span>(kn[balls[r].b]==<span class="dv">1</span>)ks++;}</span>
<span id="cb4-30"><a href="#cb4-30"></a>                <span class="cf">while</span>(r&lt;n&amp;&amp;balls[r].a==balls[r+<span class="dv">1</span>].a){r++; kn[balls[r].b]++; <span class="cf">if</span>(kn[balls[r].b]==<span class="dv">1</span>)ks++;}</span>
<span id="cb4-31"><a href="#cb4-31"></a>                <span class="cf">if</span>(r==n)<span class="cf">break</span>;</span>
<span id="cb4-32"><a href="#cb4-32"></a>            }</span>
<span id="cb4-33"><a href="#cb4-33"></a>            <span class="cf">if</span>(ks==k)mn=min(mn,balls[r].a-balls[l].a);</span>
<span id="cb4-34"><a href="#cb4-34"></a>        }</span>
<span id="cb4-35"><a href="#cb4-35"></a>        <span class="cf">if</span>(l==r)<span class="cf">break</span>;</span>
<span id="cb4-36"><a href="#cb4-36"></a>    }</span>
<span id="cb4-37"><a href="#cb4-37"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,mn); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb4-38"><a href="#cb4-38"></a>}</span></code></pre></div>
<h3 id="bzoj1787ahoi2008meet-紧急集合bzoj1832ahoi2008聚会2016.6.3">bzoj1787[Ahoi2008]Meet 紧急集合&amp;bzoj1832[AHOI2008]聚会（2016.6.3）</h3>
<h4 id="题意-4">题意</h4>
<p>给个树，每次给三个点，求与这三个点距离最小的点。</p>
<h4 id="题解-4">题解</h4>
<p>倍增求出两两之间的LCA后，比较容易理解的做法是挑出两个LCA再做一次LCA，比较所有挑法。但画kan出ti图jie可知其中有两个LCA是相等的，而所求就是那个与它们不等的LCA（我也不知为什么）。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="pp">#define maxn </span><span class="dv">500500</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="cf">return</span> x*f;</span>
<span id="cb5-12"><a href="#cb5-12"></a>}</span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="dt">int</span> fa[maxn][<span class="dv">20</span>],dep[maxn];</span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){</span>
<span id="cb5-16"><a href="#cb5-16"></a>    es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;</span>
<span id="cb5-17"><a href="#cb5-17"></a>}</span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="dt">void</span> init(){ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> f){</span>
<span id="cb5-20"><a href="#cb5-20"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f){</span>
<span id="cb5-21"><a href="#cb5-21"></a>        dep[es[i].t]=dep[x]+<span class="dv">1</span>; fa[es[i].t][<span class="dv">0</span>]=x; dfs(es[i].t,x);</span>
<span id="cb5-22"><a href="#cb5-22"></a>    }</span>
<span id="cb5-23"><a href="#cb5-23"></a>}</span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="dt">int</span> n,m;</span>
<span id="cb5-25"><a href="#cb5-25"></a><span class="dt">void</span> build(){</span>
<span id="cb5-26"><a href="#cb5-26"></a>    <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">1</span>;(<span class="dv">1</span>&lt;&lt;j)&lt;=n;j++)inc(i,<span class="dv">1</span>,n)fa[i][j]=fa[fa[i][j-<span class="dv">1</span>]][j-<span class="dv">1</span>];</span>
<span id="cb5-27"><a href="#cb5-27"></a>}</span>
<span id="cb5-28"><a href="#cb5-28"></a><span class="dt">int</span> lca(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb5-29"><a href="#cb5-29"></a>    <span class="cf">if</span>(dep[x]&lt;dep[y])swap(x,y); <span class="dt">int</span> t=dep[x]-dep[y];</span>
<span id="cb5-30"><a href="#cb5-30"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;(<span class="dv">1</span>&lt;&lt;i)&lt;=n;i++)<span class="cf">if</span>(t&amp;(<span class="dv">1</span>&lt;&lt;i))x=fa[x][i];</span>
<span id="cb5-31"><a href="#cb5-31"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">18</span>;i&gt;=<span class="dv">0</span>;i--)<span class="cf">if</span>(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];</span>
<span id="cb5-32"><a href="#cb5-32"></a>    <span class="cf">if</span>(x==y)<span class="cf">return</span> x;<span class="cf">else</span> <span class="cf">return</span> fa[x][<span class="dv">0</span>];</span>
<span id="cb5-33"><a href="#cb5-33"></a>}</span>
<span id="cb5-34"><a href="#cb5-34"></a><span class="dt">int</span> dis(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb5-35"><a href="#cb5-35"></a>    <span class="dt">int</span> z=lca(x,y); <span class="cf">return</span> dep[x]-dep[z]+dep[y]-dep[z];</span>
<span id="cb5-36"><a href="#cb5-36"></a>}</span>
<span id="cb5-37"><a href="#cb5-37"></a><span class="dt">int</span> main(){</span>
<span id="cb5-38"><a href="#cb5-38"></a>    n=read(); m=read(); init(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a=read(),b=read(); pe(a,b);}</span>
<span id="cb5-39"><a href="#cb5-39"></a>    dep[<span class="dv">1</span>]=<span class="dv">0</span>; fa[<span class="dv">1</span>][<span class="dv">0</span>]=<span class="dv">0</span>; dfs(<span class="dv">1</span>,<span class="dv">0</span>); build();</span>
<span id="cb5-40"><a href="#cb5-40"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb5-41"><a href="#cb5-41"></a>        <span class="dt">int</span> a=read(),b=read(),c=read(); <span class="dt">int</span> x=lca(a,b),y=lca(a,c),z=lca(b,c);</span>
<span id="cb5-42"><a href="#cb5-42"></a>        <span class="cf">if</span>(x==y)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span>,z,dis(a,z)+dis(b,z)+dis(c,z));</span>
<span id="cb5-43"><a href="#cb5-43"></a>        <span class="cf">else</span> <span class="cf">if</span>(x==z)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span>,y,dis(a,y)+dis(b,y)+dis(c,y));</span>
<span id="cb5-44"><a href="#cb5-44"></a>        <span class="cf">else</span> <span class="cf">if</span>(y==z)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span>,x,dis(a,x)+dis(b,x)+dis(c,x));</span>
<span id="cb5-45"><a href="#cb5-45"></a>    }</span>
<span id="cb5-46"><a href="#cb5-46"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-47"><a href="#cb5-47"></a>}</span></code></pre></div>
<h3 id="bzoj1934shoi2007vote-善意的投票2016.6.3">bzoj1934[Shoi2007]Vote 善意的投票（2016.6.3）</h3>
<h4 id="题意-5">题意</h4>
<p>n个小朋友通过投票来决定睡不睡午觉。每个人都有自己的主见，但也可以投和自己本来意愿相反的票。冲突总数为好朋友之间发生冲突的总数加上和自己本来意愿发生冲突的人数。求最小冲突数。</p>
<h4 id="题解-5">题解</h4>
<p>最小割，s向每个选1的人连边流量为1，每个选0的人连边流量为1。好朋友之间连流量为1的双向边。反思：理解错题意……以为冲突总数是每个人投票的冲突数之和，每个人投票冲突数是与朋友之间发生冲突的总数加上和这个人本来意愿发生冲突的人数。脑洞好大QAQ</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="pp">#define maxn </span><span class="dv">500</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,c,n;}; e es[maxn*<span class="dv">2000</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c){</span>
<span id="cb6-12"><a href="#cb6-12"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,g[t]}; g[t]=ess;</span>
<span id="cb6-13"><a href="#cb6-13"></a>}</span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="kw">inline</span> <span class="dt">void</span> pe2(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c){</span>
<span id="cb6-15"><a href="#cb6-15"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,c,g[t]}; g[t]=ess;</span>
<span id="cb6-16"><a href="#cb6-16"></a>}</span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="kw">inline</span> <span class="dt">void</span> init(){</span>
<span id="cb6-18"><a href="#cb6-18"></a>    ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb6-19"><a href="#cb6-19"></a>}</span>
<span id="cb6-20"><a href="#cb6-20"></a>queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> h[maxn];</span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb6-22"><a href="#cb6-22"></a>    memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); <span class="cf">while</span>(!q.empty())q.pop(); h[s]=<span class="dv">0</span>; q.push(s);</span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb6-24"><a href="#cb6-24"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb6-25"><a href="#cb6-25"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==-<span class="dv">1</span>)h[es[i].t]=h[x]+<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb6-26"><a href="#cb6-26"></a>    }</span>
<span id="cb6-27"><a href="#cb6-27"></a>    <span class="cf">return</span> h[t]!=-<span class="dv">1</span>;</span>
<span id="cb6-28"><a href="#cb6-28"></a>}</span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> t,<span class="dt">int</span> f){</span>
<span id="cb6-30"><a href="#cb6-30"></a>    <span class="cf">if</span>(x==t)<span class="cf">return</span> f; <span class="dt">int</span> u=<span class="dv">0</span>;</span>
<span id="cb6-31"><a href="#cb6-31"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==h[x]+<span class="dv">1</span>){</span>
<span id="cb6-32"><a href="#cb6-32"></a>        <span class="dt">int</span> w=dfs(es[i].t,t,min(f,es[i].c)); f-=w; u+=w; es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; <span class="cf">if</span>(f==<span class="dv">0</span>)<span class="cf">return</span> u;</span>
<span id="cb6-33"><a href="#cb6-33"></a>    }</span>
<span id="cb6-34"><a href="#cb6-34"></a>    <span class="cf">if</span>(u==<span class="dv">0</span>)h[x]=-<span class="dv">1</span>; <span class="cf">return</span> u;</span>
<span id="cb6-35"><a href="#cb6-35"></a>}</span>
<span id="cb6-36"><a href="#cb6-36"></a><span class="dt">int</span> dinic(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb6-37"><a href="#cb6-37"></a>    <span class="dt">int</span> f=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))f+=dfs(s,t,INF); <span class="cf">return</span> f;</span>
<span id="cb6-38"><a href="#cb6-38"></a>}</span>
<span id="cb6-39"><a href="#cb6-39"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb6-40"><a href="#cb6-40"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb6-41"><a href="#cb6-41"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb6-42"><a href="#cb6-42"></a>    <span class="cf">return</span> x*f;</span>
<span id="cb6-43"><a href="#cb6-43"></a>}</span>
<span id="cb6-44"><a href="#cb6-44"></a><span class="dt">int</span> n,m,s,t;</span>
<span id="cb6-45"><a href="#cb6-45"></a><span class="dt">int</span> main(){</span>
<span id="cb6-46"><a href="#cb6-46"></a>    n=read(); m=read(); s=<span class="dv">0</span>; t=n+<span class="dv">1</span>; init(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(); <span class="cf">if</span>(x)pe(s,i,<span class="dv">1</span>);<span class="cf">else</span> pe(i,t,<span class="dv">1</span>);}</span>
<span id="cb6-47"><a href="#cb6-47"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(); pe2(x,y,<span class="dv">1</span>);} printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dinic(s,t)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-48"><a href="#cb6-48"></a>}</span></code></pre></div>
<h3 id="bzoj1452jsoi2009count2016.6.3">bzoj1452[JSOI2009]Count（2016.6.3）</h3>
<h4 id="题意-6">题意</h4>
<p>n*m矩阵，支持两个操作，修改某个格子权值和查询某个子矩阵特定权值出现次数。n，m≤300，权值为1到100的整数。</p>
<h4 id="题解-6">题解</h4>
<p>原来二维前缀和也可以用树状数组维护，只要那个不断增加/减少lowbit的循环再嵌套一层就行了。同时因为权值是1到100的整数，所以二维前缀和多一维维护特定权值个数就行了。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#define maxn </span><span class="dv">301</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="dt">int</span> sm[maxn][maxn][maxn/<span class="dv">3</span>+<span class="dv">1</span>],col[maxn][maxn],n,m;</span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="dt">void</span> update(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> z,<span class="dt">int</span> v){</span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=x;i&lt;=n;i+=lb(i))<span class="cf">for</span>(<span class="dt">int</span> j=y;j&lt;=m;j+=lb(j))sm[i][j][z]+=v;</span>
<span id="cb7-12"><a href="#cb7-12"></a>}</span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="dt">int</span> query(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> z){</span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="dt">int</span> q=<span class="dv">0</span>; <span class="cf">for</span>(<span class="dt">int</span> i=x;i&gt;=<span class="dv">1</span>;i-=lb(i))<span class="cf">for</span>(<span class="dt">int</span> j=y;j&gt;=<span class="dv">1</span>;j-=lb(j))q+=sm[i][j][z]; <span class="cf">return</span> q;</span>
<span id="cb7-15"><a href="#cb7-15"></a>}</span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb7-17"><a href="#cb7-17"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb7-18"><a href="#cb7-18"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb7-20"><a href="#cb7-20"></a>}</span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="dt">int</span> main(){</span>
<span id="cb7-22"><a href="#cb7-22"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,m){col[i][j]=read(); update(i,j,col[i][j],<span class="dv">1</span>);} <span class="dt">int</span> q=read();</span>
<span id="cb7-23"><a href="#cb7-23"></a>    inc(i,<span class="dv">1</span>,q){</span>
<span id="cb7-24"><a href="#cb7-24"></a>        <span class="dt">int</span> x=read();</span>
<span id="cb7-25"><a href="#cb7-25"></a>        <span class="cf">if</span>(x==<span class="dv">1</span>){</span>
<span id="cb7-26"><a href="#cb7-26"></a>            <span class="dt">int</span> x0=read(),x1=read(),x2=read();</span>
<span id="cb7-27"><a href="#cb7-27"></a>            update(x0,x1,col[x0][x1],-<span class="dv">1</span>); update(x0,x1,x2,<span class="dv">1</span>); col[x0][x1]=x2;</span>
<span id="cb7-28"><a href="#cb7-28"></a>        }</span>
<span id="cb7-29"><a href="#cb7-29"></a>        <span class="cf">if</span>(x==<span class="dv">2</span>){</span>
<span id="cb7-30"><a href="#cb7-30"></a>            <span class="dt">int</span> x1=read(),x2=read(),y1=read(),y2=read(),c=read();</span>
<span id="cb7-31"><a href="#cb7-31"></a>            printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query(x2,y2,c)-query(x1-<span class="dv">1</span>,y2,c)-query(x2,y1-<span class="dv">1</span>,c)+query(x1-<span class="dv">1</span>,y1-<span class="dv">1</span>,c));</span>
<span id="cb7-32"><a href="#cb7-32"></a>        }</span>
<span id="cb7-33"><a href="#cb7-33"></a>    }</span>
<span id="cb7-34"><a href="#cb7-34"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-35"><a href="#cb7-35"></a>}</span></code></pre></div>
<h3 id="bzoj1406ahoi2007密码箱2016.6.3">bzoj1406[AHOI2007]密码箱（2016.6.3）</h3>
<h4 id="题意-7">题意</h4>
<p>输出1到n-1中平方后模n等于1的整数</p>
<h4 id="题解-7">题解</h4>
<p>设所求数x，化简得(x+1)(x-1)=n*k，设n1*n2等于k,(x+1)%n1==0，(x-1)%n2==0，因此n1、n2都为n的因数，且一个≤sqrt(n)，一个≥(sqrt(n))。据说int以内的数的因数都不超过30个，所以可以先求出所有≥sqrt(n)的因数，然后对于每个因数，求出所有＜n的这个因数的倍数，用它尝试被x+1模。因为这些因数都≥sqrt(n)，所以这个枚举的过程不会超时。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="pp">#define maxn </span><span class="dv">100</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="dt">int</span> yss,ys[maxn],st[maxn*<span class="dv">5000</span>],sts;</span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="dt">int</span> main(){</span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="dt">int</span> n; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,(<span class="dt">int</span>)sqrt(n))<span class="cf">if</span>(n%i==<span class="dv">0</span>)ys[++yss]=n/i; st[sts=<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb8-12"><a href="#cb8-12"></a>    inc(i,<span class="dv">1</span>,yss){</span>
<span id="cb8-13"><a href="#cb8-13"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=ys[i];j&lt;=n;j+=ys[i]){</span>
<span id="cb8-14"><a href="#cb8-14"></a>            <span class="cf">if</span>((j-<span class="dv">2</span>)%(n/ys[i])==<span class="dv">0</span>)st[++sts]=j-<span class="dv">1</span>;</span>
<span id="cb8-15"><a href="#cb8-15"></a>            <span class="cf">if</span>(j&lt;n&amp;&amp;(j+<span class="dv">2</span>)%(n/ys[i])==<span class="dv">0</span>)st[++sts]=j+<span class="dv">1</span>;</span>
<span id="cb8-16"><a href="#cb8-16"></a>        }</span>
<span id="cb8-17"><a href="#cb8-17"></a>    }</span>
<span id="cb8-18"><a href="#cb8-18"></a>    <span class="cf">if</span>(sts==<span class="dv">0</span>||n==<span class="dv">1</span>)printf(<span class="st">&quot;None&quot;</span>);<span class="cf">else</span>{</span>
<span id="cb8-19"><a href="#cb8-19"></a>        sort(st+<span class="dv">1</span>,st+<span class="dv">1</span>+sts); <span class="dt">int</span> m=unique(st+<span class="dv">1</span>,st+<span class="dv">1</span>+sts)-st-<span class="dv">1</span>; inc(i,<span class="dv">1</span>,m)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,st[i]);</span>
<span id="cb8-20"><a href="#cb8-20"></a>    }</span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb8-22"><a href="#cb8-22"></a>}</span></code></pre></div>
<h3 id="bzoj1066scoi2007蜥蜴2016.6.8">bzoj1066[SCOI2007]蜥蜴（2016.6.8）</h3>
<h4 id="题意-8">题意</h4>
<p>r行c列网格图上有一些高低不平的柱子，一些柱子上有蜥蜴，一只蜥蜴一次能跳距离为d，每次蜥蜴跳跃时出发柱子高度减一，当柱子高度为0时消失，问最少多少蜥蜴不能跳出网格图。r，c≤20，d≤4</p>
<h4 id="题解-8">题解</h4>
<p>裸最大流，每个柱子拆成X，Y两点，两点之间连柱子的高度，所有Yi向可达柱子的Xi连边，s向所有蜥蜴初始位置连边，所有可以跳出图的柱子向t连边。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="pp">#define maxn </span><span class="dv">1000</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,c,n;}; e es[maxn*<span class="dv">40</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c){</span>
<span id="cb9-12"><a href="#cb9-12"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,g[t]}; g[t]=ess;</span>
<span id="cb9-13"><a href="#cb9-13"></a>}</span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="kw">inline</span> <span class="dt">void</span> init(){</span>
<span id="cb9-15"><a href="#cb9-15"></a>    ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb9-16"><a href="#cb9-16"></a>}</span>
<span id="cb9-17"><a href="#cb9-17"></a>queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> h[maxn];</span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb9-19"><a href="#cb9-19"></a>    memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); <span class="cf">while</span>(!q.empty())q.pop(); h[s]=<span class="dv">0</span>; q.push(s);</span>
<span id="cb9-20"><a href="#cb9-20"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb9-21"><a href="#cb9-21"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb9-22"><a href="#cb9-22"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==-<span class="dv">1</span>)h[es[i].t]=h[x]+<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb9-23"><a href="#cb9-23"></a>    }</span>
<span id="cb9-24"><a href="#cb9-24"></a>    <span class="cf">return</span> h[t]!=-<span class="dv">1</span>;</span>
<span id="cb9-25"><a href="#cb9-25"></a>}</span>
<span id="cb9-26"><a href="#cb9-26"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> t,<span class="dt">int</span> f){</span>
<span id="cb9-27"><a href="#cb9-27"></a>    <span class="cf">if</span>(x==t)<span class="cf">return</span> f; <span class="dt">int</span> u=<span class="dv">0</span>;</span>
<span id="cb9-28"><a href="#cb9-28"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==h[x]+<span class="dv">1</span>){</span>
<span id="cb9-29"><a href="#cb9-29"></a>        <span class="dt">int</span> w=dfs(es[i].t,t,min(f,es[i].c)); f-=w; u+=w; es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; <span class="cf">if</span>(f==<span class="dv">0</span>)<span class="cf">return</span> u;</span>
<span id="cb9-30"><a href="#cb9-30"></a>    }</span>
<span id="cb9-31"><a href="#cb9-31"></a>    <span class="cf">if</span>(u==<span class="dv">0</span>)h[x]=-<span class="dv">1</span>; <span class="cf">return</span> u;</span>
<span id="cb9-32"><a href="#cb9-32"></a>}</span>
<span id="cb9-33"><a href="#cb9-33"></a><span class="dt">int</span> dinic(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb9-34"><a href="#cb9-34"></a>    <span class="dt">int</span> f=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))f+=dfs(s,t,INF); <span class="cf">return</span> f;</span>
<span id="cb9-35"><a href="#cb9-35"></a>}</span>
<span id="cb9-36"><a href="#cb9-36"></a><span class="kw">inline</span> <span class="dt">int</span> dis(<span class="dt">int</span> x1,<span class="dt">int</span> y1,<span class="dt">int</span> x2,<span class="dt">int</span> y2){</span>
<span id="cb9-37"><a href="#cb9-37"></a>    <span class="cf">return</span> (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);</span>
<span id="cb9-38"><a href="#cb9-38"></a>}</span>
<span id="cb9-39"><a href="#cb9-39"></a><span class="dt">int</span> r,c,d,s,t,pos[<span class="dv">30</span>][<span class="dv">30</span>],x[<span class="dv">500</span>],y[<span class="dv">500</span>],he[<span class="dv">500</span>],n,tot; <span class="dt">char</span> str[<span class="dv">30</span>];</span>
<span id="cb9-40"><a href="#cb9-40"></a><span class="dt">int</span> main(){</span>
<span id="cb9-41"><a href="#cb9-41"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;r,&amp;c,&amp;d); n=tot=<span class="dv">0</span>;</span>
<span id="cb9-42"><a href="#cb9-42"></a>    inc(i,<span class="dv">1</span>,r){</span>
<span id="cb9-43"><a href="#cb9-43"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,str);</span>
<span id="cb9-44"><a href="#cb9-44"></a>        inc(j,<span class="dv">0</span>,c-<span class="dv">1</span>)<span class="cf">if</span>(str[j]!=<span class="ch">&#39;0&#39;</span>)</span>
<span id="cb9-45"><a href="#cb9-45"></a>            n++,x[n]=i,y[n]=j+<span class="dv">1</span>,he[n]=str[j]-<span class="ch">&#39;0&#39;</span>,pos[i][j+<span class="dv">1</span>]=n;</span>
<span id="cb9-46"><a href="#cb9-46"></a>    }</span>
<span id="cb9-47"><a href="#cb9-47"></a>    init(); s=<span class="dv">0</span>; t=<span class="dv">2</span>*n+<span class="dv">1</span>;</span>
<span id="cb9-48"><a href="#cb9-48"></a>    inc(i,<span class="dv">1</span>,r){</span>
<span id="cb9-49"><a href="#cb9-49"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,str);</span>
<span id="cb9-50"><a href="#cb9-50"></a>        inc(j,<span class="dv">0</span>,c-<span class="dv">1</span>)<span class="cf">if</span>(str[j]==<span class="ch">&#39;L&#39;</span>)pe(s,pos[i][j+<span class="dv">1</span>],<span class="dv">1</span>),tot++;</span>
<span id="cb9-51"><a href="#cb9-51"></a>    }</span>
<span id="cb9-52"><a href="#cb9-52"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb9-53"><a href="#cb9-53"></a>        pe(i,n+i,he[i]);</span>
<span id="cb9-54"><a href="#cb9-54"></a>        inc(j,<span class="dv">1</span>,n)<span class="cf">if</span>(i!=j&amp;&amp;dis(x[i],y[i],x[j],y[j])&lt;=d*d)pe(n+i,j,INF);</span>
<span id="cb9-55"><a href="#cb9-55"></a>        <span class="cf">if</span>(x[i]&lt;=d||r+<span class="dv">1</span>-x[i]&lt;=d||y[i]&lt;=d||c+<span class="dv">1</span>-y[i]&lt;=d)pe(n+i,t,INF);</span>
<span id="cb9-56"><a href="#cb9-56"></a>    }</span>
<span id="cb9-57"><a href="#cb9-57"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,tot-dinic(s,t)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb9-58"><a href="#cb9-58"></a>}</span></code></pre></div>
<h3 id="bzoj1103poi2007大都市meg2016.6.8">bzoj1103[POI2007]大都市meg（2016.6.8）</h3>
<h4 id="题意-9">题意</h4>
<p>一个n点树，根节点为1，初始时全部边为土路，共n-m+1次操作，每次可将一条边改为公路或求根节点到某个节点要几个多少土路。n，m≤250000</p>
<h4 id="题解-9">题解</h4>
<p>先求出DFS序，进入节点在时间点的权值为1，离开节点在时间点的权值为-1，如果把公路转成土路就将这条边的左端点的进入时间权值和离开时间权值都置为0，如果询问则输出节点进入时间前缀和。求前缀和及修改的操作可以用树状数组维护。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="pp">#define maxn </span><span class="dv">250500</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){</span>
<span id="cb10-12"><a href="#cb10-12"></a>    es[++ess]=(e){t,g[f]}; g[f]=ess;</span>
<span id="cb10-13"><a href="#cb10-13"></a>}</span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="dt">int</span> st[maxn*<span class="dv">2</span>],l[maxn],r[maxn],tim;</span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb10-16"><a href="#cb10-16"></a>    st[++tim]=x; l[x]=tim;</span>
<span id="cb10-17"><a href="#cb10-17"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)dfs(es[i].t);</span>
<span id="cb10-18"><a href="#cb10-18"></a>    st[++tim]=x; r[x]=tim;</span>
<span id="cb10-19"><a href="#cb10-19"></a>}</span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb10-21"><a href="#cb10-21"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb10-23"><a href="#cb10-23"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb10-24"><a href="#cb10-24"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb10-25"><a href="#cb10-25"></a>}</span>
<span id="cb10-26"><a href="#cb10-26"></a><span class="dt">int</span> c[maxn*<span class="dv">2</span>],n;</span>
<span id="cb10-27"><a href="#cb10-27"></a><span class="dt">void</span> update(<span class="dt">int</span> x,<span class="dt">int</span> v){<span class="cf">while</span>(x&lt;=n*<span class="dv">2</span>)c[x]+=v,x+=lb(x);}</span>
<span id="cb10-28"><a href="#cb10-28"></a><span class="dt">int</span> query(<span class="dt">int</span> x){<span class="dt">int</span> q=<span class="dv">0</span>; <span class="cf">while</span>(x)q+=c[x],x-=lb(x); <span class="cf">return</span> q;}</span>
<span id="cb10-29"><a href="#cb10-29"></a><span class="dt">int</span> main(){</span>
<span id="cb10-30"><a href="#cb10-30"></a>    n=read(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a=read(),b=read(); pe(a,b);}</span>
<span id="cb10-31"><a href="#cb10-31"></a>    dfs(<span class="dv">1</span>); inc(i,<span class="dv">1</span>,n)update(l[i],<span class="dv">1</span>),update(r[i],-<span class="dv">1</span>);</span>
<span id="cb10-32"><a href="#cb10-32"></a>    <span class="dt">int</span> m=read(); <span class="dt">char</span> opt[<span class="dv">3</span>];</span>
<span id="cb10-33"><a href="#cb10-33"></a>    inc(i,<span class="dv">1</span>,n+m-<span class="dv">1</span>){</span>
<span id="cb10-34"><a href="#cb10-34"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,opt);</span>
<span id="cb10-35"><a href="#cb10-35"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;W&#39;</span>){<span class="dt">int</span> a=read(); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query(l[a])-<span class="dv">1</span>);}</span>
<span id="cb10-36"><a href="#cb10-36"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;A&#39;</span>){<span class="dt">int</span> a=read(),b=read(); update(l[b],-<span class="dv">1</span>); update(r[b],<span class="dv">1</span>);}</span>
<span id="cb10-37"><a href="#cb10-37"></a>    }</span>
<span id="cb10-38"><a href="#cb10-38"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-39"><a href="#cb10-39"></a>}</span></code></pre></div>
<h3 id="bzoj2733hnoi2012永无乡2016.8.60">bzoj2733[HNOI2012]永无乡（2016.8.60）</h3>
<h4 id="题意-10">题意</h4>
<p>n个节点，每个节点有个权值，初始时有m次连通两点的操作，接下来有q次操作，每次可以连通两个点或求某个点所在连通块权值第k小的节点编号。n，m≤100000，q≤300000</p>
<h4 id="题解-10">题解</h4>
<p>treap启发式合并，就是暴力将小的树拆了插到大的树里，均摊复杂度O(log^2n)。由于本弱用的是treap，不能维护fa数组，所以要并查集维护根节点。如果是splay就不用。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="pp">#define maxn </span><span class="dv">100500</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="dt">int</span> fa[maxn],rt[maxn],ch[maxn][<span class="dv">2</span>],v[maxn],sz[maxn],rnd[maxn];</span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb11-12"><a href="#cb11-12"></a>    sz[x]=sz[ch[x][<span class="dv">0</span>]]+sz[ch[x][<span class="dv">1</span>]]+<span class="dv">1</span>;</span>
<span id="cb11-13"><a href="#cb11-13"></a>}</span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="dt">void</span> rot(<span class="dt">int</span> &amp;x,<span class="dt">bool</span> lr){</span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span>; <span class="dt">int</span> a=ch[x][lr]; ch[x][lr]=ch[a][!lr]; ch[a][!lr]=x;</span>
<span id="cb11-16"><a href="#cb11-16"></a>    update(x); update(a); x=a;</span>
<span id="cb11-17"><a href="#cb11-17"></a>}</span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;x,<span class="dt">int</span> y){</span>
<span id="cb11-19"><a href="#cb11-19"></a>    <span class="cf">if</span>(!x){x=y; <span class="cf">return</span>;}</span>
<span id="cb11-20"><a href="#cb11-20"></a>    <span class="cf">if</span>(v[y]&lt;v[x])insert(ch[x][<span class="dv">0</span>],y);<span class="cf">else</span> insert(ch[x][<span class="dv">1</span>],y); update(x);</span>
<span id="cb11-21"><a href="#cb11-21"></a>    <span class="cf">if</span>(ch[x][<span class="dv">0</span>]&amp;&amp;rnd[ch[x][<span class="dv">0</span>]]&lt;rnd[x])rot(x,<span class="dv">0</span>);</span>
<span id="cb11-22"><a href="#cb11-22"></a>    <span class="cf">if</span>(ch[x][<span class="dv">1</span>]&amp;&amp;rnd[ch[x][<span class="dv">1</span>]]&lt;rnd[x])rot(x,<span class="dv">1</span>);</span>
<span id="cb11-23"><a href="#cb11-23"></a>}</span>
<span id="cb11-24"><a href="#cb11-24"></a><span class="dt">int</span> find(<span class="dt">int</span> x,<span class="dt">int</span> k){</span>
<span id="cb11-25"><a href="#cb11-25"></a>    <span class="cf">if</span>(sz[x]&lt;k)<span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb11-26"><a href="#cb11-26"></a>    <span class="cf">if</span>(sz[ch[x][<span class="dv">0</span>]]==k-<span class="dv">1</span>)<span class="cf">return</span> x;</span>
<span id="cb11-27"><a href="#cb11-27"></a>    <span class="cf">if</span>(sz[ch[x][<span class="dv">0</span>]]&lt;k-<span class="dv">1</span>)<span class="cf">return</span> find(ch[x][<span class="dv">1</span>],k-sz[ch[x][<span class="dv">0</span>]]-<span class="dv">1</span>);</span>
<span id="cb11-28"><a href="#cb11-28"></a>    <span class="cf">if</span>(sz[ch[x][<span class="dv">0</span>]]&gt;k-<span class="dv">1</span>)<span class="cf">return</span> find(ch[x][<span class="dv">0</span>],k);</span>
<span id="cb11-29"><a href="#cb11-29"></a>}</span>
<span id="cb11-30"><a href="#cb11-30"></a>queue &lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb11-31"><a href="#cb11-31"></a><span class="dt">int</span> fd(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=fd(fa[x]);}</span>
<span id="cb11-32"><a href="#cb11-32"></a><span class="dt">void</span> merge(<span class="dt">int</span> xx,<span class="dt">int</span> yy){</span>
<span id="cb11-33"><a href="#cb11-33"></a>    <span class="dt">int</span> x=fd(xx),y=fd(yy); <span class="cf">if</span>(x==y)<span class="cf">return</span>; <span class="cf">if</span>(sz[rt[x]]&gt;sz[rt[y]])swap(x,y);</span>
<span id="cb11-34"><a href="#cb11-34"></a>    fa[x]=y; <span class="cf">while</span>(! q.empty())q.pop(); q.push(rt[x]); y=rt[y];</span>
<span id="cb11-35"><a href="#cb11-35"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb11-36"><a href="#cb11-36"></a>        <span class="dt">int</span> z=q.front(); q.pop(); sz[z]=<span class="dv">1</span>;</span>
<span id="cb11-37"><a href="#cb11-37"></a>        <span class="cf">if</span>(ch[z][<span class="dv">0</span>])q.push(ch[z][<span class="dv">0</span>]); <span class="cf">if</span>(ch[z][<span class="dv">1</span>])q.push(ch[z][<span class="dv">1</span>]);</span>
<span id="cb11-38"><a href="#cb11-38"></a>        ch[z][<span class="dv">0</span>]=ch[z][<span class="dv">1</span>]=<span class="dv">0</span>; insert(y,z);</span>
<span id="cb11-39"><a href="#cb11-39"></a>    }</span>
<span id="cb11-40"><a href="#cb11-40"></a>    rt[fa[x]]=y;</span>
<span id="cb11-41"><a href="#cb11-41"></a>}</span>
<span id="cb11-42"><a href="#cb11-42"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb11-43"><a href="#cb11-43"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb11-44"><a href="#cb11-44"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb11-45"><a href="#cb11-45"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb11-46"><a href="#cb11-46"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb11-47"><a href="#cb11-47"></a>}</span>
<span id="cb11-48"><a href="#cb11-48"></a><span class="dt">int</span> n,m;</span>
<span id="cb11-49"><a href="#cb11-49"></a><span class="dt">int</span> main(){</span>
<span id="cb11-50"><a href="#cb11-50"></a>    n=read(); m=read();</span>
<span id="cb11-51"><a href="#cb11-51"></a>    inc(i,<span class="dv">1</span>,n)</span>
<span id="cb11-52"><a href="#cb11-52"></a>        v[i]=read(),ch[i][<span class="dv">0</span>]=ch[i][<span class="dv">1</span>]=<span class="dv">0</span>,rnd[i]=rand(),fa[i]=rt[i]=i,sz[i]=<span class="dv">1</span>;</span>
<span id="cb11-53"><a href="#cb11-53"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(); merge(a,b);}</span>
<span id="cb11-54"><a href="#cb11-54"></a>    m=read(); <span class="dt">char</span> opt[<span class="dv">3</span>];</span>
<span id="cb11-55"><a href="#cb11-55"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb11-56"><a href="#cb11-56"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,opt);</span>
<span id="cb11-57"><a href="#cb11-57"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>){</span>
<span id="cb11-58"><a href="#cb11-58"></a>            <span class="dt">int</span> a=read(),b=read(); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,find(rt[fd(a)],b));</span>
<span id="cb11-59"><a href="#cb11-59"></a>        }</span>
<span id="cb11-60"><a href="#cb11-60"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;B&#39;</span>){</span>
<span id="cb11-61"><a href="#cb11-61"></a>            <span class="dt">int</span> a=read(),b=read(); merge(a,b);</span>
<span id="cb11-62"><a href="#cb11-62"></a>        }</span>
<span id="cb11-63"><a href="#cb11-63"></a>    }</span>
<span id="cb11-64"><a href="#cb11-64"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-65"><a href="#cb11-65"></a>}</span></code></pre></div>
<h3 id="bzoj4195noi2015程序自动分析2016.6.8">bzoj4195[Noi2015]程序自动分析（2016.6.8）</h3>
<h4 id="题意-11">题意</h4>
<p>t组数据，每组n个给出两个变量是相等还是不等的约束条件，要求判断是否能满足。n≤1000000，变量数量≤10^9</p>
<h4 id="题解-11">题解</h4>
<p>先离散化，然后只处理相等条件用并查集维护“相等集合”，接着对每个不相等条件判断是否在一个集合，是的话则说明不满足。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="pp">#define maxn </span><span class="dv">1000100</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb12-11"><a href="#cb12-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb12-12"><a href="#cb12-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb12-14"><a href="#cb12-14"></a>}</span>
<span id="cb12-15"><a href="#cb12-15"></a><span class="dt">int</span> t,n;</span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="kw">struct</span> opt{<span class="dt">int</span> a,b; <span class="dt">bool</span> c;}; opt opts[maxn];</span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="kw">struct</span> ls{<span class="dt">int</span> a,c; <span class="dt">bool</span> b;}; ls lss[maxn*<span class="dv">2</span>]; <span class="dt">int</span> lsss,tot,fa[maxn*<span class="dv">2</span>];</span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="dt">bool</span> cmp(ls a,ls b){<span class="cf">return</span> a.a&lt;b.a;}</span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb12-20"><a href="#cb12-20"></a><span class="dt">int</span> main(){</span>
<span id="cb12-21"><a href="#cb12-21"></a>    t=read(); <span class="cf">while</span>(t--){</span>
<span id="cb12-22"><a href="#cb12-22"></a>        n=read(); lsss=<span class="dv">0</span>;</span>
<span id="cb12-23"><a href="#cb12-23"></a>        inc(i,<span class="dv">1</span>,n){</span>
<span id="cb12-24"><a href="#cb12-24"></a>            <span class="dt">int</span> a=read(),b=read(); opts[i].c=read();</span>
<span id="cb12-25"><a href="#cb12-25"></a>            lss[++lsss]=(ls){a,i,<span class="dv">0</span>}; lss[++lsss]=(ls){b,i,<span class="dv">1</span>};</span>
<span id="cb12-26"><a href="#cb12-26"></a>        }</span>
<span id="cb12-27"><a href="#cb12-27"></a>        sort(lss+<span class="dv">1</span>,lss+lsss+<span class="dv">1</span>,cmp); tot=<span class="dv">0</span>;</span>
<span id="cb12-28"><a href="#cb12-28"></a>        inc(i,<span class="dv">1</span>,lsss){</span>
<span id="cb12-29"><a href="#cb12-29"></a>            <span class="cf">if</span>(i==<span class="dv">1</span>||lss[i].a!=lss[i-<span class="dv">1</span>].a)tot++;</span>
<span id="cb12-30"><a href="#cb12-30"></a>            <span class="cf">if</span>(!lss[i].b)opts[lss[i].c].a=tot;<span class="cf">else</span> opts[lss[i].c].b=tot;</span>
<span id="cb12-31"><a href="#cb12-31"></a>        }</span>
<span id="cb12-32"><a href="#cb12-32"></a>        inc(i,<span class="dv">1</span>,tot)fa[i]=i;</span>
<span id="cb12-33"><a href="#cb12-33"></a>        inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(opts[i].c){</span>
<span id="cb12-34"><a href="#cb12-34"></a>            <span class="dt">int</span> x=find(opts[i].a),y=find(opts[i].b); <span class="cf">if</span>(x!=y)fa[x]=y;</span>
<span id="cb12-35"><a href="#cb12-35"></a>        }</span>
<span id="cb12-36"><a href="#cb12-36"></a>        <span class="dt">bool</span> f=<span class="dv">0</span>;</span>
<span id="cb12-37"><a href="#cb12-37"></a>        inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!opts[i].c){</span>
<span id="cb12-38"><a href="#cb12-38"></a>            <span class="dt">int</span> x=find(opts[i].a),y=find(opts[i].b); <span class="cf">if</span>(x==y){f=<span class="dv">1</span>; <span class="cf">break</span>;}</span>
<span id="cb12-39"><a href="#cb12-39"></a>        }</span>
<span id="cb12-40"><a href="#cb12-40"></a>        <span class="cf">if</span>(f)puts(<span class="st">&quot;NO&quot;</span>);<span class="cf">else</span> puts(<span class="st">&quot;YES&quot;</span>);</span>
<span id="cb12-41"><a href="#cb12-41"></a>    }</span>
<span id="cb12-42"><a href="#cb12-42"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb12-43"><a href="#cb12-43"></a>}</span></code></pre></div>
<h3 id="bzoj3620似乎在梦中见过的样子2016.6.9">bzoj3620似乎在梦中见过的样子（2016.6.9）</h3>
<h4 id="题意-12">题意</h4>
<p>给出一个字符串，要求求出形如A+B+A的子串数量，且lenA≥k，lenB≥1。字符串长度≤15000，k≤100，所以字符长度为小写字母。</p>
<h4 id="题解-12">题解</h4>
<p>第一次写kmp的题QAQ~这题利用的是fail函数的性质：若字符串s在位置x的fail函数f[x]不为0，则prefix(s+1,s+x)的长度为f[x]的前缀和长度为f[x]的后缀相同。因此枚举每个后缀为为j，对这个后缀做kmp，再递推一个令f[i]-j+1≥k且最小的f[i]为last[x]（f[i]表示i=x; while(i&gt;=后缀位)i=f[i]得到的所有f[i]），若last[x]-j小于等于(x-j)/2则子串(j,x)合法。讲的很乱，具体看代码。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="dt">char</span> s[<span class="dv">15100</span>]; <span class="dt">int</span> l,k,next[<span class="dv">15100</span>],last[<span class="dv">15100</span>],ans;</span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="dt">int</span> main(){</span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="co">//freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>); l=strlen(s+<span class="dv">1</span>); scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;k); ans=<span class="dv">0</span>;</span>
<span id="cb13-13"><a href="#cb13-13"></a>    inc(i,<span class="dv">1</span>,l){</span>
<span id="cb13-14"><a href="#cb13-14"></a>        next[i]=i-<span class="dv">1</span>; last[i]=INF;</span>
<span id="cb13-15"><a href="#cb13-15"></a>        inc(ii,i+<span class="dv">1</span>,l){</span>
<span id="cb13-16"><a href="#cb13-16"></a>            <span class="dt">int</span> j=next[ii-<span class="dv">1</span>]; <span class="cf">while</span>(j&gt;=i&amp;&amp;s[ii]!=s[j+<span class="dv">1</span>])j=next[j];</span>
<span id="cb13-17"><a href="#cb13-17"></a>            <span class="cf">if</span>(s[ii]==s[j+<span class="dv">1</span>])next[ii]=j+<span class="dv">1</span>;<span class="cf">else</span> next[ii]=j;</span>
<span id="cb13-18"><a href="#cb13-18"></a>            <span class="cf">if</span>(next[ii]-i+<span class="dv">1</span>&lt;k)last[ii]=INF;<span class="cf">else</span>{</span>
<span id="cb13-19"><a href="#cb13-19"></a>                last[ii]=min(last[next[ii]],next[ii]);</span>
<span id="cb13-20"><a href="#cb13-20"></a>                <span class="cf">if</span>(last[ii]-i+<span class="dv">1</span>&lt;=(ii-i)&gt;&gt;<span class="dv">1</span>)ans++;<span class="co">//,printf(&quot;%d %d\n&quot;,i,ii);</span></span>
<span id="cb13-21"><a href="#cb13-21"></a>            }</span>
<span id="cb13-22"><a href="#cb13-22"></a>        }</span>
<span id="cb13-23"><a href="#cb13-23"></a>    }</span>
<span id="cb13-24"><a href="#cb13-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-25"><a href="#cb13-25"></a>}</span></code></pre></div>
<h3 id="bzoj3621我想那还真是令人高兴啊2016.6.9">bzoj3621我想那还真是令人高兴啊（2016.6.9）</h3>
<h4 id="题意-13">题意</h4>
<p>T组数据，每组给出两个三角形各点坐标，要求求出一个点使第一个三角形可以绕这个点放缩和旋转得到另一个三角形。T≤10，坐标为≤10000的实数，数据保证三角形不用平移，答案保留三位小数。</p>
<h4 id="题解-13">题解</h4>
<p>复数既是一种数，又可以当做一种独特的二维向量，因为其数的特点可以用来解方程，又因为其向量的特点可以表示二维的点和变换。两个复数的积在几何上定义为把它转化为向量后极角相加，长度相乘，正可以用来表示放缩和旋转变换。因此设A，B，C为变换前三角形三个顶点（用复数表示），T为变换复数，P为绕的那个点，A’，B’，C’表示变换后的点。于是可以列方程(A-P)*T=(A’-P) (B-P)*T=(B’-P) (C-P)*T=(C’-P)，我们可以枚举A，B，C分别是第一个三角形的哪个顶点，然后联立前两道解出T代入第三道验证。然而本傻逼忘记枚举了导致WA了好几发，顺便安利STL的complex类，已经包装好了复数的常用运算。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="pp">#include </span><span class="im">&lt;complex&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a>complex &lt;<span class="dt">double</span>&gt; a,b,c,d,e,f,t,p,g;</span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="dt">int</span> T;</span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="dt">int</span> main(){</span>
<span id="cb14-12"><a href="#cb14-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;T); <span class="cf">while</span>(T--){</span>
<span id="cb14-13"><a href="#cb14-13"></a>        <span class="dt">double</span> x,y;</span>
<span id="cb14-14"><a href="#cb14-14"></a>        scanf(<span class="st">&quot;</span><span class="sc">%lf%lf</span><span class="st">&quot;</span>,&amp;x,&amp;y); a.real(x); a.imag(y);</span>
<span id="cb14-15"><a href="#cb14-15"></a>        scanf(<span class="st">&quot;</span><span class="sc">%lf%lf</span><span class="st">&quot;</span>,&amp;x,&amp;y); b.real(x); b.imag(y);</span>
<span id="cb14-16"><a href="#cb14-16"></a>        scanf(<span class="st">&quot;</span><span class="sc">%lf%lf</span><span class="st">&quot;</span>,&amp;x,&amp;y); c.real(x); c.imag(y);</span>
<span id="cb14-17"><a href="#cb14-17"></a>        scanf(<span class="st">&quot;</span><span class="sc">%lf%lf</span><span class="st">&quot;</span>,&amp;x,&amp;y); d.real(x); d.imag(y);</span>
<span id="cb14-18"><a href="#cb14-18"></a>        scanf(<span class="st">&quot;</span><span class="sc">%lf%lf</span><span class="st">&quot;</span>,&amp;x,&amp;y); e.real(x); e.imag(y);</span>
<span id="cb14-19"><a href="#cb14-19"></a>        scanf(<span class="st">&quot;</span><span class="sc">%lf%lf</span><span class="st">&quot;</span>,&amp;x,&amp;y); f.real(x); f.imag(y);</span>
<span id="cb14-20"><a href="#cb14-20"></a>        g.real(<span class="fl">1.000000</span>),g.imag(<span class="fl">0.000000</span>); t=(e-d)/(b-a); p=(a*t-d)/(t-g);</span>
<span id="cb14-21"><a href="#cb14-21"></a>        <span class="cf">if</span>(abs(((c-p)*t-(f-p)).real())&lt;<span class="fl">1e-4</span>&amp;&amp;abs(((c-p)*t-(f-p)).imag())&lt;<span class="fl">1e-4</span>){</span>
<span id="cb14-22"><a href="#cb14-22"></a>            printf(<span class="st">&quot;%.6lf %.6lf</span><span class="sc">\n</span><span class="st">&quot;</span>,p.real(),p.imag()); <span class="cf">continue</span>;</span>
<span id="cb14-23"><a href="#cb14-23"></a>        }</span>
<span id="cb14-24"><a href="#cb14-24"></a>        swap(b,c); t=(e-d)/(b-a); p=(a*t-d)/(t-g);</span>
<span id="cb14-25"><a href="#cb14-25"></a>        <span class="cf">if</span>(abs(((c-p)*t-(f-p)).real())&lt;<span class="fl">1e-4</span>&amp;&amp;abs(((c-p)*t-(f-p)).imag())&lt;<span class="fl">1e-4</span>){</span>
<span id="cb14-26"><a href="#cb14-26"></a>            printf(<span class="st">&quot;%.6lf %.6lf</span><span class="sc">\n</span><span class="st">&quot;</span>,p.real(),p.imag()); <span class="cf">continue</span>;</span>
<span id="cb14-27"><a href="#cb14-27"></a>        }</span>
<span id="cb14-28"><a href="#cb14-28"></a>        swap(a,b); t=(e-d)/(b-a); p=(a*t-d)/(t-g);</span>
<span id="cb14-29"><a href="#cb14-29"></a>        <span class="cf">if</span>(abs(((c-p)*t-(f-p)).real())&lt;<span class="fl">1e-4</span>&amp;&amp;abs(((c-p)*t-(f-p)).imag())&lt;<span class="fl">1e-4</span>){</span>
<span id="cb14-30"><a href="#cb14-30"></a>            printf(<span class="st">&quot;%.6lf %.6lf</span><span class="sc">\n</span><span class="st">&quot;</span>,p.real(),p.imag()); <span class="cf">continue</span>;</span>
<span id="cb14-31"><a href="#cb14-31"></a>        }</span>
<span id="cb14-32"><a href="#cb14-32"></a>        swap(b,c); t=(e-d)/(b-a); p=(a*t-d)/(t-g);</span>
<span id="cb14-33"><a href="#cb14-33"></a>        <span class="cf">if</span>(abs(((c-p)*t-(f-p)).real())&lt;<span class="fl">1e-4</span>&amp;&amp;abs(((c-p)*t-(f-p)).imag())&lt;<span class="fl">1e-4</span>){</span>
<span id="cb14-34"><a href="#cb14-34"></a>            printf(<span class="st">&quot;%.6lf %.6lf</span><span class="sc">\n</span><span class="st">&quot;</span>,p.real(),p.imag()); <span class="cf">continue</span>;</span>
<span id="cb14-35"><a href="#cb14-35"></a>        }</span>
<span id="cb14-36"><a href="#cb14-36"></a>        swap(a,b); t=(e-d)/(b-a); p=(a*t-d)/(t-g);</span>
<span id="cb14-37"><a href="#cb14-37"></a>        <span class="cf">if</span>(abs(((c-p)*t-(f-p)).real())&lt;<span class="fl">1e-4</span>&amp;&amp;abs(((c-p)*t-(f-p)).imag())&lt;<span class="fl">1e-4</span>){</span>
<span id="cb14-38"><a href="#cb14-38"></a>            printf(<span class="st">&quot;%.6lf %.6lf</span><span class="sc">\n</span><span class="st">&quot;</span>,p.real(),p.imag()); <span class="cf">continue</span>;</span>
<span id="cb14-39"><a href="#cb14-39"></a>        }</span>
<span id="cb14-40"><a href="#cb14-40"></a>        swap(b,c); t=(e-d)/(b-a); p=(a*t-d)/(t-g);</span>
<span id="cb14-41"><a href="#cb14-41"></a>        <span class="cf">if</span>(abs(((c-p)*t-(f-p)).real())&lt;<span class="fl">1e-4</span>&amp;&amp;abs(((c-p)*t-(f-p)).imag())&lt;<span class="fl">1e-4</span>){</span>
<span id="cb14-42"><a href="#cb14-42"></a>            printf(<span class="st">&quot;%.6lf %.6lf</span><span class="sc">\n</span><span class="st">&quot;</span>,p.real(),p.imag()); <span class="cf">continue</span>;</span>
<span id="cb14-43"><a href="#cb14-43"></a>        }</span>
<span id="cb14-44"><a href="#cb14-44"></a>    }</span>
<span id="cb14-45"><a href="#cb14-45"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-46"><a href="#cb14-46"></a>}</span></code></pre></div>
<h3 id="bzoj3631jloi2014松鼠的新家2016.6.10">bzoj3631[JLOI2014]松鼠的新家（2016.6.10）</h3>
<h4 id="题意-14">题意</h4>
<p>给个n点树，再给个节点的游览顺序，每经过一个节点（包括上一个游览的点到下一个游览的点路径上的点）就可以从这个节点拿走一个糖，问所有节点一开始要放几个糖。最后到达的节点不用糖。n≤300000</p>
<h4 id="题解-14">题解</h4>
<p>链剖将树链排成一列，然后用数组区间加的方式（即在数组区间左端点位置增加值，数组区间右端点+1位置增加这个值的相反数，最后扫一遍a[i]+=a[i-1]）累计糖果数。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="pp">#define maxn </span><span class="dv">300100</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb15-7"><a href="#cb15-7"></a></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb15-11"><a href="#cb15-11"></a>    <span class="cf">return</span> x*f;</span>
<span id="cb15-12"><a href="#cb15-12"></a>}</span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb15-14"><a href="#cb15-14"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){</span>
<span id="cb15-15"><a href="#cb15-15"></a>    es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;</span>
<span id="cb15-16"><a href="#cb15-16"></a>}</span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="dt">void</span> init(){ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb15-18"><a href="#cb15-18"></a><span class="dt">int</span> n,fa[maxn],dep[maxn],go[maxn],pos[maxn],top[maxn],sz[maxn],sm[maxn],tot;</span>
<span id="cb15-19"><a href="#cb15-19"></a><span class="dt">void</span> dfs1(<span class="dt">int</span> x,<span class="dt">int</span> f){</span>
<span id="cb15-20"><a href="#cb15-20"></a>    sz[x]=<span class="dv">1</span>;</span>
<span id="cb15-21"><a href="#cb15-21"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f){</span>
<span id="cb15-22"><a href="#cb15-22"></a>        dep[es[i].t]=dep[x]+<span class="dv">1</span>; fa[es[i].t]=x;</span>
<span id="cb15-23"><a href="#cb15-23"></a>        dfs1(es[i].t,x); sz[x]+=sz[es[i].t];</span>
<span id="cb15-24"><a href="#cb15-24"></a>    }</span>
<span id="cb15-25"><a href="#cb15-25"></a>}</span>
<span id="cb15-26"><a href="#cb15-26"></a><span class="dt">void</span> dfs2(<span class="dt">int</span> x,<span class="dt">int</span> f,<span class="dt">int</span> tp){</span>
<span id="cb15-27"><a href="#cb15-27"></a>    pos[x]=++tot; top[x]=tp; <span class="dt">int</span> mx=<span class="dv">0</span>;</span>
<span id="cb15-28"><a href="#cb15-28"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f){</span>
<span id="cb15-29"><a href="#cb15-29"></a>        <span class="cf">if</span>(!mx||sz[mx]&lt;sz[es[i].t])mx=es[i].t;</span>
<span id="cb15-30"><a href="#cb15-30"></a>    }</span>
<span id="cb15-31"><a href="#cb15-31"></a>    <span class="cf">if</span>(!mx)<span class="cf">return</span>; dfs2(mx,x,tp);</span>
<span id="cb15-32"><a href="#cb15-32"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f&amp;&amp;es[i].t!=mx){</span>
<span id="cb15-33"><a href="#cb15-33"></a>        dfs2(es[i].t,x,es[i].t);</span>
<span id="cb15-34"><a href="#cb15-34"></a>    }</span>
<span id="cb15-35"><a href="#cb15-35"></a>}</span>
<span id="cb15-36"><a href="#cb15-36"></a><span class="dt">void</span> lca(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb15-37"><a href="#cb15-37"></a>    <span class="cf">for</span>(;top[x]!=top[y];sm[pos[top[x]]]++,sm[pos[x]+<span class="dv">1</span>]--,x=fa[top[x]])</span>
<span id="cb15-38"><a href="#cb15-38"></a>        <span class="cf">if</span>(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span>
<span id="cb15-39"><a href="#cb15-39"></a>    <span class="cf">if</span>(dep[x]&gt;dep[y])swap(x,y); sm[pos[x]]++,sm[pos[y]+<span class="dv">1</span>]--;</span>
<span id="cb15-40"><a href="#cb15-40"></a>}</span>
<span id="cb15-41"><a href="#cb15-41"></a><span class="dt">int</span> main(){</span>
<span id="cb15-42"><a href="#cb15-42"></a>    n=read(); inc(i,<span class="dv">1</span>,n)go[i]=read(); init();</span>
<span id="cb15-43"><a href="#cb15-43"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a=read(),b=read(); pe(a,b);}</span>
<span id="cb15-44"><a href="#cb15-44"></a>    dep[<span class="dv">1</span>]=<span class="dv">0</span>; fa[<span class="dv">1</span>]=<span class="dv">0</span>; tot=<span class="dv">0</span>; dfs1(<span class="dv">1</span>,<span class="dv">0</span>); dfs2(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>);</span>
<span id="cb15-45"><a href="#cb15-45"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb15-46"><a href="#cb15-46"></a>        <span class="cf">if</span>(i==<span class="dv">1</span>){sm[pos[go[i]]]++; sm[pos[go[i]]+<span class="dv">1</span>]--; <span class="cf">continue</span>;}</span>
<span id="cb15-47"><a href="#cb15-47"></a>        sm[pos[go[i-<span class="dv">1</span>]]]--; sm[pos[go[i-<span class="dv">1</span>]]+<span class="dv">1</span>]++; lca(go[i-<span class="dv">1</span>],go[i]);</span>
<span id="cb15-48"><a href="#cb15-48"></a>        <span class="cf">if</span>(i==n){sm[pos[go[i]]]--; sm[pos[go[i]]+<span class="dv">1</span>]++;}</span>
<span id="cb15-49"><a href="#cb15-49"></a>    }</span>
<span id="cb15-50"><a href="#cb15-50"></a>    inc(i,<span class="dv">1</span>,tot)sm[i]+=sm[i-<span class="dv">1</span>]; inc(i,<span class="dv">1</span>,n)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,sm[pos[i]]);</span>
<span id="cb15-51"><a href="#cb15-51"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-52"><a href="#cb15-52"></a>}</span></code></pre></div>
<h3 id="bzoj3622已经没有什么好害怕的了2016.6.10">bzoj3622已经没有什么好害怕的了（2016.6.10）</h3>
<h4 id="题意-15">题意</h4>
<p>给n个数Ai，n个数Bi，将Ai中的数与Bi中的数配对，求配对Ai比Bi大的比Bi比Ai大的恰好有k组的方案数。n，k≤2000</p>
<h4 id="题解-15">题解</h4>
<p>蒟蒻太弱了只能引用神犇题解</p>
<blockquote>
<p>我们将两个读入的数组排序,令 next[i] 表示最大的 j 满足 A[i]&gt;B[j],令f[i][j]表示枚举到第i个A时，有j组A&gt;B，但剩下的情况是不考虑的，则f[i][j]=f[i-1][j]+f[i-1][j-1]*(next[i]-j+1)。但若把 f[n][s] 直接输出会WA因为会有这种情况出现: a1，a2，a3 b1，b2，b3 a1&gt;b1  a2&gt;b2  a3&gt;b3 那么((a1，b1)，(a2，b2)，a3不明)和((a1，b1)，(a3，b3)，a2不明)就会被视为两种答案，可见我们要求出的是 f’[n][s] 表示n个A，有s组A&gt;B，剩下的都是B&gt;A 这里就要用容斥了</p>
</blockquote>
<p><span class="math display">\[
f&#39;[n][i]=f[n][i]\times(n-i)!-\sum_{j=i+1}^n{f&#39;[n][j]*C[j][i]}
\]</span></p>
<blockquote>
<p>(n-i)!是枚举后面 n-i 可能的方案，f‘[n][j]*C(j, i) 表示 f[n][i] 中实际有 j 组B&gt;A却被计入f[n][i]的数量 f’[n][s]就是答案了，总时间复杂度为 O(n^2)</p>
</blockquote>
<p>C(j,i)要递推，不然要溢出。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="pp">#define maxn </span><span class="dv">2100</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="pp">#define mod </span><span class="dv">1000000009</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="dt">int</span> s[maxn],p[maxn],next[maxn],n,k; ll f1[maxn][maxn],f2[maxn],C[maxn][maxn],P[maxn];</span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb16-13"><a href="#cb16-13"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb16-15"><a href="#cb16-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb16-16"><a href="#cb16-16"></a>}</span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="dt">int</span> main(){</span>
<span id="cb16-18"><a href="#cb16-18"></a>    n=read(); k=read(); <span class="cf">if</span>((n-k)&amp;<span class="dv">1</span>){printf(<span class="st">&quot;0&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;} k=((n-k)&gt;&gt;<span class="dv">1</span>)+k;</span>
<span id="cb16-19"><a href="#cb16-19"></a>    inc(i,<span class="dv">1</span>,n)s[i]=read(); inc(i,<span class="dv">1</span>,n)p[i]=read(); sort(s+<span class="dv">1</span>,s+n+<span class="dv">1</span>); sort(p+<span class="dv">1</span>,p+n+<span class="dv">1</span>);</span>
<span id="cb16-20"><a href="#cb16-20"></a>    <span class="dt">int</span> l=<span class="dv">1</span>; inc(i,<span class="dv">1</span>,n){<span class="cf">while</span>(p[l]&lt;s[i]&amp;&amp;l&lt;=n)l++; next[i]=l-<span class="dv">1</span>;}</span>
<span id="cb16-21"><a href="#cb16-21"></a>    f1[<span class="dv">0</span>][<span class="dv">0</span>]=<span class="dv">1</span>; inc(i,<span class="dv">1</span>,n){f1[i][<span class="dv">0</span>]=<span class="dv">1</span>; inc(j,<span class="dv">1</span>,n)f1[i][j]=(f1[i-<span class="dv">1</span>][j]+f1[i-<span class="dv">1</span>][j-<span class="dv">1</span>]*(ll)max(next[i]-j+<span class="dv">1</span>,<span class="dv">0</span>)%mod)%mod;}</span>
<span id="cb16-22"><a href="#cb16-22"></a>    P[<span class="dv">0</span>]=<span class="dv">1</span>; inc(i,<span class="dv">1</span>,n)P[i]=P[i-<span class="dv">1</span>]*(ll)i%mod;</span>
<span id="cb16-23"><a href="#cb16-23"></a>    inc(i,<span class="dv">0</span>,n){C[i][<span class="dv">0</span>]=<span class="dv">1</span>; inc(j,<span class="dv">1</span>,i)C[i][j]=(C[i-<span class="dv">1</span>][j]+C[i-<span class="dv">1</span>][j-<span class="dv">1</span>])%mod;}</span>
<span id="cb16-24"><a href="#cb16-24"></a>    dec(i,n,k){</span>
<span id="cb16-25"><a href="#cb16-25"></a>        f2[i]=<span class="dv">0</span>; inc(j,i+<span class="dv">1</span>,n)f2[i]=(f2[i]+f2[j]*C[j][i]%mod)%mod;</span>
<span id="cb16-26"><a href="#cb16-26"></a>        f2[i]=f1[n][i]*P[n-i]%mod-f2[i]; <span class="cf">if</span>(f2[i]&lt;<span class="dv">0</span>)f2[i]+=mod;</span>
<span id="cb16-27"><a href="#cb16-27"></a>    }</span>
<span id="cb16-28"><a href="#cb16-28"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f2[k]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb16-29"><a href="#cb16-29"></a>}</span></code></pre></div>
<h3 id="bzoj2761jloi2011不重复数字2016.6.10">bzoj2761[JLOI2011]不重复数字（2016.6.10）</h3>
<h4 id="题意-16">题意</h4>
<p>给出N个数，要求把其中重复的去掉，只保留第一次出现的数。n≤50000</p>
<h4 id="题解-16">题解</h4>
<p>一道令管理员都后悔加入的水题，按大小排序后unique，再按读入顺序排序即可。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb17-6"><a href="#cb17-6"></a></span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb17-8"><a href="#cb17-8"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb17-11"><a href="#cb17-11"></a>}</span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="dt">int</span> t,n,tot;</span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="kw">struct</span> nd{<span class="dt">int</span> v,id;};</span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="dt">bool</span> cmp1(nd a,nd b){<span class="cf">if</span>(a.v!=b.v)<span class="cf">return</span> a.v&lt;b.v;<span class="cf">else</span> <span class="cf">return</span> a.id&lt;b.id;}</span>
<span id="cb17-15"><a href="#cb17-15"></a><span class="dt">bool</span> cmp2(nd a,nd b){<span class="cf">return</span> a.id&lt;b.id;};</span>
<span id="cb17-16"><a href="#cb17-16"></a>nd a[<span class="dv">50010</span>],b[<span class="dv">50010</span>];</span>
<span id="cb17-17"><a href="#cb17-17"></a><span class="dt">int</span> main(){</span>
<span id="cb17-18"><a href="#cb17-18"></a>    t=read(); <span class="cf">while</span>(t--){</span>
<span id="cb17-19"><a href="#cb17-19"></a>        n=read(); inc(i,<span class="dv">1</span>,n)a[i].v=read(),a[i].id=i; sort(a+<span class="dv">1</span>,a+n+<span class="dv">1</span>,cmp1); tot=<span class="dv">0</span>;</span>
<span id="cb17-20"><a href="#cb17-20"></a>        inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(i==<span class="dv">1</span>||a[i].v!=a[i-<span class="dv">1</span>].v)b[++tot]=a[i]; sort(b+<span class="dv">1</span>,b+tot+<span class="dv">1</span>,cmp2);</span>
<span id="cb17-21"><a href="#cb17-21"></a>        inc(i,<span class="dv">1</span>,tot-<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>,b[i].v); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,b[tot].v);</span>
<span id="cb17-22"><a href="#cb17-22"></a>    }</span>
<span id="cb17-23"><a href="#cb17-23"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb17-24"><a href="#cb17-24"></a>}</span></code></pre></div>
<h3 id="bzoj1821jsoi2010group-部落划分-group2016.6.10">bzoj1821[JSOI2010]Group 部落划分 Group（2016.6.10）</h3>
<h4 id="题意-17">题意</h4>
<p>n个野人，分为k个部落，两个部落之间距离定义为两个部落最近两个野人的距离，要求划分时最近的部落最远。求这种划分下部落间最近距离。n，k≤1000，野人坐标≤10000是整数。</p>
<h4 id="题解-17">题解</h4>
<p>每次将两个部落连接，则这两个部落之间的距离则消失，因此我们应尽力让那些比较短的边消失，所以先O(n2)弄出野人间两两的边，将它们按距离从小到大排序，然后用类似Kruscal的方法（其实就是Kruscal）连边，最后连的边的下一条可连的边的长度就是所求。注意最后的退出条件是cnt==n-k+1。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,dis;}; e es[maxn*maxn/<span class="dv">2</span>]; <span class="dt">int</span> ess;</span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="dt">bool</span> cmp(e a,e b){<span class="cf">return</span> a.dis&lt;b.dis;}</span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="dt">int</span> x[maxn],y[maxn],fa[maxn],n,k;</span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb18-13"><a href="#cb18-13"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb18-14"><a href="#cb18-14"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb18-15"><a href="#cb18-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb18-16"><a href="#cb18-16"></a>}</span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb18-18"><a href="#cb18-18"></a><span class="dt">int</span> main(){</span>
<span id="cb18-19"><a href="#cb18-19"></a>    n=read(); k=read(); inc(i,<span class="dv">1</span>,n)x[i]=read(),y[i]=read(); ess=<span class="dv">0</span>;</span>
<span id="cb18-20"><a href="#cb18-20"></a>    inc(i,<span class="dv">1</span>,n)inc(j,i+<span class="dv">1</span>,n)es[++ess]=(e){i,j,(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])};</span>
<span id="cb18-21"><a href="#cb18-21"></a>    sort(es+<span class="dv">1</span>,es+ess+<span class="dv">1</span>,cmp); <span class="dt">int</span> cnt=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)fa[i]=i;</span>
<span id="cb18-22"><a href="#cb18-22"></a>    inc(i,<span class="dv">1</span>,ess){</span>
<span id="cb18-23"><a href="#cb18-23"></a>        <span class="dt">int</span> x=find(es[i].f),y=find(es[i].t); <span class="cf">if</span>(x==y)<span class="cf">continue</span>; fa[x]=y; cnt++;</span>
<span id="cb18-24"><a href="#cb18-24"></a>        <span class="cf">if</span>(cnt==n-k+<span class="dv">1</span>){printf(<span class="st">&quot;%.2lf&quot;</span>,sqrt(es[i].dis)); <span class="cf">break</span>;}</span>
<span id="cb18-25"><a href="#cb18-25"></a>    }</span>
<span id="cb18-26"><a href="#cb18-26"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-27"><a href="#cb18-27"></a>}</span></code></pre></div>
<h3 id="bzoj4551tjoi2016heoi2016树2016.6.11">bzoj4551[Tjoi2016&amp;Heoi2016]树（2016.6.11）</h3>
<h4 id="题意-18">题意</h4>
<p>给个根节点为1的n点树，初始时节点1标记，Q个操作，每次可以标记一个点或求一个点最近一个标记了的祖先。</p>
<h4 id="题解-18">题解</h4>
<p>链剖可以写，当正解应该是并查集。离线读入所有操作，累加每个节点的标记次数，之后所有未被标记的节点向其父亲节点连边，然后倒着来，如果操作是询问则输出这个节点在并查集中的根节点，如果是标记则将该节点的标记数减1，一旦这个节点的标记数减到了0，就让它向父亲节点连边。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="pp">#define maxn </span><span class="dv">100100</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb19-8"><a href="#cb19-8"></a></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb19-10"><a href="#cb19-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb19-11"><a href="#cb19-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb19-12"><a href="#cb19-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb19-13"><a href="#cb19-13"></a>}</span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){</span>
<span id="cb19-16"><a href="#cb19-16"></a>    es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;</span>
<span id="cb19-17"><a href="#cb19-17"></a>}</span>
<span id="cb19-18"><a href="#cb19-18"></a><span class="kw">struct</span> ask{<span class="dt">char</span> opt[<span class="dv">3</span>];<span class="dt">int</span> x;}; ask asks[maxn];</span>
<span id="cb19-19"><a href="#cb19-19"></a><span class="dt">int</span> n,fa[maxn],p[maxn],q,tag[maxn];</span>
<span id="cb19-20"><a href="#cb19-20"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> f){<span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f)fa[es[i].t]=x,dfs(es[i].t,x);}</span>
<span id="cb19-21"><a href="#cb19-21"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==p[x]?x:p[x]=find(p[x]);}</span>
<span id="cb19-22"><a href="#cb19-22"></a><span class="dt">void</span> uni(<span class="dt">int</span> x){<span class="dt">int</span> y=find(fa[x]),z=find(x); <span class="cf">if</span>(y!=z)p[z]=y;}</span>
<span id="cb19-23"><a href="#cb19-23"></a><span class="dt">int</span> main(){</span>
<span id="cb19-24"><a href="#cb19-24"></a>    n=read(); q=read();</span>
<span id="cb19-25"><a href="#cb19-25"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a=read(),b=read(); pe(a,b);} dfs(<span class="dv">1</span>,<span class="dv">0</span>); tag[<span class="dv">1</span>]++;</span>
<span id="cb19-26"><a href="#cb19-26"></a>    inc(i,<span class="dv">1</span>,q){scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,asks[i].opt); asks[i].x=read(); <span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>)tag[asks[i].x]++;}</span>
<span id="cb19-27"><a href="#cb19-27"></a>    inc(i,<span class="dv">1</span>,n)p[i]=i; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!tag[i])uni(i);</span>
<span id="cb19-28"><a href="#cb19-28"></a>    dec(i,q,<span class="dv">1</span>){</span>
<span id="cb19-29"><a href="#cb19-29"></a>        <span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>){</span>
<span id="cb19-30"><a href="#cb19-30"></a>            tag[asks[i].x]--;</span>
<span id="cb19-31"><a href="#cb19-31"></a>            <span class="cf">if</span>(!tag[asks[i].x])uni(asks[i].x);</span>
<span id="cb19-32"><a href="#cb19-32"></a>        }</span>
<span id="cb19-33"><a href="#cb19-33"></a>        <span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>)asks[i].x=find(asks[i].x);</span>
<span id="cb19-34"><a href="#cb19-34"></a>    }</span>
<span id="cb19-35"><a href="#cb19-35"></a>    inc(i,<span class="dv">1</span>,q)<span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,asks[i].x);</span>
<span id="cb19-36"><a href="#cb19-36"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb19-37"><a href="#cb19-37"></a>}</span></code></pre></div>
<h3 id="bzoj2435noi2011道路修建2016.6.11">bzoj2435[Noi2011]道路修建（2016.6.11）</h3>
<h4 id="题意-19">题意</h4>
<p>给个n点树，每条边的费用为这条边两端的节点数的差值*这条边的长度，求这个数的总费用。</p>
<h4 id="题解-19">题解</h4>
<p>水题，dfs求出节点的子树大小sz，对于每一条边，费用为深度大的sz值与n-sz相减的绝对值乘边的长度。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){</span>
<span id="cb20-11"><a href="#cb20-11"></a>    es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;</span>
<span id="cb20-12"><a href="#cb20-12"></a>}</span>
<span id="cb20-13"><a href="#cb20-13"></a><span class="dt">int</span> f[maxn],t[maxn],sz[maxn],n,dep[maxn]; ll w[maxn],ans;</span>
<span id="cb20-14"><a href="#cb20-14"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb20-15"><a href="#cb20-15"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb20-16"><a href="#cb20-16"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb20-17"><a href="#cb20-17"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb20-18"><a href="#cb20-18"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb20-19"><a href="#cb20-19"></a>}</span>
<span id="cb20-20"><a href="#cb20-20"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> fa){</span>
<span id="cb20-21"><a href="#cb20-21"></a>    sz[x]=<span class="dv">1</span>;</span>
<span id="cb20-22"><a href="#cb20-22"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa)dep[es[i].t]=dep[x]+<span class="dv">1</span>,dfs(es[i].t,x),sz[x]+=sz[es[i].t];</span>
<span id="cb20-23"><a href="#cb20-23"></a>}</span>
<span id="cb20-24"><a href="#cb20-24"></a><span class="dt">int</span> main(){</span>
<span id="cb20-25"><a href="#cb20-25"></a>    n=read(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>)f[i]=read(),t[i]=read(),w[i]=(ll)read(),pe(f[i],t[i]); dfs(<span class="dv">1</span>,<span class="dv">0</span>); ll ans=<span class="dv">0</span>;</span>
<span id="cb20-26"><a href="#cb20-26"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){</span>
<span id="cb20-27"><a href="#cb20-27"></a>        <span class="cf">if</span>(dep[f[i]]&lt;dep[t[i]])swap(f[i],t[i]); ans+=(ll)abs(sz[f[i]]-(n-sz[f[i]]))*w[i];</span>
<span id="cb20-28"><a href="#cb20-28"></a>    }</span>
<span id="cb20-29"><a href="#cb20-29"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb20-30"><a href="#cb20-30"></a>}</span></code></pre></div>
<h3 id="bzoj1597usaco2008-mar土地购买2016.6.12">bzoj1597[Usaco2008 Mar]土地购买（2016.6.12）</h3>
<h4 id="题意-20">题意</h4>
<p>n块土地，现在要求把土地分成几份，每份费用为该份中土地长最大值和宽最大值成绩，要求最小费用。n≤5000</p>
<h4 id="题解-20">题解</h4>
<p>当一块土地长宽都比另一块土地小时，这块土地可以当作另一块土地的附属品，对答案不影响。因此先按长第一关键字，宽第二关键字排序，然后用单调队列就可以把长宽都被覆盖的土地除去。之后剩在单调队列里的土地长是升序排列，宽是降序排列，故用斜率优化dp：f[i]=max(f[j]+长[i]*宽[j+1])，j比k好当且仅当(f[j]-f[k])/(宽[k+1]-宽[j+1])&lt;长[i]。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="pp">#define maxn </span><span class="dv">50100</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb21-8"><a href="#cb21-8"></a></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">struct</span> str{ll x,y;}; str strs1[maxn],strs2[maxn];</span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="dt">bool</span> cmp(str a,str b){<span class="cf">return</span> a.x!=b.x?a.x&lt;b.x:a.y&lt;b.y;}</span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb21-12"><a href="#cb21-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb21-13"><a href="#cb21-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb21-14"><a href="#cb21-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb21-15"><a href="#cb21-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb21-16"><a href="#cb21-16"></a>}</span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="dt">int</span> n,l,r,m,q[maxn]; ll f[maxn];</span>
<span id="cb21-18"><a href="#cb21-18"></a><span class="dt">double</span> calc(<span class="dt">int</span> j,<span class="dt">int</span> k){</span>
<span id="cb21-19"><a href="#cb21-19"></a>    <span class="cf">return</span> (<span class="dt">double</span>)(f[j]-f[k])/(<span class="dt">double</span>)(strs2[k+<span class="dv">1</span>].y-strs2[j+<span class="dv">1</span>].y);</span>
<span id="cb21-20"><a href="#cb21-20"></a>}</span>
<span id="cb21-21"><a href="#cb21-21"></a><span class="dt">int</span> main(){</span>
<span id="cb21-22"><a href="#cb21-22"></a>    n=read(); inc(i,<span class="dv">1</span>,n)strs1[i].x=(ll)read(),strs1[i].y=(ll)read(); sort(strs1+<span class="dv">1</span>,strs1+n+<span class="dv">1</span>,cmp); m=<span class="dv">0</span>;</span>
<span id="cb21-23"><a href="#cb21-23"></a>    inc(i,<span class="dv">1</span>,n){<span class="cf">while</span>(m&amp;&amp;strs2[m].y&lt;=strs1[i].y)m--; strs2[++m]=strs1[i];} l=<span class="dv">1</span>; r=<span class="dv">1</span>; q[l]=<span class="dv">0</span>;</span>
<span id="cb21-24"><a href="#cb21-24"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb21-25"><a href="#cb21-25"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[l],q[l+<span class="dv">1</span>])&lt;strs2[i].x)l++; f[i]=f[q[l]]+strs2[i].x*strs2[q[l]+<span class="dv">1</span>].y;</span>
<span id="cb21-26"><a href="#cb21-26"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[r-<span class="dv">1</span>],q[r])&gt;calc(q[r],i))r--; q[++r]=i;</span>
<span id="cb21-27"><a href="#cb21-27"></a>    }</span>
<span id="cb21-28"><a href="#cb21-28"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f[m]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb21-29"><a href="#cb21-29"></a>}</span></code></pre></div>
<h3 id="bzoj1010hnoi2008玩具装箱toy2016.6.13">bzoj1010[HNOI2008]玩具装箱toy（2016.6.13）</h3>
<h4 id="题意-21">题意</h4>
<p>n个东西，每个有一个长度Ci。要将这些东西分成几段，每段中东西编号连续。东西编号从i到j的段长度为x=i-j+sigma(k,i,j)Ck,费用为(x-L)^2（L为常量），求最小费用。n≤50000 </p>
<h4 id="题解-21">题解</h4>
<p>裸斜率优化dp：<span class="math inline">\(f[i]=f[j]+((i-j-1)+sum[i]-sum[j]-L)^2\)</span>，j比k好当且仅当<span class="math inline">\(\frac{f[j]-f[k]+(j+sum[j])^2-(k+sum[k])^2}{j+sum[j]-k-sum[k]}&gt;2*(i+sum[i]-L-1)\)</span>。注意longlong。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="pp">#define maxn </span><span class="dv">50500</span></span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb22-10"><a href="#cb22-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb22-12"><a href="#cb22-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb22-13"><a href="#cb22-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb22-14"><a href="#cb22-14"></a>}</span>
<span id="cb22-15"><a href="#cb22-15"></a><span class="dt">int</span> n,l,r,q[maxn]; ll L,sum[maxn],f[maxn];</span>
<span id="cb22-16"><a href="#cb22-16"></a>ll sqr(ll x){<span class="cf">return</span> x*x;}</span>
<span id="cb22-17"><a href="#cb22-17"></a><span class="dt">double</span> calc(<span class="dt">int</span> j,<span class="dt">int</span> k){</span>
<span id="cb22-18"><a href="#cb22-18"></a>    <span class="cf">return</span> (<span class="dt">double</span>)(f[j]-f[k]+sqr(j+sum[j])-sqr(k+sum[k]))/(<span class="dt">double</span>)(j+sum[j]-k-sum[k]);</span>
<span id="cb22-19"><a href="#cb22-19"></a>}</span>
<span id="cb22-20"><a href="#cb22-20"></a><span class="dt">int</span> main(){</span>
<span id="cb22-21"><a href="#cb22-21"></a>    n=read(); L=(ll)read(); inc(i,<span class="dv">1</span>,n){ll a=(ll)read(); sum[i]=sum[i-<span class="dv">1</span>]+a;} l=r=<span class="dv">1</span>;</span>
<span id="cb22-22"><a href="#cb22-22"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb22-23"><a href="#cb22-23"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[l],q[l+<span class="dv">1</span>])&lt;<span class="dv">2</span>*(i+sum[i]-L-<span class="dv">1</span>))l++;</span>
<span id="cb22-24"><a href="#cb22-24"></a>        f[i]=f[q[l]]+sqr((ll)(i-q[l]-<span class="dv">1</span>)+sum[i]-sum[q[l]]-L);</span>
<span id="cb22-25"><a href="#cb22-25"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[r-<span class="dv">1</span>],q[r])&gt;calc(q[r],i))r--; q[++r]=i;</span>
<span id="cb22-26"><a href="#cb22-26"></a>    }</span>
<span id="cb22-27"><a href="#cb22-27"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f[n]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb22-28"><a href="#cb22-28"></a>}</span></code></pre></div>
<h3 id="bzoj3211花神游历各国2016.6.13bzoj3038上帝造题的七分钟22016.9.22">bzoj3211花神游历各国（2016.6.13）bzoj3038上帝造题的七分钟2（2016.9.22）</h3>
<h4 id="题意-22">题意</h4>
<p>n个数的序列，m个操作，操作两种：区间开根（向下取整）和区间求和。n≤100000，m≤200000，序列中的数非负且≤10^9。</p>
<h4 id="题解-22">题解</h4>
<p>一个≤109的数开6次根就变成1了。因此开根操作可以暴力只开不是1或0的数。对每个数维护并查集表示离它最近的不是1或0的数，每次只修改这个数在并查集中的根节点，然后跳到根节点的下一个数继续此操作。而数组的快速修改求和用树状数组就可以了。反思：本机测大数据会爆栈，路径压缩得写出非递归形式，但似乎bzoj的栈很大。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="pp">#define maxn </span><span class="dv">100500</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb23-10"><a href="#cb23-10"></a></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb23-12"><a href="#cb23-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb23-13"><a href="#cb23-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb23-14"><a href="#cb23-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb23-15"><a href="#cb23-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb23-16"><a href="#cb23-16"></a>}</span>
<span id="cb23-17"><a href="#cb23-17"></a><span class="dt">int</span> n,m,fa[maxn]; ll c[maxn],v[maxn];</span>
<span id="cb23-18"><a href="#cb23-18"></a><span class="dt">void</span> update(<span class="dt">int</span> x,ll val){<span class="cf">while</span>(x&lt;=n)c[x]+=val,x+=lb(x);}</span>
<span id="cb23-19"><a href="#cb23-19"></a>ll query(<span class="dt">int</span> x){ll q=<span class="dv">0</span>; <span class="cf">while</span>(x&gt;<span class="dv">0</span>)q+=c[x],x-=lb(x); <span class="cf">return</span> q;}</span>
<span id="cb23-20"><a href="#cb23-20"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb23-21"><a href="#cb23-21"></a><span class="dt">int</span> main(){</span>
<span id="cb23-22"><a href="#cb23-22"></a>    n=read(); inc(i,<span class="dv">1</span>,n)v[i]=(ll)read(),fa[i]=i,update(i,v[i]); m=read();</span>
<span id="cb23-23"><a href="#cb23-23"></a>    fa[n+<span class="dv">1</span>]=n+<span class="dv">1</span>; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(v[i]&lt;=<span class="dv">1</span>)fa[i]=find(i+<span class="dv">1</span>);</span>
<span id="cb23-24"><a href="#cb23-24"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb23-25"><a href="#cb23-25"></a>        <span class="dt">int</span> x=read(),l=read(),r=read();</span>
<span id="cb23-26"><a href="#cb23-26"></a>        <span class="cf">if</span>(x==<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,query(r)-query(l-<span class="dv">1</span>));</span>
<span id="cb23-27"><a href="#cb23-27"></a>        <span class="cf">if</span>(x==<span class="dv">2</span>){</span>
<span id="cb23-28"><a href="#cb23-28"></a>            <span class="dt">int</span> j=l;</span>
<span id="cb23-29"><a href="#cb23-29"></a>            <span class="cf">while</span>(j&lt;=r){</span>
<span id="cb23-30"><a href="#cb23-30"></a>                j=find(j); <span class="cf">if</span>(j&gt;r)<span class="cf">break</span>; ll y=v[j]; v[j]=(ll)sqrt(y);</span>
<span id="cb23-31"><a href="#cb23-31"></a>                update(j,v[j]-y); <span class="cf">if</span>(v[j]&lt;=<span class="dv">1</span>)fa[j]=find(j+<span class="dv">1</span>); j++;</span>
<span id="cb23-32"><a href="#cb23-32"></a>            }</span>
<span id="cb23-33"><a href="#cb23-33"></a>        }</span>
<span id="cb23-34"><a href="#cb23-34"></a>    }</span>
<span id="cb23-35"><a href="#cb23-35"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb23-36"><a href="#cb23-36"></a>}</span></code></pre></div>
<h4 id="题意-23">题意</h4>
<p>同bzoj3211，但数的大小变为10^12，且操作代码变了。</p>
<h4 id="题解-23">题解</h4>
<p>数组开大，快速读入类型改为longlong即可。（我发现我bzoj3211的代码竟然是错了，wa了好几发，现在已改正）</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="pp">#define maxn </span><span class="dv">100500</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb24-10"><a href="#cb24-10"></a></span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb24-12"><a href="#cb24-12"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb24-13"><a href="#cb24-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb24-14"><a href="#cb24-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb24-15"><a href="#cb24-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb24-16"><a href="#cb24-16"></a>}</span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="dt">int</span> n,m,fa[maxn]; ll c[maxn],v[maxn];</span>
<span id="cb24-18"><a href="#cb24-18"></a><span class="dt">void</span> update(<span class="dt">int</span> x,ll val){<span class="cf">while</span>(x&lt;=n)c[x]+=val,x+=lb(x);}</span>
<span id="cb24-19"><a href="#cb24-19"></a>ll query(<span class="dt">int</span> x){ll q=<span class="dv">0</span>; <span class="cf">while</span>(x&gt;<span class="dv">0</span>)q+=c[x],x-=lb(x); <span class="cf">return</span> q;}</span>
<span id="cb24-20"><a href="#cb24-20"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb24-21"><a href="#cb24-21"></a><span class="dt">int</span> main(){</span>
<span id="cb24-22"><a href="#cb24-22"></a>    n=read(); inc(i,<span class="dv">1</span>,n)v[i]=read(),fa[i]=i,update(i,v[i]); m=read();</span>
<span id="cb24-23"><a href="#cb24-23"></a>    fa[n+<span class="dv">1</span>]=n+<span class="dv">1</span>; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(v[i]&lt;=<span class="dv">1</span>)fa[i]=find(i+<span class="dv">1</span>);</span>
<span id="cb24-24"><a href="#cb24-24"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb24-25"><a href="#cb24-25"></a>        <span class="dt">int</span> x=read(),l=read(),r=read(); <span class="cf">if</span>(l&gt;r)swap(l,r);</span>
<span id="cb24-26"><a href="#cb24-26"></a>        <span class="cf">if</span>(x==<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,query(r)-query(l-<span class="dv">1</span>));</span>
<span id="cb24-27"><a href="#cb24-27"></a>        <span class="cf">if</span>(x==<span class="dv">0</span>){</span>
<span id="cb24-28"><a href="#cb24-28"></a>            <span class="dt">int</span> j=l;</span>
<span id="cb24-29"><a href="#cb24-29"></a>            <span class="cf">while</span>(j&lt;=r){</span>
<span id="cb24-30"><a href="#cb24-30"></a>                j=find(j); <span class="cf">if</span>(j&gt;r)<span class="cf">break</span>; ll y=v[j]; v[j]=(ll)sqrt(y);</span>
<span id="cb24-31"><a href="#cb24-31"></a>                update(j,v[j]-y); <span class="cf">if</span>(v[j]&lt;=<span class="dv">1</span>)fa[j]=find(j+<span class="dv">1</span>); j++;</span>
<span id="cb24-32"><a href="#cb24-32"></a>            }</span>
<span id="cb24-33"><a href="#cb24-33"></a>        }</span>
<span id="cb24-34"><a href="#cb24-34"></a>    }</span>
<span id="cb24-35"><a href="#cb24-35"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb24-36"><a href="#cb24-36"></a>}</span></code></pre></div>
<h3 id="bzoj2753scoi2012滑雪与时间胶囊2016.6.13">bzoj2753[SCOI2012]滑雪与时间胶囊（2016.6.13）</h3>
<h4 id="题意-24">题意</h4>
<p>n点m有权边图，每个点都有高度，只能从高度高的点到高度低的点。同时还可以瞬移到走过的点，希望求经过最多点的最短时间。n≤100000，m≤1000000。</p>
<h4 id="题解-24">题解</h4>
<blockquote>
<p>第一问：用bfs扩展出能到达的所有点，并标记。第二问：分层做最小生成树。最后一个问题：怎么分层呢？其实很简单，最小生成树之前要把边排序，这个时候我们把高度作为第一关键字，然后高度相同再按照边权排序，这样就分层了啊</p>
</blockquote>
<p>感觉很神的样子。反思：因为边数弄错wa了好几发QAQ~</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="pp">#define maxn </span><span class="dv">100500</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb25-9"><a href="#cb25-9"></a></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t; ll w; <span class="dt">int</span> n;}; e es[maxn*<span class="dv">20</span>]; <span class="dt">int</span> g[maxn],ess,h[maxn];</span>
<span id="cb25-11"><a href="#cb25-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,ll w){es[++ess]=(e){f,t,w,g[f]}; g[f]=ess;}</span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="dt">bool</span> cmp(e a,e b){<span class="cf">return</span> h[a.t]!=h[b.t]?h[a.t]&gt;h[b.t]:a.w&lt;b.w;}</span>
<span id="cb25-13"><a href="#cb25-13"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb25-14"><a href="#cb25-14"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb25-15"><a href="#cb25-15"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb25-16"><a href="#cb25-16"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb25-17"><a href="#cb25-17"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb25-18"><a href="#cb25-18"></a>}</span>
<span id="cb25-19"><a href="#cb25-19"></a><span class="dt">bool</span> vis[maxn]; queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> n,m,ans1,fa[maxn],tot; ll ans2;</span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="dt">void</span> bfs(<span class="dt">int</span> s){</span>
<span id="cb25-21"><a href="#cb25-21"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); q.push(s); vis[s]=<span class="dv">1</span>; ans1=<span class="dv">1</span>;</span>
<span id="cb25-22"><a href="#cb25-22"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb25-23"><a href="#cb25-23"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb25-24"><a href="#cb25-24"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(!vis[es[i].t])vis[es[i].t]=<span class="dv">1</span>,q.push(es[i].t),ans1++;</span>
<span id="cb25-25"><a href="#cb25-25"></a>    }</span>
<span id="cb25-26"><a href="#cb25-26"></a>}</span>
<span id="cb25-27"><a href="#cb25-27"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb25-28"><a href="#cb25-28"></a><span class="dt">int</span> main(){</span>
<span id="cb25-29"><a href="#cb25-29"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)h[i]=read();</span>
<span id="cb25-30"><a href="#cb25-30"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb25-31"><a href="#cb25-31"></a>        <span class="dt">int</span> a=read(),b=read(); ll c=(ll)read();</span>
<span id="cb25-32"><a href="#cb25-32"></a>        <span class="cf">if</span>(h[a]&gt;=h[b])pe(a,b,c); <span class="cf">if</span>(h[a]&lt;=h[b])pe(b,a,c);</span>
<span id="cb25-33"><a href="#cb25-33"></a>    }</span>
<span id="cb25-34"><a href="#cb25-34"></a>    bfs(<span class="dv">1</span>); sort(es+<span class="dv">1</span>,es+ess+<span class="dv">1</span>,cmp); inc(i,<span class="dv">1</span>,n)fa[i]=i; ans2=tot=<span class="dv">0</span>;</span>
<span id="cb25-35"><a href="#cb25-35"></a>    inc(i,<span class="dv">1</span>,ess){</span>
<span id="cb25-36"><a href="#cb25-36"></a>        <span class="dt">int</span> x=find(es[i].f),y=find(es[i].t); <span class="cf">if</span>(!vis[es[i].f]||!vis[es[i].t]||x==y)<span class="cf">continue</span>;</span>
<span id="cb25-37"><a href="#cb25-37"></a>        fa[x]=y; tot++; ans2+=es[i].w; <span class="cf">if</span>(tot==ans1-<span class="dv">1</span>)<span class="cf">break</span>;</span>
<span id="cb25-38"><a href="#cb25-38"></a>    }</span>
<span id="cb25-39"><a href="#cb25-39"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%lld\n</span><span class="st">&quot;</span>,ans1,ans2); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb25-40"><a href="#cb25-40"></a>}</span></code></pre></div>
<h3 id="bzoj2427haoi2010软件安装2016.6.14">bzoj2427[HAOI2010]软件安装（2016.6.14）</h3>
<h4 id="题意-25">题意</h4>
<p>有n个软件，每个大小为wi，价值为vi，同时每个软件依赖0个或一个其他软件，要求在大小不超过的m的前提下得到最大价值。n≤100，m≤500。</p>
<h4 id="题解-25">题解</h4>
<p>缩点然后做“树上背包dp”，具体看代码，注意里面用到了滚动数组。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="pp">#define maxn </span><span class="dv">150</span></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb26-8"><a href="#cb26-8"></a></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="dt">int</span> bel[maxn],scc,dfn[maxn],low[maxn],tim,st[maxn],top,sv[maxn],sw[maxn],v[maxn],w[maxn]; <span class="dt">bool</span> inst[maxn],ok[maxn];</span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="kw">struct</span> e1{<span class="dt">int</span> f,t,n;}; e1 es1[maxn*<span class="dv">5</span>]; <span class="dt">int</span> g1[maxn],ess1;</span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="dt">void</span> pe1(<span class="dt">int</span> f,<span class="dt">int</span> t){es1[++ess1]=(e1){f,t,g1[f]}; g1[f]=ess1;}</span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="kw">struct</span> e2{<span class="dt">int</span> t,n;}; e2 es2[maxn*<span class="dv">10</span>]; <span class="dt">int</span> g2[maxn],ess2;</span>
<span id="cb26-13"><a href="#cb26-13"></a><span class="dt">void</span> pe2(<span class="dt">int</span> f,<span class="dt">int</span> t){es2[++ess2]=(e2){t,g2[f]}; g2[f]=ess2; ok[t]=<span class="dv">1</span>;}</span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="dt">void</span> init(){</span>
<span id="cb26-15"><a href="#cb26-15"></a>    ess1=ess2=<span class="dv">0</span>; memset(g1,<span class="dv">0</span>,<span class="kw">sizeof</span>(g1)); memset(g2,<span class="dv">0</span>,<span class="kw">sizeof</span>(g2));</span>
<span id="cb26-16"><a href="#cb26-16"></a>    tim=scc=<span class="dv">0</span>; memset(inst,<span class="dv">0</span>,<span class="kw">sizeof</span>(inst)); memset(dfn,<span class="dv">0</span>,<span class="kw">sizeof</span>(dfn));</span>
<span id="cb26-17"><a href="#cb26-17"></a>}</span>
<span id="cb26-18"><a href="#cb26-18"></a><span class="dt">void</span> tarjan(<span class="dt">int</span> x){</span>
<span id="cb26-19"><a href="#cb26-19"></a>    dfn[x]=low[x]=++tim; st[++top]=x; inst[x]=<span class="dv">1</span>;</span>
<span id="cb26-20"><a href="#cb26-20"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g1[x];i;i=es1[i].n){</span>
<span id="cb26-21"><a href="#cb26-21"></a>        <span class="cf">if</span>(!dfn[es1[i].t]){</span>
<span id="cb26-22"><a href="#cb26-22"></a>            tarjan(es1[i].t); low[x]=min(low[x],low[es1[i].t]);</span>
<span id="cb26-23"><a href="#cb26-23"></a>        }<span class="cf">else</span> <span class="cf">if</span>(inst[es1[i].t])low[x]=min(low[x],dfn[es1[i].t]);</span>
<span id="cb26-24"><a href="#cb26-24"></a>    }</span>
<span id="cb26-25"><a href="#cb26-25"></a>    <span class="cf">if</span>(dfn[x]==low[x]){</span>
<span id="cb26-26"><a href="#cb26-26"></a>        scc++; <span class="dt">int</span> y=<span class="dv">0</span>; <span class="cf">while</span>(x!=y)y=st[top],bel[y]=scc,sv[scc]+=v[y],sw[scc]+=w[y],inst[y]=<span class="dv">0</span>,top--;</span>
<span id="cb26-27"><a href="#cb26-27"></a>    }</span>
<span id="cb26-28"><a href="#cb26-28"></a>}</span>
<span id="cb26-29"><a href="#cb26-29"></a><span class="dt">void</span> build(){inc(i,<span class="dv">1</span>,ess1)<span class="cf">if</span>(bel[es1[i].f]!=bel[es1[i].t])pe2(bel[es1[i].f],bel[es1[i].t]);}</span>
<span id="cb26-30"><a href="#cb26-30"></a><span class="dt">int</span> f[maxn][maxn*<span class="dv">5</span>],n,m;</span>
<span id="cb26-31"><a href="#cb26-31"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb26-32"><a href="#cb26-32"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g2[x];i;i=es2[i].n){</span>
<span id="cb26-33"><a href="#cb26-33"></a>        dfs(es2[i].t);</span>
<span id="cb26-34"><a href="#cb26-34"></a>        dec(j,m-sw[x],<span class="dv">0</span>)inc(k,<span class="dv">0</span>,j)f[x][j]=max(f[x][j],f[x][k]+f[es2[i].t][j-k]);</span>
<span id="cb26-35"><a href="#cb26-35"></a>    }</span>
<span id="cb26-36"><a href="#cb26-36"></a>    dec(j,m,<span class="dv">0</span>)<span class="cf">if</span>(j&gt;=sw[x])f[x][j]=f[x][j-sw[x]]+sv[x];<span class="cf">else</span> f[x][j]=<span class="dv">0</span>;</span>
<span id="cb26-37"><a href="#cb26-37"></a>}</span>
<span id="cb26-38"><a href="#cb26-38"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb26-39"><a href="#cb26-39"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb26-40"><a href="#cb26-40"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb26-41"><a href="#cb26-41"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb26-42"><a href="#cb26-42"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb26-43"><a href="#cb26-43"></a>}</span>
<span id="cb26-44"><a href="#cb26-44"></a><span class="dt">int</span> main(){</span>
<span id="cb26-45"><a href="#cb26-45"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)w[i]=read(); inc(i,<span class="dv">1</span>,n)v[i]=read(); init();</span>
<span id="cb26-46"><a href="#cb26-46"></a>    inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a=read(); <span class="cf">if</span>(a)pe1(a,i);} inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!dfn[i])tarjan(i); build();</span>
<span id="cb26-47"><a href="#cb26-47"></a>    inc(i,<span class="dv">1</span>,scc)<span class="cf">if</span>(!ok[i])pe2(scc+<span class="dv">1</span>,i); dfs(scc+<span class="dv">1</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[scc+<span class="dv">1</span>][m]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb26-48"><a href="#cb26-48"></a>}</span></code></pre></div>
<h3 id="bzoj1041haoi2008圆上的整点2016.6.15">bzoj1041[HAOI2008]圆上的整点（2016.6.15）</h3>
<h4 id="题意-26">题意</h4>
<p>求一个给定半径的圆圆周上有多少个点的坐标是整数。r≤2*10^9</p>
<h4 id="题解-26">题解</h4>
<p>数学神题，本弱只能转载一下黄学长的题解</p>
<blockquote>
<p>首先<span class="math inline">\(x^2+y^2=r^2\)</span>，变形得<span class="math inline">\(y^2=(r+x)\times(r-x)\)</span>。令d=gcd(r+x,r-x)，则A=(r-x)/d，B=(r+x)/d，A,B互质，用a,b代入，有<span class="math inline">\(y^2=d^2\times A\times B\)</span>，由于<span class="math inline">\(d^2\)</span>，<span class="math inline">\(y^2\)</span>为完全平方数，故A*B也为完全平方数。又因为A≠B，所以A和B都是完全平方数。设<span class="math inline">\(a^2=A=(r-x)/d,b^2=B=(r+x)/d\)</span>，则<span class="math inline">\(a^2+b^2=2r/d\)</span>，因此d为r的约数。 有了上面的推理，那么实现的方法为：枚举d∈[1,sqrt(2R)]，然后根据上述推理可知：必先判d是否为2R的一约数。此时d为2R的约数有两种情况：d=d或d=2R/d。 第一种情况：d=2R/d。枚举a∈[1,sqrt(2R/d/2)] ，算出对应的b=sqrt(2R/d-a^2)，检查是否此时的A,B满足：A≠B且A,B互质，若是就将答案加1 第二种情况：d=d。枚举a∈[1,sqrt(d/2)]，算出对应的b=sqrt(d-a^2)，检查是否此时的A,B满足：A≠B且A,B互质（根据上面的推理可知必需满足此条件），若是就将答案加1 因为这样只算出了第一象限的情况（上面枚举时均是从1开始枚举），根据圆的对称性，其他象限的整点数与第一象限中的整点数相同，最后，在象限轴上的4个整点未算，加上即可，那么最后答案为ans=4*第一象限整点数+4</p>
</blockquote>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb27-6"><a href="#cb27-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(ll<span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb27-7"><a href="#cb27-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb27-8"><a href="#cb27-8"></a></span>
<span id="cb27-9"><a href="#cb27-9"></a>ll gcd(ll a,ll b){<span class="cf">return</span> b==<span class="dv">0</span>?a:gcd(b,a%b);}</span>
<span id="cb27-10"><a href="#cb27-10"></a><span class="dt">int</span> main(){</span>
<span id="cb27-11"><a href="#cb27-11"></a>    ll n,ans=<span class="dv">0</span>; scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;n); n*=<span class="dv">2</span>;</span>
<span id="cb27-12"><a href="#cb27-12"></a>    inc(i,<span class="dv">1</span>,(ll)sqrt(n))<span class="cf">if</span>(n%i==<span class="dv">0</span>){</span>
<span id="cb27-13"><a href="#cb27-13"></a>        ll d=i;</span>
<span id="cb27-14"><a href="#cb27-14"></a>        inc(j,<span class="dv">1</span>,(ll)sqrt(n/d/<span class="dv">2</span>)){</span>
<span id="cb27-15"><a href="#cb27-15"></a>            ll b=n/d-j*j; <span class="cf">if</span>(sqrt(b)==(<span class="dt">double</span>)((ll)sqrt(b))&amp;&amp;gcd(j*j,b)==<span class="dv">1</span>&amp;&amp;j*j!=b)ans++;</span>
<span id="cb27-16"><a href="#cb27-16"></a>        }</span>
<span id="cb27-17"><a href="#cb27-17"></a>        <span class="cf">if</span>(d!=n/i){</span>
<span id="cb27-18"><a href="#cb27-18"></a>            d=n/i;</span>
<span id="cb27-19"><a href="#cb27-19"></a>            inc(j,<span class="dv">1</span>,(ll)sqrt(n/d/<span class="dv">2</span>)){</span>
<span id="cb27-20"><a href="#cb27-20"></a>                ll b=n/d-j*j; <span class="cf">if</span>(sqrt(b)==(<span class="dt">double</span>)((ll)sqrt(b))&amp;&amp;gcd(j*j,b)==<span class="dv">1</span>&amp;&amp;j*j!=b)ans++;</span>
<span id="cb27-21"><a href="#cb27-21"></a>            }</span>
<span id="cb27-22"><a href="#cb27-22"></a>        }</span>
<span id="cb27-23"><a href="#cb27-23"></a>    }</span>
<span id="cb27-24"><a href="#cb27-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans*<span class="dv">4</span>+<span class="dv">4</span>); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb27-25"><a href="#cb27-25"></a>}</span></code></pre></div>
<h3 id="bzoj1013jsoi2008球形空间产生器sphere2016.6.16">bzoj1013[JSOI2008]球形空间产生器sphere（2016.6.16）</h3>
<h4 id="题意-27">题意</h4>
<p>给定n维球体上n+1个点的坐标，求球心坐标。n≤10</p>
<h4 id="题解-27">题解</h4>
<p>考虑二维情况，设球心坐标为x,y，第一个坐标为x’，y’，则可得方程<span class="math inline">\((x-x&#39;)^2+(y-y&#39;)^2=r^2\)</span>，然后从第二个坐标开始都可以和第一个坐标联立并化简，有了n个方程就可以高斯消元解出球心坐标了，多维情况也很容易推广。反思：第一次写高斯消元。高斯消元的主要思想是将系数矩阵化成倒三角矩阵（满足matrix[i][j],i&gt;j都为0的矩阵)，对于这个矩阵，如果斜线上（即matrix[i][i]）有系数为0且结果矩阵也为0，那么这个元为自由元（可取任何数）；如果斜线上有系数为0且结果矩阵不为0，那么该方程无解；否则该方程有唯一解。高斯消元本来的解法是求出倒三角矩阵后用最后一个方程回代，然而如果一开始就知道解的情况，就可以免回代，在求倒三角矩阵的同时顺便消元。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="pp">#define maxn </span><span class="dv">20</span></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="pp">#define eps </span><span class="fl">1e-6</span></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a><span class="dt">double</span> a[maxn][maxn],f[maxn]; <span class="dt">int</span> n;</span>
<span id="cb28-11"><a href="#cb28-11"></a><span class="dt">double</span> sqr(<span class="dt">double</span> x){<span class="cf">return</span> x*x;}</span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="dt">bool</span> gauss(){</span>
<span id="cb28-13"><a href="#cb28-13"></a>    <span class="dt">int</span> now=<span class="dv">1</span>,pos; <span class="dt">double</span> t;</span>
<span id="cb28-14"><a href="#cb28-14"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb28-15"><a href="#cb28-15"></a>        <span class="cf">for</span>(pos=now;pos&lt;=n;pos++)<span class="cf">if</span>(fabs(a[pos][i])&gt;eps)<span class="cf">break</span>; <span class="cf">if</span>(pos&gt;n)<span class="cf">continue</span>;</span>
<span id="cb28-16"><a href="#cb28-16"></a>        <span class="cf">if</span>(pos!=now){inc(j,<span class="dv">1</span>,n+<span class="dv">1</span>)swap(a[pos][j],a[now][j]);} t=a[now][i]; inc(j,<span class="dv">1</span>,n+<span class="dv">1</span>)a[now][j]/=t;</span>
<span id="cb28-17"><a href="#cb28-17"></a>        inc(j,<span class="dv">1</span>,n)<span class="cf">if</span>(j!=now){t=a[j][i]; inc(k,<span class="dv">1</span>,n+<span class="dv">1</span>)a[j][k]-=t*a[now][k];}</span>
<span id="cb28-18"><a href="#cb28-18"></a>        now++;</span>
<span id="cb28-19"><a href="#cb28-19"></a>    }</span>
<span id="cb28-20"><a href="#cb28-20"></a>    inc(i,now,n)<span class="cf">if</span>(fabs(a[i][n+<span class="dv">1</span>])&gt;eps)<span class="cf">return</span> <span class="dv">0</span>; <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb28-21"><a href="#cb28-21"></a>}</span>
<span id="cb28-22"><a href="#cb28-22"></a><span class="dt">int</span> main(){</span>
<span id="cb28-23"><a href="#cb28-23"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lf</span><span class="st">&quot;</span>,&amp;f[i]);</span>
<span id="cb28-24"><a href="#cb28-24"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n){<span class="dt">double</span> b; scanf(<span class="st">&quot;</span><span class="sc">%lf</span><span class="st">&quot;</span>,&amp;b); a[i][j]=<span class="dv">2</span>*b-<span class="dv">2</span>*f[j]; a[i][n+<span class="dv">1</span>]+=sqr(b)-sqr(f[j]);}</span>
<span id="cb28-25"><a href="#cb28-25"></a>    gauss();</span>
<span id="cb28-26"><a href="#cb28-26"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>)printf(<span class="st">&quot;%.3lf &quot;</span>,a[i][n+<span class="dv">1</span>]); printf(<span class="st">&quot;%.3lf</span><span class="sc">\n</span><span class="st">&quot;</span>,a[n][n+<span class="dv">1</span>]);</span>
<span id="cb28-27"><a href="#cb28-27"></a>}</span></code></pre></div>
<h3 id="bzoj1923sdoi2010外星千足虫2016.6.16">bzoj1923[Sdoi2010]外星千足虫（2016.6.16）</h3>
<h4 id="题意-28">题意</h4>
<p>n只两种动物，一种有奇数只脚，另一种偶数只角。现在进行m次操作，每次告诉你若干只动物的脚数之和为奇数还是偶数。要求你输出所有动物的类型以及最少多少次操作就能判断。n≤1000，m≤10000</p>
<h4 id="题解-28">题解</h4>
<p>设放进去的动物的系数为1，没放的系数为0，脚数如果是奇数结果就为1，偶数结果为0，解异或方程，具体看代码。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="pp">#include </span><span class="im">&lt;bitset&gt;</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a>bitset &lt;maxn&gt; M[maxn*<span class="dv">2</span>]; <span class="dt">int</span> n,m,ans; <span class="dt">char</span> s[maxn];</span>
<span id="cb29-10"><a href="#cb29-10"></a><span class="dt">void</span> gause(){</span>
<span id="cb29-11"><a href="#cb29-11"></a>    <span class="dt">int</span> now=<span class="dv">0</span>,pos;</span>
<span id="cb29-12"><a href="#cb29-12"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb29-13"><a href="#cb29-13"></a>        <span class="cf">for</span>(pos=now+<span class="dv">1</span>;pos&lt;=m&amp;&amp;!M[pos][i];pos++); <span class="cf">if</span>(pos==m+<span class="dv">1</span>){ans=-<span class="dv">1</span>; <span class="cf">return</span>;}<span class="cf">else</span> ans=max(ans,pos);</span>
<span id="cb29-14"><a href="#cb29-14"></a>        now++; swap(M[now],M[pos]); inc(j,<span class="dv">1</span>,m)<span class="cf">if</span>(j!=now&amp;&amp;M[j][i])M[j]^=M[now];</span>
<span id="cb29-15"><a href="#cb29-15"></a>    }</span>
<span id="cb29-16"><a href="#cb29-16"></a>}</span>
<span id="cb29-17"><a href="#cb29-17"></a><span class="dt">int</span> main(){</span>
<span id="cb29-18"><a href="#cb29-18"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m);</span>
<span id="cb29-19"><a href="#cb29-19"></a>    inc(i,<span class="dv">1</span>,m){scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>); inc(j,<span class="dv">1</span>,n)M[i][j]=s[j]-<span class="ch">&#39;0&#39;</span>; <span class="dt">int</span> a; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a); M[i][n+<span class="dv">1</span>]=a;}</span>
<span id="cb29-20"><a href="#cb29-20"></a>    gause();</span>
<span id="cb29-21"><a href="#cb29-21"></a>    <span class="cf">if</span>(ans==-<span class="dv">1</span>)printf(<span class="st">&quot;Cannot Determine&quot;</span>);<span class="cf">else</span>{</span>
<span id="cb29-22"><a href="#cb29-22"></a>        printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans); inc(i,<span class="dv">1</span>,n)printf(M[i][n+<span class="dv">1</span>]?<span class="st">&quot;?y7M#</span><span class="sc">\n</span><span class="st">&quot;</span>:<span class="st">&quot;Earth</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb29-23"><a href="#cb29-23"></a>    }</span>
<span id="cb29-24"><a href="#cb29-24"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb29-25"><a href="#cb29-25"></a>}</span></code></pre></div>
<h3 id="bzoj3503cqoi2014和谐矩阵2016.6.16">bzoj3503[Cqoi2014]和谐矩阵（2016.6.16）</h3>
<h4 id="题意-29">题意</h4>
<p>我们称一个由0和1组成的矩阵是和谐的，当且仅当每个元素都有偶数个相邻的1。一个元素相邻的元素包括它本身，及他上下左右的4个元素（如果存在）。给定矩阵的行数和列数，计算并输出一个和谐的矩阵。注意：所有元素为0的矩阵是不允许的。行列数≤40</p>
<h4 id="题解-29">题解</h4>
<p>设矩阵为a，则a[i][j]^a[i+1][j]^a[i-1][j]^a[i][j-1]^a[i][j+1]为0，用i-1替换i则得a[i-1][j]^a[i][j]^a[i-2][j]^a[i-1][j-1]^a[i-1][j+1]=0，每一个元素都与其上面的元素相关，因此可以说第一行的元素决定了所有元素。同时第一行的填法合法当且仅当用第一行推出a[m+1][i]的所有元素都为0。故可以找到a[m+1][j]与第一行哪些元素相关，然后列异或方程组。这个过程可以用二进制弄。如何保证不出现所有元素为0的矩阵出现呢？只要高斯消元时把自由元都当做1就行了，这样一来就必须回代了。反思：二进制操作要用到longlong，然而我强制转换乱写一通导致我wa了n次。尤其是这个地方：M[i][j]=((ll)1&lt;&lt;(j-1)&amp;a[n+1][i])?1:0，我原来是这样写的M[i][j]=((ll)(1&lt;&lt;(j-1)&amp;a[n+1][i])?1:0，这两种解法不同是因为后者先将乘法算出来并溢出了，然后才被转换，而前者不同是因为它把乘数转换了，而longlong*int的结果为longlong故不会溢出，以后要记牢这一点。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="pp">#include </span><span class="im">&lt;bitset&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="pp">#define maxn </span><span class="dv">50</span></span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb30-9"><a href="#cb30-9"></a></span>
<span id="cb30-10"><a href="#cb30-10"></a>bitset &lt;maxn&gt; M[maxn];</span>
<span id="cb30-11"><a href="#cb30-11"></a>ll a[maxn][maxn];<span class="dt">int</span> b[maxn][maxn],n,m;</span>
<span id="cb30-12"><a href="#cb30-12"></a><span class="dt">void</span> gauss(){</span>
<span id="cb30-13"><a href="#cb30-13"></a>    <span class="dt">int</span> now=<span class="dv">0</span>,pos;</span>
<span id="cb30-14"><a href="#cb30-14"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb30-15"><a href="#cb30-15"></a>        <span class="cf">for</span>(pos=now+<span class="dv">1</span>;pos&lt;=m&amp;&amp;!M[pos][i];pos++); <span class="cf">if</span>(pos&gt;m)<span class="cf">continue</span>;</span>
<span id="cb30-16"><a href="#cb30-16"></a>        now++; swap(M[pos],M[now]); inc(j,now+<span class="dv">1</span>,m)<span class="cf">if</span>(M[j][i])M[j]^=M[now];</span>
<span id="cb30-17"><a href="#cb30-17"></a>    }</span>
<span id="cb30-18"><a href="#cb30-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=m;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb30-19"><a href="#cb30-19"></a>        b[<span class="dv">1</span>][i]=M[i][m+<span class="dv">1</span>]; <span class="cf">if</span>(!M[i][i]){b[<span class="dv">1</span>][i]=<span class="dv">1</span>; <span class="cf">continue</span>;} inc(j,i+<span class="dv">1</span>,m)<span class="cf">if</span>(M[i][j])b[<span class="dv">1</span>][i]^=b[<span class="dv">1</span>][j];</span>
<span id="cb30-20"><a href="#cb30-20"></a>    }</span>
<span id="cb30-21"><a href="#cb30-21"></a>}</span>
<span id="cb30-22"><a href="#cb30-22"></a><span class="dt">int</span> main(){</span>
<span id="cb30-23"><a href="#cb30-23"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,m)a[<span class="dv">1</span>][i]=(ll)<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>);</span>
<span id="cb30-24"><a href="#cb30-24"></a>    inc(i,<span class="dv">2</span>,n+<span class="dv">1</span>)inc(j,<span class="dv">1</span>,m)a[i][j]=a[i-<span class="dv">2</span>][j]^a[i-<span class="dv">1</span>][j-<span class="dv">1</span>]^a[i-<span class="dv">1</span>][j+<span class="dv">1</span>]^a[i-<span class="dv">1</span>][j];</span>
<span id="cb30-25"><a href="#cb30-25"></a>    inc(i,<span class="dv">1</span>,m){inc(j,<span class="dv">1</span>,m)M[i][j]=((ll)<span class="dv">1</span>&lt;&lt;(j-<span class="dv">1</span>)&amp;a[n+<span class="dv">1</span>][i])?<span class="dv">1</span>:<span class="dv">0</span>; M[i][m+<span class="dv">1</span>]=<span class="dv">0</span>;} gauss();</span>
<span id="cb30-26"><a href="#cb30-26"></a>    inc(i,<span class="dv">2</span>,n)inc(j,<span class="dv">1</span>,m)b[i][j]=b[i-<span class="dv">2</span>][j]^b[i-<span class="dv">1</span>][j-<span class="dv">1</span>]^b[i-<span class="dv">1</span>][j+<span class="dv">1</span>]^b[i-<span class="dv">1</span>][j];</span>
<span id="cb30-27"><a href="#cb30-27"></a>    inc(i,<span class="dv">1</span>,n){inc(j,<span class="dv">1</span>,m-<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>,b[i][j]); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,b[i][m]);}</span>
<span id="cb30-28"><a href="#cb30-28"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb30-29"><a href="#cb30-29"></a>}</span></code></pre></div>
<h3 id="bzoj1968ahoi2005common-约数研究2016.6.17">bzoj1968[Ahoi2005]COMMON 约数研究（2016.6.17）</h3>
<h4 id="题意-30">题意</h4>
<p>定义f(x)=x的约数个数，求<span class="math inline">\(\sum_{i=1}^n{f(i)}\)</span>。n≤1000000</p>
<h4 id="题解-30">题解</h4>
<p>只要会思路这道题就很水。对于一个数i，它是n/i个数的约数，对答案有n/i的贡献。所以直接从1枚举到n累加n/i就行了。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="dt">int</span> main(){</span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="dt">int</span> n;scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); <span class="dt">int</span> ans=<span class="dv">0</span>;</span>
<span id="cb31-5"><a href="#cb31-5"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)ans+=n/i;</span>
<span id="cb31-6"><a href="#cb31-6"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb31-7"><a href="#cb31-7"></a>}</span></code></pre></div>
<h3 id="bzoj1212hnoi2004l语言2016.6.17">bzoj1212[HNOI2004]L语言（2016.6.17）</h3>
<h4 id="题意-31">题意</h4>
<p>给定一个字典D，你的程序需要判断若干段文章在字典D下是否能够被理解。 并给出其在字典D下能够被理解的最长前缀的位置。理解定义为这段文章可以拆成字典里的单词。单词数≤10且长度≤10，文章数≤20且长度≤1M。</p>
<h4 id="题解-31">题解</h4>
<p>在trie上跑dp，dp[i]表示文章能否匹配到i这个位置。对于每个i，如果dp[i-1]为1，则从s[i]开始在trie上走，走过的节点数+i的dp值都置为1。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="pp">#define maxn </span><span class="dv">200</span></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb32-7"><a href="#cb32-7"></a></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="dt">int</span> ch[maxn][<span class="dv">26</span>],n,m,sz; <span class="dt">bool</span> d[maxn*<span class="dv">10000</span>],val[maxn]; <span class="dt">char</span> s[maxn*<span class="dv">10000</span>];</span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="dt">void</span> insert(<span class="dt">char</span> *s){</span>
<span id="cb32-10"><a href="#cb32-10"></a>    <span class="dt">int</span> l=strlen(s+<span class="dv">1</span>),x=<span class="dv">0</span>;</span>
<span id="cb32-11"><a href="#cb32-11"></a>    inc(i,<span class="dv">1</span>,l){</span>
<span id="cb32-12"><a href="#cb32-12"></a>        <span class="cf">if</span>(!ch[x][s[i]-<span class="ch">&#39;a&#39;</span>])ch[x][s[i]-<span class="ch">&#39;a&#39;</span>]=++sz; x=ch[x][s[i]-<span class="ch">&#39;a&#39;</span>];</span>
<span id="cb32-13"><a href="#cb32-13"></a>    }</span>
<span id="cb32-14"><a href="#cb32-14"></a>    val[x]=<span class="dv">1</span>;</span>
<span id="cb32-15"><a href="#cb32-15"></a>}</span>
<span id="cb32-16"><a href="#cb32-16"></a><span class="dt">int</span> main(){</span>
<span id="cb32-17"><a href="#cb32-17"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>),insert(s);</span>
<span id="cb32-18"><a href="#cb32-18"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb32-19"><a href="#cb32-19"></a>        memset(d,<span class="dv">0</span>,<span class="kw">sizeof</span>(d)); scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>); <span class="dt">int</span> l=strlen(s+<span class="dv">1</span>); d[<span class="dv">0</span>]=<span class="dv">1</span>;</span>
<span id="cb32-20"><a href="#cb32-20"></a>        inc(i,<span class="dv">1</span>,l)<span class="cf">if</span>(d[i-<span class="dv">1</span>]){</span>
<span id="cb32-21"><a href="#cb32-21"></a>            <span class="dt">int</span> x=<span class="dv">0</span>,y=i;</span>
<span id="cb32-22"><a href="#cb32-22"></a>            <span class="cf">while</span>(s[y]-<span class="ch">&#39;a&#39;</span>&gt;=<span class="dv">0</span>&amp;&amp;ch[x][s[y]-<span class="ch">&#39;a&#39;</span>]){</span>
<span id="cb32-23"><a href="#cb32-23"></a>                x=ch[x][s[y]-<span class="ch">&#39;a&#39;</span>]; <span class="cf">if</span>(val[x])d[y]=<span class="dv">1</span>; y++;</span>
<span id="cb32-24"><a href="#cb32-24"></a>            }</span>
<span id="cb32-25"><a href="#cb32-25"></a>        }</span>
<span id="cb32-26"><a href="#cb32-26"></a>        <span class="cf">while</span>(!d[l])l--; printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,l);</span>
<span id="cb32-27"><a href="#cb32-27"></a>    }</span>
<span id="cb32-28"><a href="#cb32-28"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb32-29"><a href="#cb32-29"></a>}</span></code></pre></div>
<h3 id="bzoj3172tjoi2013单词2016.6.20">bzoj3172[Tjoi2013]单词（2016.6.20）</h3>
<h4 id="题意-32">题意</h4>
<p>某人读论文，一篇论文是由许多单词组成。但他发现一个单词会在论文中出现很多次，现在想知道每个单词分别在论文中出现多少次。注意论文中单词之间是有分隔的。单词数≤200，长度≤1000000</p>
<h4 id="题解-32">题解</h4>
<p>先将每个单词插入trie，经过的节点的sum[i]++，然后求fail函数，求完后按BFS序倒过来维护sum[fail[i]]+=sum[i]，最后输出第i个单词末尾字符节点的sum值。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb33-7"><a href="#cb33-7"></a></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="dt">int</span> ch[maxn][<span class="dv">26</span>],sum[maxn],pos[maxn],q[maxn],n,tot,fail[maxn]; <span class="dt">char</span> s[maxn];</span>
<span id="cb33-9"><a href="#cb33-9"></a><span class="dt">int</span> insert(<span class="dt">char</span> *s){</span>
<span id="cb33-10"><a href="#cb33-10"></a>    <span class="dt">int</span> l=strlen(s+<span class="dv">1</span>),x=<span class="dv">0</span>;</span>
<span id="cb33-11"><a href="#cb33-11"></a>    inc(i,<span class="dv">1</span>,l){<span class="cf">if</span>(!ch[x][s[i]-<span class="ch">&#39;a&#39;</span>])ch[x][s[i]-<span class="ch">&#39;a&#39;</span>]=++tot; x=ch[x][s[i]-<span class="ch">&#39;a&#39;</span>]; sum[x]++;} <span class="cf">return</span> x;</span>
<span id="cb33-12"><a href="#cb33-12"></a>}</span>
<span id="cb33-13"><a href="#cb33-13"></a><span class="dt">void</span> getfail(){</span>
<span id="cb33-14"><a href="#cb33-14"></a>    <span class="dt">int</span> l=<span class="dv">1</span>,r=<span class="dv">0</span>; inc(i,<span class="dv">0</span>,<span class="dv">25</span>)<span class="cf">if</span>(ch[<span class="dv">0</span>][i])q[++r]=ch[<span class="dv">0</span>][i],fail[ch[<span class="dv">0</span>][i]]=<span class="dv">0</span>;</span>
<span id="cb33-15"><a href="#cb33-15"></a>    <span class="cf">while</span>(l&lt;=r){</span>
<span id="cb33-16"><a href="#cb33-16"></a>        <span class="dt">int</span> x=q[l++];</span>
<span id="cb33-17"><a href="#cb33-17"></a>        inc(i,<span class="dv">0</span>,<span class="dv">25</span>)<span class="cf">if</span>(ch[x][i]){</span>
<span id="cb33-18"><a href="#cb33-18"></a>            <span class="dt">int</span> y=fail[x]; <span class="cf">while</span>(y&amp;&amp;!ch[y][i])y=fail[y];</span>
<span id="cb33-19"><a href="#cb33-19"></a>            <span class="cf">if</span>(ch[y][i])fail[ch[x][i]]=ch[y][i]; q[++r]=ch[x][i];</span>
<span id="cb33-20"><a href="#cb33-20"></a>        }</span>
<span id="cb33-21"><a href="#cb33-21"></a>    }</span>
<span id="cb33-22"><a href="#cb33-22"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=r;i;i--)sum[fail[q[i]]]+=sum[q[i]];</span>
<span id="cb33-23"><a href="#cb33-23"></a>}</span>
<span id="cb33-24"><a href="#cb33-24"></a><span class="dt">int</span> main(){</span>
<span id="cb33-25"><a href="#cb33-25"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); tot=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n){scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>); pos[i]=insert(s);}</span>
<span id="cb33-26"><a href="#cb33-26"></a>    getfail(); inc(i,<span class="dv">1</span>,n)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,sum[pos[i]]);</span>
<span id="cb33-27"><a href="#cb33-27"></a>}</span></code></pre></div>
<h3 id="bzoj1269ahoi2006文本编辑器editor2016.6.20">bzoj1269[AHOI2006]文本编辑器editor（2016.6.20）</h3>
<h4 id="题意-33">题意</h4>
<p>维护一个字符串，支持插入，删除，翻转操作。</p>
<h4 id="题解-33">题解</h4>
<p>C++有个库里面有个容器叫rope，可以实现可持久化平衡树，然而本题只要它的插入、删除、截取字符串功能就行了，翻转怎么办？维护一个倒序的rope即可。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="pp">#include </span><span class="im">&lt;ext/rope&gt;</span></span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="pp">#define maxn </span><span class="dv">2000000</span></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb34-8"><a href="#cb34-8"></a><span class="kw">using</span> <span class="kw">namespace</span> __gnu_cxx;</span>
<span id="cb34-9"><a href="#cb34-9"></a></span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb34-11"><a href="#cb34-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb34-12"><a href="#cb34-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb34-13"><a href="#cb34-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb34-14"><a href="#cb34-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb34-15"><a href="#cb34-15"></a>}</span>
<span id="cb34-16"><a href="#cb34-16"></a>rope &lt;<span class="dt">char</span>&gt; l,r,tmp; <span class="dt">char</span> ls[maxn],rs[maxn],opt[<span class="dv">10</span>]; <span class="dt">int</span> n,now;</span>
<span id="cb34-17"><a href="#cb34-17"></a><span class="dt">int</span> main(){</span>
<span id="cb34-18"><a href="#cb34-18"></a>    n=read();</span>
<span id="cb34-19"><a href="#cb34-19"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb34-20"><a href="#cb34-20"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,opt);</span>
<span id="cb34-21"><a href="#cb34-21"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;M&#39;</span>)now=read(); <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;P&#39;</span>)now--;</span>
<span id="cb34-22"><a href="#cb34-22"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;N&#39;</span>)now++; <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;G&#39;</span>)printf(<span class="st">&quot;</span><span class="sc">%c\n</span><span class="st">&quot;</span>,l[now]);</span>
<span id="cb34-23"><a href="#cb34-23"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;D&#39;</span>){<span class="dt">int</span> x=read(),len=l.length(); l.erase(now,x); r.erase(len-now-x,x);}</span>
<span id="cb34-24"><a href="#cb34-24"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;R&#39;</span>){</span>
<span id="cb34-25"><a href="#cb34-25"></a>            <span class="dt">int</span> x=read(),len=l.length(); tmp=l.substr(now,x);</span>
<span id="cb34-26"><a href="#cb34-26"></a>            l=l.substr(<span class="dv">0</span>,now)+r.substr(len-now-x,x)+l.substr(now+x,len-now-x);</span>
<span id="cb34-27"><a href="#cb34-27"></a>            r=r.substr(<span class="dv">0</span>,len-now-x)+tmp+r.substr(len-now,now);</span>
<span id="cb34-28"><a href="#cb34-28"></a>        }</span>
<span id="cb34-29"><a href="#cb34-29"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;I&#39;</span>){</span>
<span id="cb34-30"><a href="#cb34-30"></a>            <span class="dt">int</span> x=read(),len=l.length();</span>
<span id="cb34-31"><a href="#cb34-31"></a>            inc(i,<span class="dv">0</span>,x-<span class="dv">1</span>){</span>
<span id="cb34-32"><a href="#cb34-32"></a>                ls[i]=getchar(); <span class="cf">while</span>(ls[i]&lt;<span class="dv">32</span>||ls[i]&gt;<span class="dv">126</span>)ls[i]=getchar(); rs[x-i-<span class="dv">1</span>]=ls[i];</span>
<span id="cb34-33"><a href="#cb34-33"></a>            }</span>
<span id="cb34-34"><a href="#cb34-34"></a>            ls[x]=rs[x]=<span class="dv">0</span>; l.insert(now,ls); r.insert(len-now,rs);</span>
<span id="cb34-35"><a href="#cb34-35"></a>        }</span>
<span id="cb34-36"><a href="#cb34-36"></a>    }</span>
<span id="cb34-37"><a href="#cb34-37"></a>}</span></code></pre></div>
<h3 id="bzoj1030jsoi2007文本生成器2016.6.21">bzoj1030[JSOI2007]文本生成器（2016.6.21）</h3>
<h4 id="题意-34">题意</h4>
<p>给出一个字典和一个长度，要求有多少个这个长度的字符串里含有子串为字典里的单词。字符串和字典里的字符都为大写字母。单词数≤60，字符串及单词长度≤100。</p>
<h4 id="题解-34">题解</h4>
<p>在AC自动机上跑dp，求不含字典单词的个数，再用总个数减。f[i][j]表示当前处理第i个位置，在trie上的节点为j。f[i][j]=sum{f[i+1][ch[x][k]]}，x为j的fail祖先，为k为大写字母，不能走到val为1的节点。注意val的处理，特别是getfail中的“if(val[ch[y][i]])val[ch[x][i]]=1;”一句。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="pp">#define maxn </span><span class="dv">10000</span></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="pp">#define mod </span><span class="dv">10007</span></span>
<span id="cb35-8"><a href="#cb35-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb35-9"><a href="#cb35-9"></a></span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="dt">int</span> n,m,sz,ch[maxn][<span class="dv">26</span>],fail[maxn],ans,f[<span class="dv">150</span>][maxn]; <span class="dt">bool</span> val[maxn];</span>
<span id="cb35-11"><a href="#cb35-11"></a><span class="dt">void</span> insert(<span class="dt">char</span> *s){</span>
<span id="cb35-12"><a href="#cb35-12"></a>    <span class="dt">int</span> x=<span class="dv">0</span>,len=strlen(s+<span class="dv">1</span>); inc(i,<span class="dv">1</span>,len){<span class="cf">if</span>(!ch[x][s[i]-<span class="ch">&#39;A&#39;</span>])ch[x][s[i]-<span class="ch">&#39;A&#39;</span>]=++sz; x=ch[x][s[i]-<span class="ch">&#39;A&#39;</span>];}</span>
<span id="cb35-13"><a href="#cb35-13"></a>    val[x]=<span class="dv">1</span>;</span>
<span id="cb35-14"><a href="#cb35-14"></a>}</span>
<span id="cb35-15"><a href="#cb35-15"></a>queue &lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb35-16"><a href="#cb35-16"></a><span class="dt">void</span> getfail(){</span>
<span id="cb35-17"><a href="#cb35-17"></a>    inc(i,<span class="dv">0</span>,<span class="dv">25</span>)<span class="cf">if</span>(ch[<span class="dv">0</span>][i])q.push(ch[<span class="dv">0</span>][i]),fail[ch[<span class="dv">0</span>][i]]=<span class="dv">0</span>;</span>
<span id="cb35-18"><a href="#cb35-18"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb35-19"><a href="#cb35-19"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb35-20"><a href="#cb35-20"></a>        inc(i,<span class="dv">0</span>,<span class="dv">25</span>)<span class="cf">if</span>(ch[x][i]){</span>
<span id="cb35-21"><a href="#cb35-21"></a>            <span class="dt">int</span> y=fail[x]; <span class="cf">while</span>(y&amp;&amp;!ch[y][i])y=fail[y]; <span class="cf">if</span>(ch[y][i])fail[ch[x][i]]=ch[y][i];</span>
<span id="cb35-22"><a href="#cb35-22"></a>            <span class="cf">if</span>(val[ch[y][i]])val[ch[x][i]]=<span class="dv">1</span>; q.push(ch[x][i]);</span>
<span id="cb35-23"><a href="#cb35-23"></a>        }</span>
<span id="cb35-24"><a href="#cb35-24"></a>    }</span>
<span id="cb35-25"><a href="#cb35-25"></a>}</span>
<span id="cb35-26"><a href="#cb35-26"></a><span class="dt">char</span> str[<span class="dv">150</span>];</span>
<span id="cb35-27"><a href="#cb35-27"></a><span class="dt">int</span> main(){</span>
<span id="cb35-28"><a href="#cb35-28"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,str+<span class="dv">1</span>),insert(str); ans=<span class="dv">1</span>; getfail();</span>
<span id="cb35-29"><a href="#cb35-29"></a>    inc(i,<span class="dv">1</span>,m)ans=ans*<span class="dv">26</span>%mod; f[<span class="dv">0</span>][<span class="dv">0</span>]=<span class="dv">1</span>;</span>
<span id="cb35-30"><a href="#cb35-30"></a>    inc(i,<span class="dv">1</span>,m)inc(j,<span class="dv">0</span>,sz)<span class="cf">if</span>(!val[j]&amp;&amp;f[i-<span class="dv">1</span>][j]){</span>
<span id="cb35-31"><a href="#cb35-31"></a>        inc(k,<span class="dv">0</span>,<span class="dv">25</span>){</span>
<span id="cb35-32"><a href="#cb35-32"></a>            <span class="dt">int</span> x=j; <span class="cf">while</span>(x&amp;&amp;!ch[x][k])x=fail[x]; f[i][ch[x][k]]=(f[i][ch[x][k]]+f[i-<span class="dv">1</span>][j])%mod;</span>
<span id="cb35-33"><a href="#cb35-33"></a>        }</span>
<span id="cb35-34"><a href="#cb35-34"></a>    }</span>
<span id="cb35-35"><a href="#cb35-35"></a>    inc(i,<span class="dv">0</span>,sz)<span class="cf">if</span>(!val[i]){</span>
<span id="cb35-36"><a href="#cb35-36"></a>        ans=(ans-f[m][i])%mod; <span class="cf">if</span>(ans&lt;<span class="dv">0</span>)ans+=mod;</span>
<span id="cb35-37"><a href="#cb35-37"></a>    }</span>
<span id="cb35-38"><a href="#cb35-38"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb35-39"><a href="#cb35-39"></a>}</span></code></pre></div>
<h3 id="bzoj2588-spoj-10628.-count-on-a-tree2016.6.21">bzoj2588 Spoj 10628. Count on a tree（2016.6.21）</h3>
<h4 id="题意-35">题意</h4>
<p>n点树，m个询问求点u到点v路径上第k小的点权。强制在线。n，m≤100000</p>
<h4 id="题解-35">题解</h4>
<p>用主席树维护某节点到根节点的权值数量sz，建树过程可以由父亲节点递推。询问就用倍增求出lca，然后路径上的sz值就为sz[u]-sz[lca]+sz[v]-sz[fa[lca]]。反思：本弱倍增数组写反了，疯狂reQAQ~</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="pp">#define maxn </span><span class="dv">100500</span></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb36-7"><a href="#cb36-7"></a></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="dt">int</span> f[<span class="dv">18</span>][maxn],rt[maxn],dep[maxn],ch[maxn*<span class="dv">35</span>][<span class="dv">2</span>],sz[maxn*<span class="dv">35</span>],v[maxn],id[maxn],n,m,size,last,tot;</span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb36-10"><a href="#cb36-10"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;}</span>
<span id="cb36-11"><a href="#cb36-11"></a><span class="kw">struct</span> abc{<span class="dt">int</span> v,id;}; abc abcd[maxn]; <span class="dt">bool</span> cmp(abc a,abc b){<span class="cf">return</span> a.v&lt;b.v;}</span>
<span id="cb36-12"><a href="#cb36-12"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> x=<span class="dv">0</span>,f=<span class="dv">1</span>;</span>
<span id="cb36-14"><a href="#cb36-14"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb36-15"><a href="#cb36-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb36-16"><a href="#cb36-16"></a>}</span>
<span id="cb36-17"><a href="#cb36-17"></a><span class="dt">void</span> build1(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb36-18"><a href="#cb36-18"></a>    x=++size; sz[x]=ch[x][<span class="dv">0</span>]=ch[x][<span class="dv">1</span>]=<span class="dv">0</span>; <span class="cf">if</span>(l==r)<span class="cf">return</span>;</span>
<span id="cb36-19"><a href="#cb36-19"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; build1(ch[x][<span class="dv">0</span>],l,mid); build1(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r);</span>
<span id="cb36-20"><a href="#cb36-20"></a>}</span>
<span id="cb36-21"><a href="#cb36-21"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> val){</span>
<span id="cb36-22"><a href="#cb36-22"></a>    size++; sz[size]=sz[x]+<span class="dv">1</span>; ch[size][<span class="dv">0</span>]=ch[x][<span class="dv">0</span>]; ch[size][<span class="dv">1</span>]=ch[x][<span class="dv">1</span>]; x=size; <span class="cf">if</span>(l==r)<span class="cf">return</span>;</span>
<span id="cb36-23"><a href="#cb36-23"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(val&lt;=mid)insert(ch[x][<span class="dv">0</span>],l,mid,val); <span class="cf">if</span>(val&gt;mid)insert(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r,val);</span>
<span id="cb36-24"><a href="#cb36-24"></a>}</span>
<span id="cb36-25"><a href="#cb36-25"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> fa){</span>
<span id="cb36-26"><a href="#cb36-26"></a>    rt[x]=rt[fa]; insert(rt[x],<span class="dv">1</span>,tot,v[x]);</span>
<span id="cb36-27"><a href="#cb36-27"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa){</span>
<span id="cb36-28"><a href="#cb36-28"></a>        f[<span class="dv">0</span>][es[i].t]=x; dep[es[i].t]=dep[x]+<span class="dv">1</span>; dfs(es[i].t,x);</span>
<span id="cb36-29"><a href="#cb36-29"></a>    }</span>
<span id="cb36-30"><a href="#cb36-30"></a>}</span>
<span id="cb36-31"><a href="#cb36-31"></a><span class="dt">void</span> build2(){</span>
<span id="cb36-32"><a href="#cb36-32"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;(<span class="dv">1</span>&lt;&lt;i)&lt;=n;i++)inc(j,<span class="dv">1</span>,n)f[i][j]=f[i-<span class="dv">1</span>][f[i-<span class="dv">1</span>][j]];</span>
<span id="cb36-33"><a href="#cb36-33"></a>}</span>
<span id="cb36-34"><a href="#cb36-34"></a><span class="dt">int</span> LCA(<span class="dt">int</span> u,<span class="dt">int</span> v){</span>
<span id="cb36-35"><a href="#cb36-35"></a>    <span class="cf">if</span>(dep[u]&lt;dep[v])swap(u,v); <span class="dt">int</span> t=dep[u]-dep[v];</span>
<span id="cb36-36"><a href="#cb36-36"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;(<span class="dv">1</span>&lt;&lt;i)&lt;=n;i++)<span class="cf">if</span>(t&amp;(<span class="dv">1</span>&lt;&lt;i))u=f[i][u];</span>
<span id="cb36-37"><a href="#cb36-37"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">16</span>;i&gt;=<span class="dv">0</span>;i--)<span class="cf">if</span>(f[i][u]!=f[i][v])u=f[i][u],v=f[i][v];</span>
<span id="cb36-38"><a href="#cb36-38"></a>    <span class="cf">return</span> u==v?u:f[<span class="dv">0</span>][u];</span>
<span id="cb36-39"><a href="#cb36-39"></a>}</span>
<span id="cb36-40"><a href="#cb36-40"></a><span class="dt">int</span> solve(<span class="dt">int</span> u,<span class="dt">int</span> v,<span class="dt">int</span> k){</span>
<span id="cb36-41"><a href="#cb36-41"></a>    <span class="dt">int</span> lca=LCA(u,v),l=<span class="dv">1</span>,r=tot,x1=rt[v],x2=rt[f[<span class="dv">0</span>][lca]],x3=rt[u],x4=rt[lca];</span>
<span id="cb36-42"><a href="#cb36-42"></a>    <span class="cf">while</span>(l&lt;r){</span>
<span id="cb36-43"><a href="#cb36-43"></a>        <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>,tmp=sz[ch[x1][<span class="dv">0</span>]]-sz[ch[x2][<span class="dv">0</span>]]+sz[ch[x3][<span class="dv">0</span>]]-sz[ch[x4][<span class="dv">0</span>]];</span>
<span id="cb36-44"><a href="#cb36-44"></a>        <span class="cf">if</span>(tmp&gt;=k)</span>
<span id="cb36-45"><a href="#cb36-45"></a>            r=mid,x1=ch[x1][<span class="dv">0</span>],x2=ch[x2][<span class="dv">0</span>],x3=ch[x3][<span class="dv">0</span>],x4=ch[x4][<span class="dv">0</span>];</span>
<span id="cb36-46"><a href="#cb36-46"></a>        <span class="cf">else</span></span>
<span id="cb36-47"><a href="#cb36-47"></a>            k-=tmp,l=mid+<span class="dv">1</span>,x1=ch[x1][<span class="dv">1</span>],x2=ch[x2][<span class="dv">1</span>],x3=ch[x3][<span class="dv">1</span>],x4=ch[x4][<span class="dv">1</span>];</span>
<span id="cb36-48"><a href="#cb36-48"></a>    }</span>
<span id="cb36-49"><a href="#cb36-49"></a>    <span class="cf">return</span> l;</span>
<span id="cb36-50"><a href="#cb36-50"></a>}</span>
<span id="cb36-51"><a href="#cb36-51"></a><span class="dt">int</span> main(){</span>
<span id="cb36-52"><a href="#cb36-52"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)abcd[i]=(abc){read(),i}; inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a=read(),b=read(); pe(a,b);}</span>
<span id="cb36-53"><a href="#cb36-53"></a>    sort(abcd+<span class="dv">1</span>,abcd+<span class="dv">1</span>+n,cmp);</span>
<span id="cb36-54"><a href="#cb36-54"></a>    inc(i,<span class="dv">1</span>,n){<span class="cf">if</span>(i==<span class="dv">1</span>||abcd[i].v!=abcd[i-<span class="dv">1</span>].v)++tot,id[tot]=abcd[i].v; v[abcd[i].id]=tot;}</span>
<span id="cb36-55"><a href="#cb36-55"></a>    size=<span class="dv">0</span>; build1(rt[<span class="dv">0</span>],<span class="dv">1</span>,tot); dfs(<span class="dv">1</span>,<span class="dv">0</span>); build2();</span>
<span id="cb36-56"><a href="#cb36-56"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb36-57"><a href="#cb36-57"></a>        <span class="dt">int</span> u=read()^last,v=read(),k=read(); last=id[solve(u,v,k)]; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,last); <span class="cf">if</span>(i!=m)puts(<span class="st">&quot;&quot;</span>);</span>
<span id="cb36-58"><a href="#cb36-58"></a>    }</span>
<span id="cb36-59"><a href="#cb36-59"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb36-60"><a href="#cb36-60"></a>}</span></code></pre></div>
<h3 id="bzoj3156防御准备2016.6.23">bzoj3156防御准备（2016.6.23）</h3>
<h4 id="题意-36">题意</h4>
<p>n个检查点，在第i个检查点放置塔花费a[i]，放置木偶花费为该位置右边最近一个塔离它的距离。求最小花费。n≤1000000</p>
<h4 id="题解-36">题解</h4>
<p>从右往左处理。在第i个点放塔的费用<span class="math inline">\(f[i]=\min_j(f[j]+\sum_{k=i+1}^{j-1}{k-i})+a[i]\)</span>，用等差数列求和公式化简后作斜率dp，具体看代码。反思：本弱公式总是推错，要稳！</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb37-8"><a href="#cb37-8"></a></span>
<span id="cb37-9"><a href="#cb37-9"></a><span class="dt">int</span> n,q[maxn],l,r; ll c[maxn],f[maxn];</span>
<span id="cb37-10"><a href="#cb37-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb37-11"><a href="#cb37-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> x=<span class="dv">0</span>,f=<span class="dv">1</span>;</span>
<span id="cb37-12"><a href="#cb37-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb37-13"><a href="#cb37-13"></a>    <span class="cf">return</span> x*f;</span>
<span id="cb37-14"><a href="#cb37-14"></a>}</span>
<span id="cb37-15"><a href="#cb37-15"></a><span class="dt">double</span> calc(<span class="dt">int</span> j,<span class="dt">int</span> k){</span>
<span id="cb37-16"><a href="#cb37-16"></a>    <span class="cf">return</span> (<span class="dt">double</span>)(<span class="dv">2</span>*f[j]-<span class="dv">2</span>*f[k]+j-k+(ll)j*j-(ll)k*k)/(<span class="dt">double</span>)(j-k);</span>
<span id="cb37-17"><a href="#cb37-17"></a>}</span>
<span id="cb37-18"><a href="#cb37-18"></a><span class="dt">int</span> main(){</span>
<span id="cb37-19"><a href="#cb37-19"></a>    n=read(); inc(i,<span class="dv">1</span>,n)c[i]=(ll)read(); l=r=<span class="dv">0</span>;</span>
<span id="cb37-20"><a href="#cb37-20"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb37-21"><a href="#cb37-21"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[l],q[l+<span class="dv">1</span>])&lt;<span class="dv">2</span>*i)l++; f[i]=f[q[l]]+((ll)i-q[l])*(i-q[l]-<span class="dv">1</span>)/<span class="dv">2</span>+c[i];</span>
<span id="cb37-22"><a href="#cb37-22"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[r-<span class="dv">1</span>],q[r])&gt;calc(q[r],i))r--; q[++r]=i;</span>
<span id="cb37-23"><a href="#cb37-23"></a>    }</span>
<span id="cb37-24"><a href="#cb37-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f[n]);</span>
<span id="cb37-25"><a href="#cb37-25"></a>}</span></code></pre></div>
<h3 id="bzoj3673可持久化并查集-by-zkybzoj3674可持久化并查集加强版2016.6.23">bzoj3673可持久化并查集 by zky&amp;bzoj3674可持久化并查集加强版（2016.6.23）</h3>
<h4 id="题意-37">题意</h4>
<p>维护可以恢复到第k次操作后的并查集。</p>
<h4 id="题解-37">题解</h4>
<p>用可持久化线段树维护并查集的fa数组和秩（在并查集里的深度），不能路径压缩所以用按秩启发式合并，可以使合并均摊复杂度为O(nlog2n)。可持久化线段树实际上就是在更新节点时按主席树的插入方式新建一条路径（其实主席树就是可持久化权值线段树）。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="pp">#define maxn </span><span class="dv">30000</span></span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb38-7"><a href="#cb38-7"></a></span>
<span id="cb38-8"><a href="#cb38-8"></a><span class="dt">int</span> fa[maxn*<span class="dv">15</span>],ch[maxn*<span class="dv">15</span>][<span class="dv">2</span>],dep[maxn*<span class="dv">15</span>],pos[maxn*<span class="dv">15</span>],sz,n,m,rt[maxn];</span>
<span id="cb38-9"><a href="#cb38-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb38-10"><a href="#cb38-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb38-11"><a href="#cb38-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb38-12"><a href="#cb38-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb38-13"><a href="#cb38-13"></a>}</span>
<span id="cb38-14"><a href="#cb38-14"></a><span class="dt">void</span> build(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb38-15"><a href="#cb38-15"></a>    x=++sz; <span class="cf">if</span>(l==r){fa[x]=l; dep[x]=<span class="dv">1</span>; pos[x]=l; <span class="cf">return</span>;}</span>
<span id="cb38-16"><a href="#cb38-16"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; build(ch[x][<span class="dv">0</span>],l,mid); build(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r);</span>
<span id="cb38-17"><a href="#cb38-17"></a>}</span>
<span id="cb38-18"><a href="#cb38-18"></a><span class="dt">void</span> updatefa(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> a,<span class="dt">int</span> b){</span>
<span id="cb38-19"><a href="#cb38-19"></a>    sz++; fa[sz]=fa[x]; dep[sz]=dep[x]; pos[sz]=pos[x]; ch[sz][<span class="dv">0</span>]=ch[x][<span class="dv">0</span>]; ch[sz][<span class="dv">1</span>]=ch[x][<span class="dv">1</span>];</span>
<span id="cb38-20"><a href="#cb38-20"></a>    x=sz; <span class="cf">if</span>(l==r){fa[x]=b; <span class="cf">return</span>;}</span>
<span id="cb38-21"><a href="#cb38-21"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(a&lt;=mid)updatefa(ch[x][<span class="dv">0</span>],l,mid,a,b);<span class="cf">else</span> updatefa(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r,a,b);</span>
<span id="cb38-22"><a href="#cb38-22"></a>}</span>
<span id="cb38-23"><a href="#cb38-23"></a><span class="dt">void</span> updatedep(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> a,<span class="dt">int</span> b){</span>
<span id="cb38-24"><a href="#cb38-24"></a>    sz++; fa[sz]=fa[x]; dep[sz]=dep[x]; pos[sz]=pos[x]; ch[sz][<span class="dv">0</span>]=ch[x][<span class="dv">0</span>]; ch[sz][<span class="dv">1</span>]=ch[x][<span class="dv">1</span>];</span>
<span id="cb38-25"><a href="#cb38-25"></a>    x=sz; <span class="cf">if</span>(l==r){dep[x]=b; <span class="cf">return</span>;}</span>
<span id="cb38-26"><a href="#cb38-26"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(a&lt;=mid)updatedep(ch[x][<span class="dv">0</span>],l,mid,a,b);<span class="cf">else</span> updatedep(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r,a,b);</span>
<span id="cb38-27"><a href="#cb38-27"></a>}</span>
<span id="cb38-28"><a href="#cb38-28"></a><span class="dt">int</span> query(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> a){</span>
<span id="cb38-29"><a href="#cb38-29"></a>    <span class="cf">if</span>(l==r)<span class="cf">return</span> x; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb38-30"><a href="#cb38-30"></a>    <span class="cf">if</span>(a&lt;=mid)<span class="cf">return</span> query(ch[x][<span class="dv">0</span>],l,mid,a);<span class="cf">else</span> <span class="cf">return</span> query(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r,a);</span>
<span id="cb38-31"><a href="#cb38-31"></a>}</span>
<span id="cb38-32"><a href="#cb38-32"></a><span class="dt">int</span> find(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb38-33"><a href="#cb38-33"></a>    <span class="dt">int</span> z=query(x,<span class="dv">1</span>,n,y); <span class="cf">if</span>(fa[z]==pos[z])<span class="cf">return</span> z;<span class="cf">else</span> <span class="cf">return</span> find(x,fa[z]);</span>
<span id="cb38-34"><a href="#cb38-34"></a>}</span>
<span id="cb38-35"><a href="#cb38-35"></a><span class="dt">void</span> merge(<span class="dt">int</span> &amp;s,<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb38-36"><a href="#cb38-36"></a>    <span class="dt">int</span> z1=find(s,x),z2=find(s,y); <span class="cf">if</span>(pos[z1]==pos[z2])<span class="cf">return</span>; <span class="cf">if</span>(dep[z1]&gt;dep[z2])swap(z1,z2);</span>
<span id="cb38-37"><a href="#cb38-37"></a>    <span class="dt">int</span> abc=max(dep[z2],dep[z1]+<span class="dv">1</span>); updatefa(s,<span class="dv">1</span>,n,pos[z1],pos[z2]); updatedep(s,<span class="dv">1</span>,n,pos[z2],abc);</span>
<span id="cb38-38"><a href="#cb38-38"></a>}</span>
<span id="cb38-39"><a href="#cb38-39"></a><span class="dt">int</span> main(){</span>
<span id="cb38-40"><a href="#cb38-40"></a>    n=read(); m=read(); build(rt[<span class="dv">0</span>],<span class="dv">1</span>,n);</span>
<span id="cb38-41"><a href="#cb38-41"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb38-42"><a href="#cb38-42"></a>        <span class="dt">int</span> opt=read();</span>
<span id="cb38-43"><a href="#cb38-43"></a>        <span class="cf">if</span>(opt==<span class="dv">1</span>){<span class="dt">int</span> a=read(),b=read(); rt[i]=rt[i-<span class="dv">1</span>]; merge(rt[i],a,b);}</span>
<span id="cb38-44"><a href="#cb38-44"></a>        <span class="cf">if</span>(opt==<span class="dv">2</span>){<span class="dt">int</span> k=read(); rt[i]=rt[k];}</span>
<span id="cb38-45"><a href="#cb38-45"></a>        <span class="cf">if</span>(opt==<span class="dv">3</span>){</span>
<span id="cb38-46"><a href="#cb38-46"></a>            <span class="dt">int</span> a=read(),b=read(); rt[i]=rt[i-<span class="dv">1</span>];</span>
<span id="cb38-47"><a href="#cb38-47"></a>            <span class="cf">if</span>(pos[find(rt[i],a)]==pos[find(rt[i],b)])puts(<span class="st">&quot;1&quot;</span>);<span class="cf">else</span> puts(<span class="st">&quot;0&quot;</span>);</span>
<span id="cb38-48"><a href="#cb38-48"></a>        }</span>
<span id="cb38-49"><a href="#cb38-49"></a>    }</span>
<span id="cb38-50"><a href="#cb38-50"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb38-51"><a href="#cb38-51"></a>}</span></code></pre></div>
<h4 id="题意-38">题意</h4>
<p>同bzoj3673，但强制在线且点数操作数≤200000</p>
<h4 id="题解-38">题解</h4>
<p>T个不停，后来看黄学长博客把数组n*2(log2n)开成结果A了，后来突然明白我fa数组和dep数组是分开维护的，也就是说每次操作新建了两条路径，当然要*2，QAQ~</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="pp">#define maxn </span><span class="dv">200010</span></span>
<span id="cb39-5"><a href="#cb39-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb39-6"><a href="#cb39-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb39-7"><a href="#cb39-7"></a></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="dt">int</span> fa[maxn*<span class="dv">50</span>],ch[maxn*<span class="dv">50</span>][<span class="dv">2</span>],dep[maxn*<span class="dv">50</span>],pos[maxn*<span class="dv">50</span>],sz,n,m,rt[maxn];</span>
<span id="cb39-9"><a href="#cb39-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb39-10"><a href="#cb39-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb39-11"><a href="#cb39-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb39-12"><a href="#cb39-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb39-13"><a href="#cb39-13"></a>}</span>
<span id="cb39-14"><a href="#cb39-14"></a><span class="dt">void</span> build(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb39-15"><a href="#cb39-15"></a>    x=++sz; <span class="cf">if</span>(l==r){fa[x]=l; dep[x]=<span class="dv">1</span>; pos[x]=l; <span class="cf">return</span>;}</span>
<span id="cb39-16"><a href="#cb39-16"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; build(ch[x][<span class="dv">0</span>],l,mid); build(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r);</span>
<span id="cb39-17"><a href="#cb39-17"></a>}</span>
<span id="cb39-18"><a href="#cb39-18"></a><span class="dt">void</span> updatefa(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> a,<span class="dt">int</span> b){</span>
<span id="cb39-19"><a href="#cb39-19"></a>    sz++; fa[sz]=fa[x]; dep[sz]=dep[x]; pos[sz]=pos[x]; ch[sz][<span class="dv">0</span>]=ch[x][<span class="dv">0</span>]; ch[sz][<span class="dv">1</span>]=ch[x][<span class="dv">1</span>];</span>
<span id="cb39-20"><a href="#cb39-20"></a>    x=sz; <span class="cf">if</span>(l==r){fa[x]=b; <span class="cf">return</span>;}</span>
<span id="cb39-21"><a href="#cb39-21"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(a&lt;=mid)updatefa(ch[x][<span class="dv">0</span>],l,mid,a,b);<span class="cf">else</span> updatefa(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r,a,b);</span>
<span id="cb39-22"><a href="#cb39-22"></a>}</span>
<span id="cb39-23"><a href="#cb39-23"></a><span class="dt">void</span> updatedep(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> a,<span class="dt">int</span> b){</span>
<span id="cb39-24"><a href="#cb39-24"></a>    sz++; fa[sz]=fa[x]; dep[sz]=dep[x]; pos[sz]=pos[x]; ch[sz][<span class="dv">0</span>]=ch[x][<span class="dv">0</span>]; ch[sz][<span class="dv">1</span>]=ch[x][<span class="dv">1</span>];</span>
<span id="cb39-25"><a href="#cb39-25"></a>    x=sz; <span class="cf">if</span>(l==r){dep[x]=b; <span class="cf">return</span>;}</span>
<span id="cb39-26"><a href="#cb39-26"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(a&lt;=mid)updatedep(ch[x][<span class="dv">0</span>],l,mid,a,b);<span class="cf">else</span> updatedep(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r,a,b);</span>
<span id="cb39-27"><a href="#cb39-27"></a>}</span>
<span id="cb39-28"><a href="#cb39-28"></a><span class="dt">int</span> query(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> a){</span>
<span id="cb39-29"><a href="#cb39-29"></a>    <span class="cf">if</span>(l==r)<span class="cf">return</span> x; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb39-30"><a href="#cb39-30"></a>    <span class="cf">if</span>(a&lt;=mid)<span class="cf">return</span> query(ch[x][<span class="dv">0</span>],l,mid,a);<span class="cf">else</span> <span class="cf">return</span> query(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r,a);</span>
<span id="cb39-31"><a href="#cb39-31"></a>}</span>
<span id="cb39-32"><a href="#cb39-32"></a><span class="dt">int</span> find(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb39-33"><a href="#cb39-33"></a>    <span class="dt">int</span> z=query(x,<span class="dv">1</span>,n,y); <span class="cf">if</span>(fa[z]==pos[z])<span class="cf">return</span> z;<span class="cf">else</span> <span class="cf">return</span> find(x,fa[z]);</span>
<span id="cb39-34"><a href="#cb39-34"></a>}</span>
<span id="cb39-35"><a href="#cb39-35"></a><span class="dt">void</span> merge(<span class="dt">int</span> &amp;s,<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb39-36"><a href="#cb39-36"></a>    <span class="dt">int</span> z1=find(s,x),z2=find(s,y); <span class="cf">if</span>(pos[z1]==pos[z2])<span class="cf">return</span>; <span class="cf">if</span>(dep[z1]&gt;dep[z2])swap(z1,z2);</span>
<span id="cb39-37"><a href="#cb39-37"></a>    <span class="dt">int</span> abc=max(dep[z2],dep[z1]+<span class="dv">1</span>); updatefa(s,<span class="dv">1</span>,n,pos[z1],pos[z2]); updatedep(s,<span class="dv">1</span>,n,pos[z2],abc);</span>
<span id="cb39-38"><a href="#cb39-38"></a>}</span>
<span id="cb39-39"><a href="#cb39-39"></a><span class="dt">int</span> main(){</span>
<span id="cb39-40"><a href="#cb39-40"></a>    n=read(); m=read(); build(rt[<span class="dv">0</span>],<span class="dv">1</span>,n); <span class="dt">int</span> last=<span class="dv">0</span>;</span>
<span id="cb39-41"><a href="#cb39-41"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb39-42"><a href="#cb39-42"></a>        <span class="dt">int</span> opt=read();</span>
<span id="cb39-43"><a href="#cb39-43"></a>        <span class="cf">if</span>(opt==<span class="dv">1</span>){<span class="dt">int</span> a=read()^last,b=read()^last; rt[i]=rt[i-<span class="dv">1</span>]; merge(rt[i],a,b);}</span>
<span id="cb39-44"><a href="#cb39-44"></a>        <span class="cf">if</span>(opt==<span class="dv">2</span>){<span class="dt">int</span> k=read()^last; rt[i]=rt[k];}</span>
<span id="cb39-45"><a href="#cb39-45"></a>        <span class="cf">if</span>(opt==<span class="dv">3</span>){</span>
<span id="cb39-46"><a href="#cb39-46"></a>            <span class="dt">int</span> a=read()^last,b=read()^last; rt[i]=rt[i-<span class="dv">1</span>];</span>
<span id="cb39-47"><a href="#cb39-47"></a>            <span class="cf">if</span>(pos[find(rt[i],a)]==pos[find(rt[i],b)])puts(<span class="st">&quot;1&quot;</span>),last=<span class="dv">1</span>;<span class="cf">else</span> puts(<span class="st">&quot;0&quot;</span>),last=<span class="dv">0</span>;</span>
<span id="cb39-48"><a href="#cb39-48"></a>        }</span>
<span id="cb39-49"><a href="#cb39-49"></a>    }</span>
<span id="cb39-50"><a href="#cb39-50"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb39-51"><a href="#cb39-51"></a>}</span></code></pre></div>
<h3 id="bzoj2563阿狸和桃子的游戏2016.6.23">bzoj2563阿狸和桃子的游戏（2016.6.23）</h3>
<h4 id="题意-39">题意</h4>
<p>一个n（偶数）点图，节点权值为w(v)，边权为c(e)。两人轮流将图中的顶点染色，已经被染过色的点不能再染了，而且每一轮都必须给一个且仅一个顶点染色。染完后每个人的分数为染过的点权和以及两个端点都被染的边权和。如果两人都是采用最优策略的，求最终第一个人的分数减去第二个人的分数。n≤10000，边数≤100000</p>
<h4 id="题解-39">题解</h4>
<p>本弱只能引用神犇的题解</p>
<blockquote>
<p>考虑先手选择每个点对答案的影响 一个点如果不选，本身对答案的贡献是-w，一个点如果选，本身对答案的贡献是w，一条边如果两个端点都不选，对答案的贡献是-c，如果两个端点中只选择一个，对答案的贡献是0，如果两个端点都选，对答案的贡献是c，那么我们先预先把所有的权值都在初始答案中减掉，然后就变成了： 一个点如果不选，本身对答案的贡献是0，一个点如果选，本身对答案的贡献是2*w，一条边如果两个端点都不选，对答案的贡献是0，如果两个端点中只选择一个，对答案的贡献是c，如果两个端点都选，对答案的贡献是2*c，那么令一个点的贡献值为本身点权的二倍+所有相连的边的边权，排个序两人轮流取最大即可。</p>
</blockquote>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb40-7"><a href="#cb40-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb40-8"><a href="#cb40-8"></a></span>
<span id="cb40-9"><a href="#cb40-9"></a><span class="dt">int</span> n,m; ll w[maxn],ans1,ans2;</span>
<span id="cb40-10"><a href="#cb40-10"></a><span class="dt">bool</span> cmp(ll a,ll b){<span class="cf">return</span> a&gt;b;}</span>
<span id="cb40-11"><a href="#cb40-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb40-12"><a href="#cb40-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb40-13"><a href="#cb40-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb40-14"><a href="#cb40-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb40-15"><a href="#cb40-15"></a>}</span>
<span id="cb40-16"><a href="#cb40-16"></a><span class="dt">int</span> main(){</span>
<span id="cb40-17"><a href="#cb40-17"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)w[i]=(ll)read()&lt;&lt;<span class="dv">1</span>,ans2+=w[i]&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb40-18"><a href="#cb40-18"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(); ll c=(ll)read(); ans2+=c; w[a]+=c; w[b]+=c;} sort(w+<span class="dv">1</span>,w+n+<span class="dv">1</span>,cmp);</span>
<span id="cb40-19"><a href="#cb40-19"></a>    inc(i,<span class="dv">1</span>,n){<span class="cf">if</span>(i&amp;<span class="dv">1</span>)ans1+=w[i];}</span>
<span id="cb40-20"><a href="#cb40-20"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans1-ans2); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb40-21"><a href="#cb40-21"></a>}</span></code></pre></div>
<h3 id="bzoj4384poi2015trzy-wieże2016.6.27">bzoj4384[POI2015]Trzy wieże（2016.6.27）</h3>
<h4 id="题意-40">题意</h4>
<p>给定一个长度为n的仅包含’B’、‘C’、’S’三种字符的字符串，请找到最长的一段连续子串，使得这一段要么只有一种字符，要么有多种字符，但是没有任意两种字符出现次数相同。</p>
<h4 id="题解-40">题解</h4>
<p>恶心的树状数组题。首先先求出只有一种字符的最长字串。然后预处理出前缀和。题目要求满足</p>
<p>cnt[1][i]-cnt[1][j]!=cnt[2][i]-cnt[2][j] cnt[2][i]-cnt[2][j]!=cnt[3][i]-cnt[3][j] cnt[1][i]-cnt[1][j]!=cnt[3][i]-cnt[3][j]</p>
<p>化简得到cnt[1][i]-cnt[2][i]!=cnt[1][j]-cnt[2][j] cnt[2][i]-cnt[3][i]!=cnt[2][j]-cnt[3][j] cnt[1][i]-cnt[3][i]!=cnt[1][j]-cnt[3][j]</p>
<p>把cnt[1][i]-cnt[2][i],cnt[2][i]-cnt[3][i],cnt[1][i]-cnt[3][i]分别当成xi,yi,zi，题目就转化成对每个i，求一个j使它们的xyz不同且i与j相差最大。首先以x为关键字排序，接着以y（离散化除掉负数，用链表法，如果用排序法会T）为下标建树状数组，树状数组维护6个值：之前处理过的位置的最大最小值、最大最小值对应的z，与最大最小值的z不同的最大最小值。为什么要维护最小值呢？因为按x排序后位置先后顺序会不一样，可能会出现位置靠后的比位置靠前先处理的情况。使x不同的具体方法，就是对于x相同的一组位置，先对它们一起分别查询更新答案，更新答案完后再一起分别插入树状数组。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb41-5"><a href="#cb41-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb41-6"><a href="#cb41-6"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb41-7"><a href="#cb41-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb41-8"><a href="#cb41-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb41-9"><a href="#cb41-9"></a></span>
<span id="cb41-10"><a href="#cb41-10"></a><span class="kw">struct</span> nd{<span class="dt">int</span> id,cnt[<span class="dv">3</span>];}; nd nds[maxn]; <span class="kw">struct</span> e{<span class="dt">int</span> v,n;}; <span class="dt">int</span> ess,g[maxn&lt;&lt;<span class="dv">1</span>]; e es[maxn];</span>
<span id="cb41-11"><a href="#cb41-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> a,<span class="dt">int</span> b){es[++ess]=(e){a,g[b]}; g[b]=ess;}</span>
<span id="cb41-12"><a href="#cb41-12"></a><span class="dt">int</span> ans,n,tot; <span class="dt">char</span> s[maxn];</span>
<span id="cb41-13"><a href="#cb41-13"></a><span class="kw">struct</span> bit{<span class="dt">int</span> mn1,mnz,mn2,mx1,mxz,mx2;}; bit bits1[maxn],bits2[maxn];</span>
<span id="cb41-14"><a href="#cb41-14"></a><span class="dt">bool</span> cmp1(nd a,nd b){<span class="cf">return</span> a.cnt[<span class="dv">0</span>]&lt;b.cnt[<span class="dv">0</span>];}</span>
<span id="cb41-15"><a href="#cb41-15"></a><span class="dt">void</span> query1(nd a){</span>
<span id="cb41-16"><a href="#cb41-16"></a>    <span class="dt">int</span> b=a.cnt[<span class="dv">1</span>]-<span class="dv">1</span>;</span>
<span id="cb41-17"><a href="#cb41-17"></a>    <span class="cf">while</span>(b){</span>
<span id="cb41-18"><a href="#cb41-18"></a>        <span class="cf">if</span>(bits1[b].mnz==a.cnt[<span class="dv">2</span>]){</span>
<span id="cb41-19"><a href="#cb41-19"></a>            <span class="cf">if</span>(bits1[b].mn2!=INF)ans=max(ans,a.id-bits1[b].mn2);</span>
<span id="cb41-20"><a href="#cb41-20"></a>        }<span class="cf">else</span> <span class="cf">if</span>(bits1[b].mn1!=INF)ans=max(ans,a.id-bits1[b].mn1);</span>
<span id="cb41-21"><a href="#cb41-21"></a>        <span class="cf">if</span>(bits1[b].mxz==a.cnt[<span class="dv">2</span>]){</span>
<span id="cb41-22"><a href="#cb41-22"></a>            <span class="cf">if</span>(bits1[b].mx2!=<span class="dv">0</span>)ans=max(ans,bits1[b].mx2-a.id);</span>
<span id="cb41-23"><a href="#cb41-23"></a>        }<span class="cf">else</span> <span class="cf">if</span>(bits1[b].mx1!=<span class="dv">0</span>)ans=max(ans,bits1[b].mx1-a.id);</span>
<span id="cb41-24"><a href="#cb41-24"></a>        b-=lb(b);</span>
<span id="cb41-25"><a href="#cb41-25"></a>    }</span>
<span id="cb41-26"><a href="#cb41-26"></a>}</span>
<span id="cb41-27"><a href="#cb41-27"></a><span class="dt">void</span> query2(nd a){</span>
<span id="cb41-28"><a href="#cb41-28"></a>    <span class="dt">int</span> b=a.cnt[<span class="dv">1</span>]+<span class="dv">1</span>;</span>
<span id="cb41-29"><a href="#cb41-29"></a>    <span class="cf">while</span>(b&lt;=tot){</span>
<span id="cb41-30"><a href="#cb41-30"></a>        <span class="cf">if</span>(bits2[b].mnz==a.cnt[<span class="dv">2</span>]){</span>
<span id="cb41-31"><a href="#cb41-31"></a>            <span class="cf">if</span>(bits1[b].mn2!=INF)ans=max(ans,a.id-bits2[b].mn2);</span>
<span id="cb41-32"><a href="#cb41-32"></a>        }<span class="cf">else</span> <span class="cf">if</span>(bits2[b].mn1!=INF)ans=max(ans,a.id-bits2[b].mn1);</span>
<span id="cb41-33"><a href="#cb41-33"></a>        <span class="cf">if</span>(bits2[b].mxz==a.cnt[<span class="dv">2</span>]){</span>
<span id="cb41-34"><a href="#cb41-34"></a>            <span class="cf">if</span>(bits1[b].mx2!=<span class="dv">0</span>)ans=max(ans,bits2[b].mx2-a.id);</span>
<span id="cb41-35"><a href="#cb41-35"></a>        }<span class="cf">else</span> <span class="cf">if</span>(bits2[b].mx1!=<span class="dv">0</span>)ans=max(ans,bits2[b].mx1-a.id);</span>
<span id="cb41-36"><a href="#cb41-36"></a>        b+=lb(b);</span>
<span id="cb41-37"><a href="#cb41-37"></a>    }</span>
<span id="cb41-38"><a href="#cb41-38"></a>}</span>
<span id="cb41-39"><a href="#cb41-39"></a><span class="dt">void</span> update1(nd a){</span>
<span id="cb41-40"><a href="#cb41-40"></a>    <span class="dt">int</span> b=a.cnt[<span class="dv">1</span>];</span>
<span id="cb41-41"><a href="#cb41-41"></a>    <span class="cf">while</span>(b&lt;=tot){</span>
<span id="cb41-42"><a href="#cb41-42"></a>        <span class="cf">if</span>(a.id&lt;bits1[b].mn1){</span>
<span id="cb41-43"><a href="#cb41-43"></a>            <span class="cf">if</span>(a.cnt[<span class="dv">2</span>]!=bits1[b].mnz)</span>
<span id="cb41-44"><a href="#cb41-44"></a>                bits1[b].mnz=a.cnt[<span class="dv">2</span>],bits1[b].mn2=bits1[b].mn1,bits1[b].mn1=a.id;</span>
<span id="cb41-45"><a href="#cb41-45"></a>            <span class="cf">else</span> bits1[b].mn1=a.id;</span>
<span id="cb41-46"><a href="#cb41-46"></a>        }<span class="cf">else</span> <span class="cf">if</span>(a.cnt[<span class="dv">2</span>]!=bits1[b].mnz&amp;&amp;a.id&lt;bits1[b].mn2)bits1[b].mn2=a.id;</span>
<span id="cb41-47"><a href="#cb41-47"></a>        <span class="cf">if</span>(a.id&gt;bits1[b].mx1){</span>
<span id="cb41-48"><a href="#cb41-48"></a>            <span class="cf">if</span>(a.cnt[<span class="dv">2</span>]!=bits1[b].mxz)</span>
<span id="cb41-49"><a href="#cb41-49"></a>                bits1[b].mxz=a.cnt[<span class="dv">2</span>],bits1[b].mx2=bits1[b].mx1,bits1[b].mx1=a.id;</span>
<span id="cb41-50"><a href="#cb41-50"></a>            <span class="cf">else</span> bits1[b].mx1=a.id;</span>
<span id="cb41-51"><a href="#cb41-51"></a>        }<span class="cf">else</span> <span class="cf">if</span>(a.cnt[<span class="dv">2</span>]!=bits1[b].mxz&amp;&amp;a.id&gt;bits1[b].mx2)bits1[b].mx2=a.id;</span>
<span id="cb41-52"><a href="#cb41-52"></a>        b+=lb(b);</span>
<span id="cb41-53"><a href="#cb41-53"></a>    }</span>
<span id="cb41-54"><a href="#cb41-54"></a>}</span>
<span id="cb41-55"><a href="#cb41-55"></a><span class="dt">void</span> update2(nd a){</span>
<span id="cb41-56"><a href="#cb41-56"></a>    <span class="dt">int</span> b=a.cnt[<span class="dv">1</span>];</span>
<span id="cb41-57"><a href="#cb41-57"></a>    <span class="cf">while</span>(b){</span>
<span id="cb41-58"><a href="#cb41-58"></a>        <span class="cf">if</span>(a.id&lt;bits2[b].mn1){</span>
<span id="cb41-59"><a href="#cb41-59"></a>            <span class="cf">if</span>(a.cnt[<span class="dv">2</span>]!=bits2[b].mnz)</span>
<span id="cb41-60"><a href="#cb41-60"></a>                bits2[b].mnz=a.cnt[<span class="dv">2</span>],bits2[b].mn2=bits2[b].mn1,bits2[b].mn1=a.id;</span>
<span id="cb41-61"><a href="#cb41-61"></a>            <span class="cf">else</span> bits2[b].mn1=a.id;</span>
<span id="cb41-62"><a href="#cb41-62"></a>        }<span class="cf">else</span> <span class="cf">if</span>(a.cnt[<span class="dv">2</span>]!=bits2[b].mnz&amp;&amp;a.id&lt;bits2[b].mn2)bits2[b].mn2=a.id;</span>
<span id="cb41-63"><a href="#cb41-63"></a>        <span class="cf">if</span>(a.id&gt;bits2[b].mx1){</span>
<span id="cb41-64"><a href="#cb41-64"></a>            <span class="cf">if</span>(a.cnt[<span class="dv">2</span>]!=bits2[b].mxz)</span>
<span id="cb41-65"><a href="#cb41-65"></a>                bits2[b].mxz=a.cnt[<span class="dv">2</span>],bits2[b].mx2=bits2[b].mx1,bits2[b].mx1=a.id;</span>
<span id="cb41-66"><a href="#cb41-66"></a>            <span class="cf">else</span> bits2[b].mx1=a.id;</span>
<span id="cb41-67"><a href="#cb41-67"></a>        }<span class="cf">else</span> <span class="cf">if</span>(a.cnt[<span class="dv">2</span>]!=bits2[b].mxz&amp;&amp;a.id&gt;bits2[b].mx2)bits2[b].mx2=a.id;</span>
<span id="cb41-68"><a href="#cb41-68"></a>        b-=lb(b);</span>
<span id="cb41-69"><a href="#cb41-69"></a>    }</span>
<span id="cb41-70"><a href="#cb41-70"></a>}</span>
<span id="cb41-71"><a href="#cb41-71"></a><span class="dt">int</span> main(){</span>
<span id="cb41-72"><a href="#cb41-72"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>); <span class="dt">int</span> cnt[<span class="dv">3</span>]={<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>};</span>
<span id="cb41-73"><a href="#cb41-73"></a>    <span class="dt">int</span> l=<span class="dv">1</span>,r=<span class="dv">1</span>; <span class="cf">while</span>(r&lt;=n){<span class="cf">while</span>(r&lt;=n&amp;&amp;s[l]==s[r])ans=max(ans,r-l+<span class="dv">1</span>),r++; l++;}</span>
<span id="cb41-74"><a href="#cb41-74"></a>    nds[<span class="dv">0</span>]=(nd){<span class="dv">0</span>,{<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}};</span>
<span id="cb41-75"><a href="#cb41-75"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb41-76"><a href="#cb41-76"></a>        <span class="cf">if</span>(s[i]==<span class="ch">&#39;B&#39;</span>)cnt[<span class="dv">0</span>]++; <span class="cf">if</span>(s[i]==<span class="ch">&#39;C&#39;</span>)cnt[<span class="dv">1</span>]++; <span class="cf">if</span>(s[i]==<span class="ch">&#39;S&#39;</span>)cnt[<span class="dv">2</span>]++;</span>
<span id="cb41-77"><a href="#cb41-77"></a>        nds[i]=(nd){i,{cnt[<span class="dv">0</span>]-cnt[<span class="dv">1</span>],cnt[<span class="dv">0</span>]-cnt[<span class="dv">2</span>],cnt[<span class="dv">1</span>]-cnt[<span class="dv">2</span>]}};</span>
<span id="cb41-78"><a href="#cb41-78"></a>    }</span>
<span id="cb41-79"><a href="#cb41-79"></a>    ess=<span class="dv">0</span>; inc(i,<span class="dv">0</span>,n)pe(i,nds[i].cnt[<span class="dv">1</span>]+n+<span class="dv">1</span>); tot=<span class="dv">0</span>;</span>
<span id="cb41-80"><a href="#cb41-80"></a>    inc(i,<span class="dv">0</span>,n*<span class="dv">2</span>+<span class="dv">1</span>)<span class="cf">if</span>(g[i]){</span>
<span id="cb41-81"><a href="#cb41-81"></a>        tot++; <span class="dt">int</span> x=g[i]; <span class="cf">while</span>(x)nds[es[x].v].cnt[<span class="dv">1</span>]=tot,x=es[x].n;</span>
<span id="cb41-82"><a href="#cb41-82"></a>    }</span>
<span id="cb41-83"><a href="#cb41-83"></a>    inc(i,<span class="dv">1</span>,tot)bits1[i]=bits2[i]=(bit){INF,<span class="dv">0</span>,INF,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}; sort(nds,nds+n+<span class="dv">1</span>,cmp1); <span class="dt">int</span> i=<span class="dv">0</span>;</span>
<span id="cb41-84"><a href="#cb41-84"></a>    <span class="cf">while</span>(i&lt;=n){</span>
<span id="cb41-85"><a href="#cb41-85"></a>        <span class="dt">int</span> j=i; <span class="cf">while</span>(j&lt;=n&amp;&amp;nds[j].cnt[<span class="dv">0</span>]==nds[i].cnt[<span class="dv">0</span>])j++;</span>
<span id="cb41-86"><a href="#cb41-86"></a>        <span class="cf">if</span>(i)inc(k,i,j-<span class="dv">1</span>){query1(nds[k]); query2(nds[k]);}</span>
<span id="cb41-87"><a href="#cb41-87"></a>        inc(k,i,j-<span class="dv">1</span>){update1(nds[k]); update2(nds[k]);}</span>
<span id="cb41-88"><a href="#cb41-88"></a>        i=j;</span>
<span id="cb41-89"><a href="#cb41-89"></a>    }</span>
<span id="cb41-90"><a href="#cb41-90"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb41-91"><a href="#cb41-91"></a>}</span></code></pre></div>
<h3 id="bzoj1067scoi2007降雨量2016.6.28">bzoj1067[SCOI2007]降雨量（2016.6.28）</h3>
<h4 id="题意-41">题意</h4>
<p>“X年是自Y年以来降雨量最多的”。它的含义是X年的降雨量不超过Y年，且对于任意Y＜Z＜X，Z年的降雨量严格小于X年。由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。要求对于一个说法判断它是对、错、有可能。（即使有降雨量未知也有可能可以推出说法错误，具体看题解）信息数≤50000，询问数≤100000</p>
<h4 id="题解-41">题解</h4>
<p>本题坑点非常多。设i年&lt;j年，要分为很多种情况：</p>
<ul>
<li>i，j均未知输出可能；</li>
<li>i知j未知，因为j最大可以和i相等，所以如果i到j之间有大于i的需输出错，否则输出可能；</li>
<li>i未知j知，如果i到j之间有大于j的输出错否则输出可能；</li>
<li>i知j知如果i到j中已知的大于j或j的信息大于i，则输出错，如果没有大于j的且i到j所有年份已知输出可能，否则输出对。</li>
</ul>
<p>具体实现我用的是二分查年份+线段树查最大值。我在二分查询年份位置时没有处理好边界问题导致re了好多发QAQ~</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb42-4"><a href="#cb42-4"></a><span class="pp">#define maxn </span><span class="dv">100000</span></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb42-8"><a href="#cb42-8"></a></span>
<span id="cb42-9"><a href="#cb42-9"></a><span class="dt">int</span> x[maxn],y[maxn],mx[maxn*<span class="dv">2</span>],n,m,mnn;</span>
<span id="cb42-10"><a href="#cb42-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb42-11"><a href="#cb42-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb42-12"><a href="#cb42-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb42-13"><a href="#cb42-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb42-14"><a href="#cb42-14"></a>}</span>
<span id="cb42-15"><a href="#cb42-15"></a><span class="dt">void</span> build(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb42-16"><a href="#cb42-16"></a>    <span class="cf">if</span>(l==r){mx[x]=y[l]; <span class="cf">return</span>;} <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb42-17"><a href="#cb42-17"></a>    build(x&lt;&lt;<span class="dv">1</span>,l,mid); build(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r); mx[x]=max(mx[x&lt;&lt;<span class="dv">1</span>],mx[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]);</span>
<span id="cb42-18"><a href="#cb42-18"></a>}</span>
<span id="cb42-19"><a href="#cb42-19"></a><span class="dt">int</span> query(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb42-20"><a href="#cb42-20"></a>    <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="cf">return</span> mx[x]; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>,q=<span class="dv">0</span>;</span>
<span id="cb42-21"><a href="#cb42-21"></a>    <span class="cf">if</span>(ql&lt;=mid)q=max(q,query(x&lt;&lt;<span class="dv">1</span>,l,mid,ql,qr)); <span class="cf">if</span>(qr&gt;mid)q=max(q,query(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r,ql,qr));</span>
<span id="cb42-22"><a href="#cb42-22"></a>    <span class="cf">return</span> q;</span>
<span id="cb42-23"><a href="#cb42-23"></a>}</span>
<span id="cb42-24"><a href="#cb42-24"></a><span class="dt">int</span> find(<span class="dt">int</span> y,<span class="dt">bool</span> a){</span>
<span id="cb42-25"><a href="#cb42-25"></a>    <span class="dt">int</span> l=<span class="dv">1</span>,r=n;</span>
<span id="cb42-26"><a href="#cb42-26"></a>    <span class="cf">if</span>(a){</span>
<span id="cb42-27"><a href="#cb42-27"></a>        <span class="cf">while</span>(l&lt;r){</span>
<span id="cb42-28"><a href="#cb42-28"></a>            <span class="dt">int</span> mid=l+((r-l)&gt;&gt;<span class="dv">1</span>); <span class="cf">if</span>(y&lt;=x[mid])r=mid;<span class="cf">else</span> l=mid+<span class="dv">1</span>;</span>
<span id="cb42-29"><a href="#cb42-29"></a>        }</span>
<span id="cb42-30"><a href="#cb42-30"></a>    }<span class="cf">else</span>{</span>
<span id="cb42-31"><a href="#cb42-31"></a>        <span class="cf">while</span>(l&lt;r){</span>
<span id="cb42-32"><a href="#cb42-32"></a>            <span class="dt">int</span> mid=r-((r-l)&gt;&gt;<span class="dv">1</span>); <span class="cf">if</span>(y&lt;x[mid])r=mid-<span class="dv">1</span>;<span class="cf">else</span> l=mid;</span>
<span id="cb42-33"><a href="#cb42-33"></a>        }</span>
<span id="cb42-34"><a href="#cb42-34"></a>    }</span>
<span id="cb42-35"><a href="#cb42-35"></a>    <span class="cf">return</span> l;</span>
<span id="cb42-36"><a href="#cb42-36"></a>}</span>
<span id="cb42-37"><a href="#cb42-37"></a><span class="dt">int</span> main(){</span>
<span id="cb42-38"><a href="#cb42-38"></a>    n=read(); mnn=INF; inc(i,<span class="dv">1</span>,n)x[i]=read(),y[i]=read(),mnn=min(mnn,x[i]);</span>
<span id="cb42-39"><a href="#cb42-39"></a>    build(<span class="dv">1</span>,<span class="dv">1</span>,n); m=read();</span>
<span id="cb42-40"><a href="#cb42-40"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb42-41"><a href="#cb42-41"></a>        <span class="dt">int</span> a=read(),b=read(); <span class="dt">int</span> c=find(a,<span class="dv">1</span>),d=find(b,<span class="dv">1</span>);</span>
<span id="cb42-42"><a href="#cb42-42"></a>        <span class="cf">if</span>(a&gt;=b){puts(<span class="st">&quot;false&quot;</span>); <span class="cf">continue</span>;}</span>
<span id="cb42-43"><a href="#cb42-43"></a>        <span class="cf">if</span>(b!=x[d]){</span>
<span id="cb42-44"><a href="#cb42-44"></a>            <span class="cf">if</span>(a!=x[c]){puts(<span class="st">&quot;maybe&quot;</span>); <span class="cf">continue</span>;} <span class="cf">if</span>(c==n){puts(<span class="st">&quot;maybe&quot;</span>); <span class="cf">continue</span>;}</span>
<span id="cb42-45"><a href="#cb42-45"></a>            <span class="cf">if</span>(query(<span class="dv">1</span>,<span class="dv">1</span>,n,c+<span class="dv">1</span>,find(b,<span class="dv">0</span>))&gt;=y[c])puts(<span class="st">&quot;false&quot;</span>);<span class="cf">else</span> puts(<span class="st">&quot;maybe&quot;</span>); <span class="cf">continue</span>;</span>
<span id="cb42-46"><a href="#cb42-46"></a>        }</span>
<span id="cb42-47"><a href="#cb42-47"></a>        <span class="cf">if</span>(a!=x[c]){</span>
<span id="cb42-48"><a href="#cb42-48"></a>            <span class="cf">if</span>(d==<span class="dv">1</span>){puts(<span class="st">&quot;maybe&quot;</span>); <span class="cf">continue</span>;}</span>
<span id="cb42-49"><a href="#cb42-49"></a>            <span class="cf">if</span>(a&lt;mnn){</span>
<span id="cb42-50"><a href="#cb42-50"></a>                <span class="cf">if</span>(query(<span class="dv">1</span>,<span class="dv">1</span>,n,<span class="dv">1</span>,d-<span class="dv">1</span>)&gt;=y[d])puts(<span class="st">&quot;false&quot;</span>);<span class="cf">else</span> puts(<span class="st">&quot;maybe&quot;</span>);</span>
<span id="cb42-51"><a href="#cb42-51"></a>            }<span class="cf">else</span>{</span>
<span id="cb42-52"><a href="#cb42-52"></a>                <span class="cf">if</span>(query(<span class="dv">1</span>,<span class="dv">1</span>,n,find(a,<span class="dv">1</span>),d-<span class="dv">1</span>)&gt;=y[d])puts(<span class="st">&quot;false&quot;</span>);<span class="cf">else</span> puts(<span class="st">&quot;maybe&quot;</span>);</span>
<span id="cb42-53"><a href="#cb42-53"></a>            }</span>
<span id="cb42-54"><a href="#cb42-54"></a>            <span class="cf">continue</span>;</span>
<span id="cb42-55"><a href="#cb42-55"></a>        }</span>
<span id="cb42-56"><a href="#cb42-56"></a>        <span class="cf">if</span>(y[d]&gt;y[c]||query(<span class="dv">1</span>,<span class="dv">1</span>,n,c+<span class="dv">1</span>,d-<span class="dv">1</span>)&gt;=y[d])puts(<span class="st">&quot;false&quot;</span>);<span class="cf">else</span>{</span>
<span id="cb42-57"><a href="#cb42-57"></a>            <span class="cf">if</span>(d-c!=b-a)puts(<span class="st">&quot;maybe&quot;</span>);<span class="cf">else</span> puts(<span class="st">&quot;true&quot;</span>);</span>
<span id="cb42-58"><a href="#cb42-58"></a>        }</span>
<span id="cb42-59"><a href="#cb42-59"></a>    }</span>
<span id="cb42-60"><a href="#cb42-60"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb42-61"><a href="#cb42-61"></a>}</span></code></pre></div>
<h3 id="bzoj3668noi2014起床困难综合症2016.6.29">bzoj3668[Noi2014]起床困难综合症（2016.6.29）</h3>
<h4 id="题意-42">题意</h4>
<p>求0到m的一个数，使它被n次操作后最大。操作三种：&amp;t、|t、^t，t为操作中给定的数。n≤100000，m，t≤1000000000</p>
<h4 id="题解-42">题解</h4>
<p>先求出0经过n次操作后得到的数，然后对于小于等于m的每个二进制位从大到小考虑一下当这位为1时是否比0好，如果好的话令这位为1并让m减去这个二进制位。因为n次操作后为1的二进制位越大越好，所以从大到小考虑是正确的。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="pp">#define maxn </span><span class="dv">200000</span></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb43-7"><a href="#cb43-7"></a></span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb43-9"><a href="#cb43-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb43-10"><a href="#cb43-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb43-11"><a href="#cb43-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb43-12"><a href="#cb43-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb43-13"><a href="#cb43-13"></a>}</span>
<span id="cb43-14"><a href="#cb43-14"></a><span class="dt">char</span> s[<span class="dv">5</span>]; <span class="dt">int</span> opt[maxn],p[maxn],ans,n,m;</span>
<span id="cb43-15"><a href="#cb43-15"></a><span class="dt">int</span> main(){</span>
<span id="cb43-16"><a href="#cb43-16"></a>    n=read(); m=read(); ans=<span class="dv">0</span>;</span>
<span id="cb43-17"><a href="#cb43-17"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb43-18"><a href="#cb43-18"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s); <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;A&#39;</span>)opt[i]=<span class="dv">0</span>; <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;O&#39;</span>)opt[i]=<span class="dv">1</span>; <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;X&#39;</span>)opt[i]=<span class="dv">2</span>; p[i]=read();</span>
<span id="cb43-19"><a href="#cb43-19"></a>    }</span>
<span id="cb43-20"><a href="#cb43-20"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb43-21"><a href="#cb43-21"></a>        <span class="cf">if</span>(opt[i]==<span class="dv">0</span>)ans&amp;=p[i]; <span class="cf">if</span>(opt[i]==<span class="dv">1</span>)ans|=p[i]; <span class="cf">if</span>(opt[i]==<span class="dv">2</span>)ans^=p[i];</span>
<span id="cb43-22"><a href="#cb43-22"></a>    }</span>
<span id="cb43-23"><a href="#cb43-23"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">30</span>;i&gt;=<span class="dv">0</span>;i--){</span>
<span id="cb43-24"><a href="#cb43-24"></a>        <span class="dt">int</span> k=<span class="dv">1</span>&lt;&lt;i; <span class="cf">if</span>(k&gt;m)<span class="cf">continue</span>;</span>
<span id="cb43-25"><a href="#cb43-25"></a>        inc(j,<span class="dv">1</span>,n){</span>
<span id="cb43-26"><a href="#cb43-26"></a>            <span class="cf">if</span>(opt[j]==<span class="dv">0</span>)k&amp;=p[j]; <span class="cf">if</span>(opt[j]==<span class="dv">1</span>)k|=p[j]; <span class="cf">if</span>(opt[j]==<span class="dv">2</span>)k^=p[j];</span>
<span id="cb43-27"><a href="#cb43-27"></a>        }</span>
<span id="cb43-28"><a href="#cb43-28"></a>        <span class="cf">if</span>(!(ans&amp;(<span class="dv">1</span>&lt;&lt;i))&amp;&amp;(k&amp;(<span class="dv">1</span>&lt;&lt;i)))ans|=(<span class="dv">1</span>&lt;&lt;i),m-=(<span class="dv">1</span>&lt;&lt;i);</span>
<span id="cb43-29"><a href="#cb43-29"></a>    }</span>
<span id="cb43-30"><a href="#cb43-30"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);</span>
<span id="cb43-31"><a href="#cb43-31"></a>}</span></code></pre></div>
<h3 id="bzoj2463中山市选2009谁能赢呢2016.6.30">bzoj2463[中山市选2009]谁能赢呢？（2016.6.30）</h3>
<h4 id="题意-43">题意</h4>
<p>给定一个n×n的棋盘，一个石头被放在棋盘的左上角。他们轮流移动石头。每一回合，选手只能把石头向上，下，左，右四个方向移动一格，并且要求移动到的格子之前不能被访问过。谁不能移动石头了就算输。假如小明先移动石头，而且两个选手都以最优策略走步，问最后谁能赢？</p>
<h4 id="题解-43">题解</h4>
<p>对于n*n为偶数的棋盘肯定可以用二格骨牌覆盖，这样每次先手都是走骨牌的一端而后手就可以走另一端，故后手赢。对于n*n为奇数的棋盘先手走了一步剩下的棋盘就可以被覆盖了，后手面临和之前先手面临的情况一样，故先手赢。由于奇数的平方是奇数，偶数平方是偶数，所以只要对输入判断奇偶性就行了。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="dt">int</span> n;</span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="dt">int</span> main(){</span>
<span id="cb44-4"><a href="#cb44-4"></a>   <span class="cf">while</span>(<span class="dv">1</span>){scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); <span class="cf">if</span>(!n)<span class="cf">break</span>; puts(n&amp;<span class="dv">1</span>?<span class="st">&quot;Bob&quot;</span>:<span class="st">&quot;Alice&quot;</span>);}</span>
<span id="cb44-5"><a href="#cb44-5"></a>   <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb44-6"><a href="#cb44-6"></a>}</span></code></pre></div>
<h3 id="bzoj3155preprefix-sum2016.6.30">bzoj3155Preprefix sum（2016.6.30）</h3>
<h4 id="题意-44">题意</h4>
<p>询问一个数组前缀和数组的前缀和，支持单点修改。</p>
<h4 id="题解-44">题解</h4>
<p><span class="math inline">\(S_{S_i}=\sum_{i=1}^n{(n-i+1)\times a_i}=(n+1)\times S_i-\sum_{i=1}^n{i\times ai}\)</span>。然后就只要用树状数组维护ai和i*ai的前缀和就行了。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb45-5"><a href="#cb45-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb45-6"><a href="#cb45-6"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb45-7"><a href="#cb45-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb45-8"><a href="#cb45-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb45-9"><a href="#cb45-9"></a></span>
<span id="cb45-10"><a href="#cb45-10"></a>ll v[maxn][<span class="dv">2</span>],sm[maxn][<span class="dv">2</span>]; <span class="dt">int</span> n,m; <span class="dt">char</span> s[<span class="dv">10</span>];</span>
<span id="cb45-11"><a href="#cb45-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb45-12"><a href="#cb45-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb45-13"><a href="#cb45-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb45-14"><a href="#cb45-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb45-15"><a href="#cb45-15"></a>}</span>
<span id="cb45-16"><a href="#cb45-16"></a><span class="dt">void</span> update(<span class="dt">int</span> x,ll val,<span class="dt">bool</span> b){<span class="cf">while</span>(x&lt;=n)sm[x][b]+=val,x+=lb(x);}</span>
<span id="cb45-17"><a href="#cb45-17"></a>ll query(<span class="dt">int</span> x,<span class="dt">bool</span> b){ll q=<span class="dv">0</span>; <span class="cf">while</span>(x)q+=sm[x][b],x-=lb(x); <span class="cf">return</span> q;}</span>
<span id="cb45-18"><a href="#cb45-18"></a><span class="dt">int</span> main(){</span>
<span id="cb45-19"><a href="#cb45-19"></a>    n=read(); m=read();</span>
<span id="cb45-20"><a href="#cb45-20"></a>    inc(i,<span class="dv">1</span>,n)v[i][<span class="dv">0</span>]=(ll)read(),v[i][<span class="dv">1</span>]=(ll)i*v[i][<span class="dv">0</span>],update(i,v[i][<span class="dv">0</span>],<span class="dv">0</span>),update(i,v[i][<span class="dv">1</span>],<span class="dv">1</span>);</span>
<span id="cb45-21"><a href="#cb45-21"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb45-22"><a href="#cb45-22"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s);</span>
<span id="cb45-23"><a href="#cb45-23"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>){<span class="dt">int</span> a=read(); printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,query(a,<span class="dv">0</span>)*(a+<span class="dv">1</span>)-query(a,<span class="dv">1</span>));}</span>
<span id="cb45-24"><a href="#cb45-24"></a>        <span class="cf">if</span>(s[<span class="dv">0</span>]==<span class="ch">&#39;M&#39;</span>){</span>
<span id="cb45-25"><a href="#cb45-25"></a>            <span class="dt">int</span> a=read(); ll b=(ll)read();</span>
<span id="cb45-26"><a href="#cb45-26"></a>            update(a,b-v[a][<span class="dv">0</span>],<span class="dv">0</span>); v[a][<span class="dv">0</span>]=b; update(a,b*a-v[a][<span class="dv">1</span>],<span class="dv">1</span>); v[a][<span class="dv">1</span>]=b*a;</span>
<span id="cb45-27"><a href="#cb45-27"></a>        }</span>
<span id="cb45-28"><a href="#cb45-28"></a>    }</span>
<span id="cb45-29"><a href="#cb45-29"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb45-30"><a href="#cb45-30"></a>}</span></code></pre></div>
<h3 id="bzoj4552tjoi2016heoi2016排序2016.6.30">bzoj4552[Tjoi2016&amp;Heoi2016]排序（2016.6.30）</h3>
<h4 id="题意-45">题意</h4>
<p>给出一个1到n的全排列，现在对这个全排列序列进行m次局部排序，排序分为两种：1:(0,l,r)表示将区间[l,r]的数字升序排序2:(1,l,r)表示将区间[l,r]的数字降序排序，最后询问第q位置上的数字。</p>
<h4 id="题解-45">题解</h4>
<p>二分最后这个数，判定一个数就是令数组中＞它为1，≤它的为0。然后把排序转成线段树区间赋值，最后查询q位置的数。如果为1则用来判定的数＜答案，如果为0则用来判定的数≥答案。反思：查询区间里有多少个1后，区间赋值时如果查询结果为0，那么区间赋值左端点=r-0+1，右端点=r，则会导致左端点大于右端点，那么就会wa，当查询结果等于区间长度时也会发生类似情况。</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb46-5"><a href="#cb46-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb46-7"><a href="#cb46-7"></a></span>
<span id="cb46-8"><a href="#cb46-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb46-9"><a href="#cb46-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb46-10"><a href="#cb46-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();} <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb46-11"><a href="#cb46-11"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb46-12"><a href="#cb46-12"></a>}</span>
<span id="cb46-13"><a href="#cb46-13"></a><span class="dt">int</span> n,m,v[maxn],opt[maxn],x[maxn],y[maxn],l,r,k,sm[maxn*<span class="dv">5</span>],tag[maxn*<span class="dv">5</span>],ll[maxn*<span class="dv">5</span>],rr[maxn*<span class="dv">5</span>]; <span class="dt">bool</span> bit[maxn];</span>
<span id="cb46-14"><a href="#cb46-14"></a><span class="dt">void</span> update(<span class="dt">int</span> x){sm[x]=sm[x&lt;&lt;<span class="dv">1</span>]+sm[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>];}</span>
<span id="cb46-15"><a href="#cb46-15"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb46-16"><a href="#cb46-16"></a>    <span class="cf">if</span>(tag[x]!=-<span class="dv">1</span>&amp;&amp;ll[x]!=rr[x]){</span>
<span id="cb46-17"><a href="#cb46-17"></a>        sm[x&lt;&lt;<span class="dv">1</span>]=tag[x]*(rr[x&lt;&lt;<span class="dv">1</span>]-ll[x&lt;&lt;<span class="dv">1</span>]+<span class="dv">1</span>); tag[x&lt;&lt;<span class="dv">1</span>]=tag[x];</span>
<span id="cb46-18"><a href="#cb46-18"></a>        sm[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=tag[x]*(rr[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]-ll[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]+<span class="dv">1</span>); tag[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=tag[x];</span>
<span id="cb46-19"><a href="#cb46-19"></a>        tag[x]=-<span class="dv">1</span>;</span>
<span id="cb46-20"><a href="#cb46-20"></a>    }</span>
<span id="cb46-21"><a href="#cb46-21"></a>}</span>
<span id="cb46-22"><a href="#cb46-22"></a><span class="dt">void</span> build(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb46-23"><a href="#cb46-23"></a>    tag[x]=-<span class="dv">1</span>; ll[x]=l; rr[x]=r; <span class="cf">if</span>(l==r){sm[x]=bit[l]; <span class="cf">return</span>;} <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb46-24"><a href="#cb46-24"></a>    build(x&lt;&lt;<span class="dv">1</span>,l,mid); build(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r); update(x);</span>
<span id="cb46-25"><a href="#cb46-25"></a>}</span>
<span id="cb46-26"><a href="#cb46-26"></a><span class="dt">void</span> modify(<span class="dt">int</span> x,<span class="dt">int</span> ql,<span class="dt">int</span> qr,<span class="dt">bool</span> bit){</span>
<span id="cb46-27"><a href="#cb46-27"></a>    <span class="cf">if</span>(ql&gt;qr)<span class="cf">return</span>; pushdown(x);</span>
<span id="cb46-28"><a href="#cb46-28"></a>    <span class="cf">if</span>(ql&lt;=ll[x]&amp;&amp;rr[x]&lt;=qr){tag[x]=bit; sm[x]=bit*(rr[x]-ll[x]+<span class="dv">1</span>); <span class="cf">return</span>;} <span class="dt">int</span> mid=(ll[x]+rr[x])&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb46-29"><a href="#cb46-29"></a>    <span class="cf">if</span>(ql&lt;=mid)modify(x&lt;&lt;<span class="dv">1</span>,ql,qr,bit); <span class="cf">if</span>(mid&lt;qr)modify(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,ql,qr,bit); update(x);</span>
<span id="cb46-30"><a href="#cb46-30"></a>}</span>
<span id="cb46-31"><a href="#cb46-31"></a><span class="dt">int</span> query(<span class="dt">int</span> x,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb46-32"><a href="#cb46-32"></a>    pushdown(x);</span>
<span id="cb46-33"><a href="#cb46-33"></a>    <span class="cf">if</span>(ql&lt;=ll[x]&amp;&amp;rr[x]&lt;=qr){<span class="cf">return</span> sm[x];} <span class="dt">int</span> mid=(ll[x]+rr[x])&gt;&gt;<span class="dv">1</span>,q=<span class="dv">0</span>;</span>
<span id="cb46-34"><a href="#cb46-34"></a>    <span class="cf">if</span>(ql&lt;=mid)q+=query(x&lt;&lt;<span class="dv">1</span>,ql,qr); <span class="cf">if</span>(mid&lt;qr)q+=query(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,ql,qr); <span class="cf">return</span> q;</span>
<span id="cb46-35"><a href="#cb46-35"></a>}</span>
<span id="cb46-36"><a href="#cb46-36"></a><span class="dt">bool</span> check(<span class="dt">int</span> o){</span>
<span id="cb46-37"><a href="#cb46-37"></a>    inc(i,<span class="dv">1</span>,n)bit[i]=(v[i]&gt;o); build(<span class="dv">1</span>,<span class="dv">1</span>,n);</span>
<span id="cb46-38"><a href="#cb46-38"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb46-39"><a href="#cb46-39"></a>        <span class="dt">int</span> q=query(<span class="dv">1</span>,x[i],y[i]);</span>
<span id="cb46-40"><a href="#cb46-40"></a>        <span class="cf">if</span>(!opt[i])modify(<span class="dv">1</span>,x[i],y[i]-q,<span class="dv">0</span>),modify(<span class="dv">1</span>,y[i]-q+<span class="dv">1</span>,y[i],<span class="dv">1</span>);</span>
<span id="cb46-41"><a href="#cb46-41"></a>        <span class="cf">else</span> modify(<span class="dv">1</span>,x[i],x[i]+q-<span class="dv">1</span>,<span class="dv">1</span>),modify(<span class="dv">1</span>,x[i]+q,y[i],<span class="dv">0</span>);</span>
<span id="cb46-42"><a href="#cb46-42"></a>    }</span>
<span id="cb46-43"><a href="#cb46-43"></a>    <span class="cf">if</span>(query(<span class="dv">1</span>,k,k))<span class="cf">return</span> <span class="dv">1</span>;<span class="cf">else</span> <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb46-44"><a href="#cb46-44"></a>}</span>
<span id="cb46-45"><a href="#cb46-45"></a><span class="dt">int</span> main(){</span>
<span id="cb46-46"><a href="#cb46-46"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)v[i]=read(); inc(i,<span class="dv">1</span>,m)opt[i]=read(),x[i]=read(),y[i]=read();</span>
<span id="cb46-47"><a href="#cb46-47"></a>    k=read(); l=<span class="dv">1</span>; r=n;</span>
<span id="cb46-48"><a href="#cb46-48"></a>    <span class="cf">while</span>(l&lt;r){</span>
<span id="cb46-49"><a href="#cb46-49"></a>        <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(check(mid))l=mid+<span class="dv">1</span>;<span class="cf">else</span> r=mid;</span>
<span id="cb46-50"><a href="#cb46-50"></a>    }</span>
<span id="cb46-51"><a href="#cb46-51"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,l);</span>
<span id="cb46-52"><a href="#cb46-52"></a>}</span></code></pre></div>
<footer>
    <hr>
    <center>
        Powered by <a href="https://github.com/ZimingYuan/Yblogs" target="_blank">Yblogs</a><br>
        转载请注明出处<br>
        © 2025 VnYzm的博客<br>
        <span id="busuanzi_container_site_uv">2025年10月7日以来总访问量为<span id="busuanzi_value_site_uv"></span>次</span>
    </center>
</footer>
</body>
</html>
