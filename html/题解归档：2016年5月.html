<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="题解归档：2016年5月" />
  <meta name="keywords" content="" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 "LXGW Bright", Georgia, serif;
    --font-h: 1.4rem/1.5 "LXGW Bright", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" type="text/css" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css"/>
  <title>题解归档：2016年5月</title>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">所有文章</a></li>
            <li><a href="/technique.html">技术</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li><a href="/friends.html">友链</a></li>
            <li><a href="/html/关于.html">关于</a></li>
            <li><a href="https://www.travellings.cn/go.html" target="_blank">开往</a></li>
            <li class="float-right sticky"><button style="margin: 0" onclick="search()">
              <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M15.7955 15.8111L21 21M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>
            </button></li>
            <li class="float-right sticky"><input type="search" placeholder="搜索标题" style="margin: 0"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">题解归档：2016年5月</h1>
<hr>
</header>
<h3 id="bzoj3196tyvj1730二逼平衡树2016.5.8">bzoj3196Tyvj1730二逼平衡树（2016.5.8）</h3>
<h4 id="题意">题意</h4>
<p>维护一个数列,操作：查询k在区间内的排名、查询区间内排名为k的值3、修改某一位上的数值、查询k在区间内的前驱(前驱定义为小于x，且最大的数)、查询k在区间内的后继(后继定义为大于x，且最小的数)</p>
<h4 id="题解">题解</h4>
<p>线段树套treap，我写了一个星期QAQ第一、三个操作直接搞；第二个操作就二分那个值，然后查它在区间内的排名；第四、五个操作就当查询值≤(≥)当前节点就往左(右)走，用一个全局变量记往左(右)走时遍历过的最大(小)值。反思：本弱各种写挂，以前从来把treap的rotate操作写的和splay的rotate操作一样，结果这题如果还这样写，将会异常麻烦，因此不得不用引用型写法，去掉了一个fa数组，异常不习惯。同时第二个操作也很蛋疼，推了很久（实际上是抄了很久），treap也很久没写了，甚至删除节点还出现if(cnt[x]&gt;1){cnt[x]–,sz[x]–; return;}写成if(cnt[x]&gt;0){cnt[x]–,sz[x]–; return;}的错误，调了一整个晚修QAQ。最后交的时候10s，差点TLE。求了一下序列中的最大最小值，在第二个操作做二分时用，省了0.2s；又将线段树的l、r、lc、rc数组去掉，省了0.6s，最后结果是9.2s，还是卡时啊……</p>
<p>yyl大爷：你要多写些题，提高代码能力！ orzzzzzzz……</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="pp">#define maxn </span><span class="dv">2500000</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="pp">#define maxm </span><span class="dv">200000</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="dt">int</span> v[maxn],rnd[maxn],root[maxm],ch[maxn][<span class="dv">2</span>],cnt[maxn],sz[maxn],nds,mx,mn,n;</span>
<span id="cb1-13"><a href="#cb1-13"></a>stack &lt;<span class="dt">int</span>&gt; pool;</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="dt">int</span> newnode(){</span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="cf">if</span>(pool.empty())<span class="cf">return</span> ++nds;<span class="cf">else</span>{<span class="dt">int</span> x=pool.top(); pool.pop(); <span class="cf">return</span> x;}</span>
<span id="cb1-16"><a href="#cb1-16"></a>}</span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="dt">void</span> delnode(<span class="dt">int</span> x){pool.push(x);}</span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="dt">void</span> update(<span class="dt">int</span> x){<span class="cf">if</span>(! x)<span class="cf">return</span>; sz[x]=cnt[x]+sz[ch[x][<span class="dv">0</span>]]+sz[ch[x][<span class="dv">1</span>]];}</span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="dt">void</span> rotate(<span class="dt">int</span> &amp;x,<span class="dt">bool</span> lr){</span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span>; <span class="dt">int</span> a=ch[x][lr]; ch[x][lr]=ch[a][!lr]; ch[a][!lr]=x; update(x); x=a; update(a);</span>
<span id="cb1-21"><a href="#cb1-21"></a>}</span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;x,<span class="dt">int</span> num){</span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="cf">if</span>(!x){<span class="dt">int</span> y=newnode(); v[y]=num; rnd[y]=rand(); ch[y][<span class="dv">0</span>]=ch[y][<span class="dv">1</span>]=<span class="dv">0</span>; cnt[y]=sz[y]=<span class="dv">1</span>; x=y; <span class="cf">return</span>;}</span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="cf">if</span>(v[x]==num){cnt[x]++; sz[x]++; <span class="cf">return</span>;}</span>
<span id="cb1-25"><a href="#cb1-25"></a>    <span class="cf">if</span>(num&lt;v[x])insert(ch[x][<span class="dv">0</span>],num);<span class="cf">else</span> insert(ch[x][<span class="dv">1</span>],num); update(x);</span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="cf">if</span>(ch[x][<span class="dv">0</span>]&amp;&amp;rnd[ch[x][<span class="dv">0</span>]]&lt;rnd[x])rotate(x,<span class="dv">0</span>);</span>
<span id="cb1-27"><a href="#cb1-27"></a>    <span class="cf">if</span>(ch[x][<span class="dv">1</span>]&amp;&amp;rnd[ch[x][<span class="dv">1</span>]]&lt;rnd[x])rotate(x,<span class="dv">1</span>);</span>
<span id="cb1-28"><a href="#cb1-28"></a>}</span>
<span id="cb1-29"><a href="#cb1-29"></a><span class="dt">void</span> del(<span class="dt">int</span> &amp;x,<span class="dt">int</span> num){</span>
<span id="cb1-30"><a href="#cb1-30"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span>;</span>
<span id="cb1-31"><a href="#cb1-31"></a>    <span class="cf">if</span>(v[x]==num){</span>
<span id="cb1-32"><a href="#cb1-32"></a>        <span class="cf">if</span>(cnt[x]&gt;<span class="dv">1</span>){cnt[x]--,sz[x]--; <span class="cf">return</span>;}</span>
<span id="cb1-33"><a href="#cb1-33"></a>        <span class="cf">if</span>(ch[x][<span class="dv">0</span>]*ch[x][<span class="dv">1</span>]==<span class="dv">0</span>){delnode(x); x=ch[x][<span class="dv">0</span>]+ch[x][<span class="dv">1</span>]; <span class="cf">return</span>;} <span class="dt">int</span> y=x;</span>
<span id="cb1-34"><a href="#cb1-34"></a>        <span class="cf">if</span>(rnd[ch[x][<span class="dv">0</span>]]&lt;rnd[ch[x][<span class="dv">1</span>]])rotate(x,<span class="dv">0</span>),del(ch[x][<span class="dv">1</span>],num);<span class="cf">else</span> rotate(x,<span class="dv">1</span>),del(ch[x][<span class="dv">0</span>],num);</span>
<span id="cb1-35"><a href="#cb1-35"></a>        update(x); <span class="cf">return</span>;</span>
<span id="cb1-36"><a href="#cb1-36"></a>    }</span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="cf">if</span>(num&lt;v[x])del(ch[x][<span class="dv">0</span>],num);<span class="cf">else</span> del(ch[x][<span class="dv">1</span>],num); update(x);</span>
<span id="cb1-38"><a href="#cb1-38"></a>}</span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="dt">int</span> rank(<span class="dt">int</span> x,<span class="dt">int</span> num){</span>
<span id="cb1-40"><a href="#cb1-40"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span> <span class="dv">0</span>; <span class="cf">if</span>(v[x]==num)<span class="cf">return</span> sz[ch[x][<span class="dv">0</span>]];</span>
<span id="cb1-41"><a href="#cb1-41"></a>    <span class="cf">if</span>(num&lt;v[x])<span class="cf">return</span> rank(ch[x][<span class="dv">0</span>],num);<span class="cf">else</span> <span class="cf">return</span> rank(ch[x][<span class="dv">1</span>],num)+sz[ch[x][<span class="dv">0</span>]]+cnt[x];</span>
<span id="cb1-42"><a href="#cb1-42"></a>}</span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="dt">int</span> ans;</span>
<span id="cb1-44"><a href="#cb1-44"></a><span class="dt">void</span> before(<span class="dt">int</span> x,<span class="dt">int</span> num){</span>
<span id="cb1-45"><a href="#cb1-45"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span>; <span class="cf">if</span>(num&lt;=v[x])before(ch[x][<span class="dv">0</span>],num); <span class="cf">else</span> ans=max(ans,v[x]),before(ch[x][<span class="dv">1</span>],num);</span>
<span id="cb1-46"><a href="#cb1-46"></a>}</span>
<span id="cb1-47"><a href="#cb1-47"></a><span class="dt">void</span> after(<span class="dt">int</span> x,<span class="dt">int</span> num){</span>
<span id="cb1-48"><a href="#cb1-48"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span>; <span class="cf">if</span>(num&gt;=v[x])after(ch[x][<span class="dv">1</span>],num); <span class="cf">else</span> ans=min(ans,v[x]),after(ch[x][<span class="dv">0</span>],num);</span>
<span id="cb1-49"><a href="#cb1-49"></a>}</span>
<span id="cb1-50"><a href="#cb1-50"></a><span class="dt">void</span> add(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> pos,<span class="dt">int</span> num){</span>
<span id="cb1-51"><a href="#cb1-51"></a>    insert(root[x],num); <span class="cf">if</span>(l==r)<span class="cf">return</span>; <span class="dt">int</span> M=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb1-52"><a href="#cb1-52"></a>    <span class="cf">if</span>(l&lt;=pos&amp;&amp;pos&lt;=M)add(x&lt;&lt;<span class="dv">1</span>,l,M,pos,num);</span>
<span id="cb1-53"><a href="#cb1-53"></a>    <span class="cf">if</span>(M&lt;pos&amp;&amp;pos&lt;=r)add(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,M+<span class="dv">1</span>,r,pos,num);</span>
<span id="cb1-54"><a href="#cb1-54"></a>}</span>
<span id="cb1-55"><a href="#cb1-55"></a><span class="dt">void</span> change(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> pos,<span class="dt">int</span> num,<span class="dt">int</span> val){</span>
<span id="cb1-56"><a href="#cb1-56"></a>    del(root[x],num); insert(root[x],val); <span class="cf">if</span>(l==r)<span class="cf">return</span>; <span class="dt">int</span> M=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb1-57"><a href="#cb1-57"></a>    <span class="cf">if</span>(l&lt;=pos&amp;&amp;pos&lt;=M)change(x&lt;&lt;<span class="dv">1</span>,l,M,pos,num,val); <span class="cf">if</span>(M&lt;pos&amp;&amp;pos&lt;=r)change(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,M+<span class="dv">1</span>,r,pos,num,val);</span>
<span id="cb1-58"><a href="#cb1-58"></a>}</span>
<span id="cb1-59"><a href="#cb1-59"></a><span class="dt">int</span> getrank(<span class="dt">int</span> k,<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb1-60"><a href="#cb1-60"></a>    <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="cf">return</span> rank(root[x],k); <span class="dt">int</span> M=(l+r)&gt;&gt;<span class="dv">1</span>,q=<span class="dv">0</span>;</span>
<span id="cb1-61"><a href="#cb1-61"></a>    <span class="cf">if</span>(ql&lt;=M)q+=getrank(k,x&lt;&lt;<span class="dv">1</span>,l,M,ql,qr); <span class="cf">if</span>(M&lt;qr)q+=getrank(k,x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,M+<span class="dv">1</span>,r,ql,qr); <span class="cf">return</span> q;</span>
<span id="cb1-62"><a href="#cb1-62"></a>}</span>
<span id="cb1-63"><a href="#cb1-63"></a><span class="dt">int</span> getindex(<span class="dt">int</span> k,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb1-64"><a href="#cb1-64"></a>    <span class="dt">int</span> L=mn,R=mx;</span>
<span id="cb1-65"><a href="#cb1-65"></a>    <span class="cf">while</span>(L&lt;=R){</span>
<span id="cb1-66"><a href="#cb1-66"></a>        <span class="dt">int</span> M=(L+R)&gt;&gt;<span class="dv">1</span>; <span class="dt">int</span> x=getrank(M,<span class="dv">1</span>,<span class="dv">1</span>,n,ql,qr);</span>
<span id="cb1-67"><a href="#cb1-67"></a>        <span class="cf">if</span>(x+<span class="dv">1</span>&lt;=k)L=M+<span class="dv">1</span>,ans=M;<span class="cf">else</span> R=M-<span class="dv">1</span>;</span>
<span id="cb1-68"><a href="#cb1-68"></a>    }</span>
<span id="cb1-69"><a href="#cb1-69"></a>    <span class="cf">return</span> ans;</span>
<span id="cb1-70"><a href="#cb1-70"></a>}</span>
<span id="cb1-71"><a href="#cb1-71"></a><span class="dt">void</span> getbefore(<span class="dt">int</span> k,<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb1-72"><a href="#cb1-72"></a>    <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr){before(root[x],k); <span class="cf">return</span>;} <span class="dt">int</span> M=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb1-73"><a href="#cb1-73"></a>    <span class="cf">if</span>(ql&lt;=M)getbefore(k,x&lt;&lt;<span class="dv">1</span>,l,M,ql,qr); <span class="cf">if</span>(M&lt;qr)getbefore(k,x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,M+<span class="dv">1</span>,r,ql,qr);</span>
<span id="cb1-74"><a href="#cb1-74"></a>}</span>
<span id="cb1-75"><a href="#cb1-75"></a><span class="dt">void</span> getafter(<span class="dt">int</span> k,<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb1-76"><a href="#cb1-76"></a>    <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr){after(root[x],k); <span class="cf">return</span>;} <span class="dt">int</span> M=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb1-77"><a href="#cb1-77"></a>    <span class="cf">if</span>(ql&lt;=M)getafter(k,x&lt;&lt;<span class="dv">1</span>,l,M,ql,qr); <span class="cf">if</span>(M&lt;qr)getafter(k,x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,M+<span class="dv">1</span>,r,ql,qr);</span>
<span id="cb1-78"><a href="#cb1-78"></a>}</span>
<span id="cb1-79"><a href="#cb1-79"></a><span class="dt">int</span> val[maxm],m;</span>
<span id="cb1-80"><a href="#cb1-80"></a><span class="dt">int</span> main(){</span>
<span id="cb1-81"><a href="#cb1-81"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); mx=-<span class="dv">1</span>; mn=INF;</span>
<span id="cb1-82"><a href="#cb1-82"></a>    inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;val[i]),mx=max(mx,val[i]),mn=min(mn,val[i]),add(<span class="dv">1</span>,<span class="dv">1</span>,n,i,val[i]);</span>
<span id="cb1-83"><a href="#cb1-83"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb1-84"><a href="#cb1-84"></a>        <span class="dt">int</span> opt,x,y,z; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;opt);</span>
<span id="cb1-85"><a href="#cb1-85"></a>        <span class="cf">if</span>(opt==<span class="dv">1</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y,&amp;z),printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,getrank(z,<span class="dv">1</span>,<span class="dv">1</span>,n,x,y)+<span class="dv">1</span>);</span>
<span id="cb1-86"><a href="#cb1-86"></a>        <span class="cf">if</span>(opt==<span class="dv">2</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y,&amp;z),printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,getindex(z,x,y));</span>
<span id="cb1-87"><a href="#cb1-87"></a>        <span class="cf">if</span>(opt==<span class="dv">3</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y),change(<span class="dv">1</span>,<span class="dv">1</span>,n,x,val[x],y),val[x]=y,mx=max(mx,y),mn=min(mn,y);</span>
<span id="cb1-88"><a href="#cb1-88"></a>        <span class="cf">if</span>(opt==<span class="dv">4</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y,&amp;z),ans=-<span class="dv">1</span>,getbefore(z,<span class="dv">1</span>,<span class="dv">1</span>,n,x,y),printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb1-89"><a href="#cb1-89"></a>        <span class="cf">if</span>(opt==<span class="dv">5</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y,&amp;z),ans=INF,getafter(z,<span class="dv">1</span>,<span class="dv">1</span>,n,x,y),printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb1-90"><a href="#cb1-90"></a>    }</span>
<span id="cb1-91"><a href="#cb1-91"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-92"><a href="#cb1-92"></a>}</span></code></pre></div>
<h3 id="bzoj3932cqoi2015任务查询系统2016.5.16">bzoj3932[CQOI2015]任务查询系统（2016.5.16）</h3>
<h4 id="题意-1">题意</h4>
<p>m个任务，任务(Si,Ei,Pi)表示任务从第Si秒开始，在第Ei秒后结束，优先级为Pi。n个询问，每次询问第Xi秒正在运行的任务中，优先级最小的Ki个任务的优先级之和是多少。若Ki大于第Xi秒正在运行的任务总数，输出第Xi秒任务优先级之和。m，n≤100000，强制在线。</p>
<h4 id="题解-1">题解</h4>
<p>第一次写主席树……（因为没彻底理解被yyl大爷d：你根本不理解主席树）主席树本质上就是权值线段树+重用节点。</p>
<p>反映在本题中，就是给每个时间点建一棵权值线段树，但这样会MLE，所以我们先将所有任务拆成“Si到n时间点的权值+Pi”和“Ei+1到n时间点的权值+(-Pi)，然后按插入的时间点排序，在每个插入操作前，将之前上一次操作得到的权值线段树的根节点指针复制过来，然后插入时只新开节点记录被修改后的节点，因为一次插入只会影响log2n个节点，所以总空间复杂度为O(nlog2n)，同时因为相隔两个插入时间点之间的时间点只要复制一个指针就行，每次插入时间复杂度为log2n，故时间复杂度为O(nlog2n)。本题可以不离散化，但我比较怂所以还是离散了一下省空间。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="pp">#define maxn </span><span class="dv">400000</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">struct</span> opt{<span class="dt">int</span> a,b,c,id;}; opt opts[maxn*<span class="dv">2</span>];</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="dt">bool</span> cmp1(opt a,opt b){<span class="cf">return</span> a.b&lt;b.b;}</span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="dt">bool</span> cmp2(opt a,opt b){<span class="cf">return</span> a.a&lt;b.a;}</span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="dt">int</span> lc[<span class="dv">20</span>*maxn],rc[<span class="dv">20</span>*maxn],rt[maxn],sz[<span class="dv">20</span>*maxn],n,m,valn,tot,optn;</span>
<span id="cb2-14"><a href="#cb2-14"></a>ll sm[<span class="dv">20</span>*maxn];</span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="dt">void</span> build(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb2-16"><a href="#cb2-16"></a>    x=++tot; lc[x]=rc[x]=sz[x]=sm[x]=<span class="dv">0</span>; <span class="cf">if</span>(l==r)<span class="cf">return</span>;</span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; build(lc[x],l,mid); build(rc[x],mid+<span class="dv">1</span>,r);</span>
<span id="cb2-18"><a href="#cb2-18"></a>}</span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="dt">void</span> ins(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> y,<span class="dt">int</span> z1,<span class="dt">int</span> z2){</span>
<span id="cb2-20"><a href="#cb2-20"></a>    tot++; sm[tot]=sm[x]+(ll)(z1*z2); sz[tot]=sz[x]+z2;</span>
<span id="cb2-21"><a href="#cb2-21"></a>    lc[tot]=lc[x]; rc[tot]=rc[x]; x=tot; <span class="cf">if</span>(l==r)<span class="cf">return</span>; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb2-22"><a href="#cb2-22"></a>    <span class="cf">if</span>(y&lt;=mid)ins(lc[x],l,mid,y,z1,z2);<span class="cf">else</span> ins(rc[x],mid+<span class="dv">1</span>,r,y,z1,z2);</span>
<span id="cb2-23"><a href="#cb2-23"></a>}</span>
<span id="cb2-24"><a href="#cb2-24"></a>ll query(<span class="dt">int</span> x,ll k){</span>
<span id="cb2-25"><a href="#cb2-25"></a>    ll q=<span class="dv">0</span>; <span class="dt">int</span> y=x;</span>
<span id="cb2-26"><a href="#cb2-26"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb2-27"><a href="#cb2-27"></a>        <span class="cf">if</span>(k&gt;=sz[y]){q+=sm[y]; <span class="cf">return</span> q;} <span class="cf">if</span>(!lc[y]&amp;&amp;!rc[y]){q+=sm[y]/sz[y]*k; <span class="cf">return</span> q;}</span>
<span id="cb2-28"><a href="#cb2-28"></a>        <span class="cf">if</span>(k==sz[lc[y]]){q+=sm[lc[y]]; <span class="cf">return</span> q;}</span>
<span id="cb2-29"><a href="#cb2-29"></a>        <span class="cf">if</span>(k&lt;sz[lc[y]])y=lc[y];<span class="cf">else</span> k-=sz[lc[y]],q+=sm[lc[y]],y=rc[y];</span>
<span id="cb2-30"><a href="#cb2-30"></a>    }</span>
<span id="cb2-31"><a href="#cb2-31"></a>}</span>
<span id="cb2-32"><a href="#cb2-32"></a><span class="dt">int</span> main(){</span>
<span id="cb2-33"><a href="#cb2-33"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;m,&amp;n); optn=<span class="dv">0</span>;</span>
<span id="cb2-34"><a href="#cb2-34"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb2-35"><a href="#cb2-35"></a>        <span class="dt">int</span> a,b,c; scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c);</span>
<span id="cb2-36"><a href="#cb2-36"></a>        opts[++optn]=(opt){a,c,<span class="dv">1</span>,<span class="dv">0</span>}; <span class="cf">if</span>(b!=n)opts[++optn]=(opt){b+<span class="dv">1</span>,c,-<span class="dv">1</span>,<span class="dv">0</span>};</span>
<span id="cb2-37"><a href="#cb2-37"></a>    }</span>
<span id="cb2-38"><a href="#cb2-38"></a>    sort(opts+<span class="dv">1</span>,opts+<span class="dv">1</span>+optn,cmp1); valn=<span class="dv">1</span>; opts[<span class="dv">1</span>].id=<span class="dv">1</span>;</span>
<span id="cb2-39"><a href="#cb2-39"></a>    inc(i,<span class="dv">2</span>,optn){<span class="cf">if</span>(opts[i].b!=opts[i-<span class="dv">1</span>].b)opts[i].id=++valn;<span class="cf">else</span> opts[i].id=valn;}</span>
<span id="cb2-40"><a href="#cb2-40"></a>    tot=<span class="dv">0</span>; build(rt[<span class="dv">0</span>],<span class="dv">1</span>,valn); sort(opts+<span class="dv">1</span>,opts+<span class="dv">1</span>+optn,cmp2); opts[optn+<span class="dv">1</span>].a=n;</span>
<span id="cb2-41"><a href="#cb2-41"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=opts[<span class="dv">1</span>].a&amp;&amp;i&lt;=n;i++)rt[i]=rt[i-<span class="dv">1</span>];</span>
<span id="cb2-42"><a href="#cb2-42"></a>    inc(i,<span class="dv">1</span>,optn){</span>
<span id="cb2-43"><a href="#cb2-43"></a>        ins(rt[opts[i].a],<span class="dv">1</span>,valn,opts[i].id,opts[i].b,opts[i].c);</span>
<span id="cb2-44"><a href="#cb2-44"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=opts[i].a+<span class="dv">1</span>;j&lt;=opts[i+<span class="dv">1</span>].a&amp;&amp;j&lt;=n;j++)rt[j]=rt[j-<span class="dv">1</span>];</span>
<span id="cb2-45"><a href="#cb2-45"></a>    }</span>
<span id="cb2-46"><a href="#cb2-46"></a>    ll last=<span class="dv">1</span>;</span>
<span id="cb2-47"><a href="#cb2-47"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb2-48"><a href="#cb2-48"></a>        <span class="dt">int</span> a;ll b,c,d; scanf(<span class="st">&quot;</span><span class="sc">%d%lld%lld%lld</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span>
<span id="cb2-49"><a href="#cb2-49"></a>        last=query(rt[a],<span class="dv">1</span>+(b*last+c)%d);</span>
<span id="cb2-50"><a href="#cb2-50"></a>        printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,last);</span>
<span id="cb2-51"><a href="#cb2-51"></a>    }</span>
<span id="cb2-52"><a href="#cb2-52"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-53"><a href="#cb2-53"></a>}</span></code></pre></div>
<h3 id="bzoj4512usaco2016-jan-build-gates2016.5.17">bzoj4512[Usaco2016 Jan] Build Gates（2016.5.17）</h3>
<h4 id="题意-2">题意</h4>
<p>某人从农场的(0,0)出发，沿边界到处乱走，走过的地方会留下栅栏，等走完后问要在多少个栅栏上开门才能使整个农场连通，最多走1000步。</p>
<h4 id="题解-2">题解</h4>
<p>我的代码比别人的都长~我的做法是先算出最左/最下可能会走到哪里，然后变换一下坐标系（实际是是改变出发起点），然后记录哪个格子的上下左右被栅栏堵了，最后做一下floodfill，输出连通块数-1。注意还要把有栅栏区域的外圈格子也算进去，因为它们代表了有栅栏区域外的广大地区（这个人的农场是无限大的）。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="dt">bool</span> unok[<span class="dv">2000</span>][<span class="dv">2000</span>][<span class="dv">4</span>],vis[<span class="dv">2000</span>][<span class="dv">2000</span>]; <span class="dt">int</span> mx,my,tot,n;</span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="dt">char</span> opt[<span class="dv">2000</span>];</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb3-10"><a href="#cb3-10"></a>    vis[x][y]=<span class="dv">1</span>;</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="cf">if</span>(y!=<span class="dv">0</span>&amp;&amp;!unok[x][y][<span class="dv">0</span>]&amp;&amp;!vis[x][y-<span class="dv">1</span>])dfs(x,y-<span class="dv">1</span>);</span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="cf">if</span>(x!=mx&amp;&amp;!unok[x][y][<span class="dv">1</span>]&amp;&amp;!vis[x+<span class="dv">1</span>][y])dfs(x+<span class="dv">1</span>,y);</span>
<span id="cb3-13"><a href="#cb3-13"></a>    <span class="cf">if</span>(y!=my&amp;&amp;!unok[x][y][<span class="dv">2</span>]&amp;&amp;!vis[x][y+<span class="dv">1</span>])dfs(x,y+<span class="dv">1</span>);</span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="cf">if</span>(x!=<span class="dv">0</span>&amp;&amp;!unok[x][y][<span class="dv">3</span>]&amp;&amp;!vis[x-<span class="dv">1</span>][y])dfs(x-<span class="dv">1</span>,y);</span>
<span id="cb3-15"><a href="#cb3-15"></a>}</span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="dt">int</span> main(){</span>
<span id="cb3-17"><a href="#cb3-17"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); <span class="dt">int</span> x=<span class="dv">1</span>,y=<span class="dv">1</span>; scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,opt);</span>
<span id="cb3-18"><a href="#cb3-18"></a>    inc(i,<span class="dv">0</span>,n-<span class="dv">1</span>){<span class="cf">if</span>(opt[i]==<span class="ch">&#39;W&#39;</span>)y++;<span class="cf">if</span>(opt[i]==<span class="ch">&#39;S&#39;</span>)x++;}</span>
<span id="cb3-19"><a href="#cb3-19"></a>    memset(unok,<span class="dv">0</span>,<span class="kw">sizeof</span>(unok)); mx=my=<span class="dv">0</span>;</span>
<span id="cb3-20"><a href="#cb3-20"></a>    inc(i,<span class="dv">0</span>,n-<span class="dv">1</span>){</span>
<span id="cb3-21"><a href="#cb3-21"></a>        <span class="cf">if</span>(opt[i]==<span class="ch">&#39;N&#39;</span>){</span>
<span id="cb3-22"><a href="#cb3-22"></a>            unok[x][y][<span class="dv">0</span>]=<span class="dv">1</span>; unok[x][y-<span class="dv">1</span>][<span class="dv">2</span>]=<span class="dv">1</span>; x++; mx=max(mx,x);</span>
<span id="cb3-23"><a href="#cb3-23"></a>        }</span>
<span id="cb3-24"><a href="#cb3-24"></a>        <span class="cf">if</span>(opt[i]==<span class="ch">&#39;S&#39;</span>){</span>
<span id="cb3-25"><a href="#cb3-25"></a>            unok[x-<span class="dv">1</span>][y][<span class="dv">0</span>]=<span class="dv">1</span>; unok[x-<span class="dv">1</span>][y-<span class="dv">1</span>][<span class="dv">2</span>]=<span class="dv">1</span>; x--;</span>
<span id="cb3-26"><a href="#cb3-26"></a>        }</span>
<span id="cb3-27"><a href="#cb3-27"></a>        <span class="cf">if</span>(opt[i]==<span class="ch">&#39;W&#39;</span>){</span>
<span id="cb3-28"><a href="#cb3-28"></a>            unok[x][y-<span class="dv">1</span>][<span class="dv">3</span>]=<span class="dv">1</span>; unok[x-<span class="dv">1</span>][y-<span class="dv">1</span>][<span class="dv">1</span>]=<span class="dv">1</span>; y--;</span>
<span id="cb3-29"><a href="#cb3-29"></a>        }</span>
<span id="cb3-30"><a href="#cb3-30"></a>        <span class="cf">if</span>(opt[i]==<span class="ch">&#39;E&#39;</span>){</span>
<span id="cb3-31"><a href="#cb3-31"></a>            unok[x][y][<span class="dv">3</span>]=<span class="dv">1</span>; unok[x-<span class="dv">1</span>][y][<span class="dv">1</span>]=<span class="dv">1</span>; y++; my=max(my,y);</span>
<span id="cb3-32"><a href="#cb3-32"></a>        }</span>
<span id="cb3-33"><a href="#cb3-33"></a>    }</span>
<span id="cb3-34"><a href="#cb3-34"></a>    memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); tot=<span class="dv">0</span>;</span>
<span id="cb3-35"><a href="#cb3-35"></a>    inc(i,<span class="dv">0</span>,mx)inc(j,<span class="dv">0</span>,my)<span class="cf">if</span>(!vis[i][j])tot++,dfs(i,j);</span>
<span id="cb3-36"><a href="#cb3-36"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,tot-<span class="dv">1</span>);</span>
<span id="cb3-37"><a href="#cb3-37"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-38"><a href="#cb3-38"></a>}</span></code></pre></div>
<h3 id="bzoj4525usaco2016-janangry-cows2016.5.17">bzoj4525[Usaco2016 Jan]Angry Cows（2016.5.17）</h3>
<h4 id="题意-3">题意</h4>
<p>有N个草堆在数轴的不同位置，向坐标x处扔炸弹，[x−R,x+R]的草堆都会燃爆。 K个炸弹，问如果要引爆所有的草堆最小的R。草堆数最多50000，坐标最大为109</p>
<h4 id="题解-3">题解</h4>
<p>二分R，判定时从小到大枚举草堆，如果这个草堆没被炸就在这里放炸弹（实际上是放在此处坐标+R的位置），炸掉与它距离≤2R的草堆，重复上述操作。本弱一开始以为炸掉的是与它距离≤2R+1的草堆，调了0.5hQAQ</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="dt">int</span> n,k,x[<span class="dv">60000</span>];</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="dt">int</span> main(){</span>
<span id="cb4-10"><a href="#cb4-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x[i]); sort(x+<span class="dv">1</span>,x+n+<span class="dv">1</span>);</span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="dt">int</span> l=<span class="dv">0</span>,r=x[n],ans;</span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="cf">while</span>(l&lt;=r){</span>
<span id="cb4-13"><a href="#cb4-13"></a>        <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>,pre=-INF,tot=<span class="dv">0</span>; <span class="dt">bool</span> f=<span class="dv">0</span>;</span>
<span id="cb4-14"><a href="#cb4-14"></a>        inc(i,<span class="dv">1</span>,n){</span>
<span id="cb4-15"><a href="#cb4-15"></a>            <span class="cf">if</span>(x[i]-pre&gt;<span class="dv">2</span>*mid)tot++,pre=x[i];</span>
<span id="cb4-16"><a href="#cb4-16"></a>            <span class="cf">if</span>(tot&gt;k){f=<span class="dv">1</span>; <span class="cf">break</span>;}</span>
<span id="cb4-17"><a href="#cb4-17"></a>        }</span>
<span id="cb4-18"><a href="#cb4-18"></a>        <span class="cf">if</span>(!f)r=mid-<span class="dv">1</span>,ans=mid;<span class="cf">else</span> l=mid+<span class="dv">1</span>;</span>
<span id="cb4-19"><a href="#cb4-19"></a>    }</span>
<span id="cb4-20"><a href="#cb4-20"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);</span>
<span id="cb4-21"><a href="#cb4-21"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb4-22"><a href="#cb4-22"></a>}</span></code></pre></div>
<h3 id="bzoj1051haoi2006受欢迎的牛2016.5.17">bzoj1051[HAOI2006]受欢迎的牛（2016.5.17）</h3>
<h4 id="题意-4">题意</h4>
<p>有N头牛，给M对整数(A,B)，表示牛A认为牛B受欢迎，这种关系具有传递性。求出有多少头牛被所有的牛认为是受欢迎的。N≤10000</p>
<h4 id="题解-4">题解</h4>
<p>因为求的是被所有牛认同的牛，如果该牛不认同任何牛，那么这头牛出度为0，且出度为0的牛有且只有一个否则不存在所求牛。如果这头牛认同别的牛，那么就要求这两头牛互相认同。同时两头牛都是所求牛。因此做个tarjan缩点，缩点后若出度为0的点有多个则没有所求牛，若只有一个那么这个点所表示强连通块里的所有点都是所求牛。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,n;}; e es[<span class="dv">60000</span>]; <span class="dt">int</span> g[<span class="dv">20000</span>],ess;</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){f,t,g[f]}; g[f]=ess;}</span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="dt">int</span> bel[<span class="dv">20000</span>],cnt[<span class="dv">20000</span>],n,m,sz[<span class="dv">20000</span>],tot,low[<span class="dv">20000</span>],pre[<span class="dv">20000</span>],tim; <span class="dt">bool</span> vis[<span class="dv">20000</span>],ins[<span class="dv">20000</span>];</span>
<span id="cb5-11"><a href="#cb5-11"></a>stack &lt;<span class="dt">int</span>&gt; s;</span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb5-13"><a href="#cb5-13"></a>    vis[x]=ins[x]=<span class="dv">1</span>; s.push(x); low[x]=pre[x]=++tim;</span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)</span>
<span id="cb5-15"><a href="#cb5-15"></a>        <span class="cf">if</span>(!vis[es[i].t])dfs(es[i].t),low[x]=min(low[x],low[es[i].t]);</span>
<span id="cb5-16"><a href="#cb5-16"></a>        <span class="cf">else</span> <span class="cf">if</span>(ins[es[i].t])low[x]=min(low[x],pre[es[i].t]);</span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="cf">if</span>(low[x]==pre[x]){</span>
<span id="cb5-18"><a href="#cb5-18"></a>        tot++;</span>
<span id="cb5-19"><a href="#cb5-19"></a>        <span class="cf">while</span>(!s.empty()){</span>
<span id="cb5-20"><a href="#cb5-20"></a>            <span class="dt">int</span> now=s.top(); s.pop(); bel[now]=tot; sz[tot]++; ins[now]=<span class="dv">0</span>; <span class="cf">if</span>(now==x)<span class="cf">break</span>;</span>
<span id="cb5-21"><a href="#cb5-21"></a>        }</span>
<span id="cb5-22"><a href="#cb5-22"></a>    }</span>
<span id="cb5-23"><a href="#cb5-23"></a>}</span>
<span id="cb5-24"><a href="#cb5-24"></a><span class="dt">void</span> tarjan(){</span>
<span id="cb5-25"><a href="#cb5-25"></a>    <span class="cf">while</span>(!s.empty())s.pop(); memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); memset(ins,<span class="dv">0</span>,<span class="kw">sizeof</span>(ins)); memset(sz,<span class="dv">0</span>,<span class="kw">sizeof</span>(sz));</span>
<span id="cb5-26"><a href="#cb5-26"></a>    tot=tim=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(! vis[i])dfs(i);</span>
<span id="cb5-27"><a href="#cb5-27"></a>}</span>
<span id="cb5-28"><a href="#cb5-28"></a><span class="dt">void</span> solve(){</span>
<span id="cb5-29"><a href="#cb5-29"></a>    memset(cnt,<span class="dv">0</span>,<span class="kw">sizeof</span>(cnt)); inc(i,<span class="dv">1</span>,ess)<span class="cf">if</span>(bel[es[i].f]!=bel[es[i].t])cnt[bel[es[i].f]]++; <span class="dt">int</span> a=<span class="dv">0</span>;</span>
<span id="cb5-30"><a href="#cb5-30"></a>    inc(i,<span class="dv">1</span>,tot){</span>
<span id="cb5-31"><a href="#cb5-31"></a>        <span class="cf">if</span>(cnt[i]==<span class="dv">0</span>&amp;&amp;a!=<span class="dv">0</span>){printf(<span class="st">&quot;0</span><span class="sc">\n</span><span class="st">&quot;</span>); <span class="cf">return</span>;}</span>
<span id="cb5-32"><a href="#cb5-32"></a>        <span class="cf">if</span>(cnt[i]==<span class="dv">0</span>)a=i;</span>
<span id="cb5-33"><a href="#cb5-33"></a>    }</span>
<span id="cb5-34"><a href="#cb5-34"></a>    printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,sz[a]);</span>
<span id="cb5-35"><a href="#cb5-35"></a>}</span>
<span id="cb5-36"><a href="#cb5-36"></a><span class="dt">int</span> main(){</span>
<span id="cb5-37"><a href="#cb5-37"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb5-38"><a href="#cb5-38"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a,b; scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b); pe(a,b);}</span>
<span id="cb5-39"><a href="#cb5-39"></a>    tarjan(); solve();</span>
<span id="cb5-40"><a href="#cb5-40"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-41"><a href="#cb5-41"></a>}</span></code></pre></div>
<h3 id="bzoj1079scoi2008着色方案2016.5.17">bzoj1079[SCOI2008]着色方案（2016.5.17）</h3>
<h4 id="题意-5">题意</h4>
<p>有n个木块排成一行，有k种颜色的油漆，其中第i种颜色的油漆足够涂ci个木块，所有油漆刚好足够涂满所有木块。求任意两个相邻木块颜色不同的着色方案。k≤15，ci≤5</p>
<h4 id="题解-5">题解</h4>
<p>解决本题关键是ci≤5，所以以剩余可涂方块数为1,2,3,4,5及上次涂的色这次剩余可涂方块数为状态，做dp就行了。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="pp">#define mod </span><span class="dv">1000000007</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a>ll f[<span class="dv">16</span>][<span class="dv">16</span>][<span class="dv">16</span>][<span class="dv">16</span>][<span class="dv">16</span>][<span class="dv">6</span>],k,c[<span class="dv">16</span>],rem[<span class="dv">6</span>];</span>
<span id="cb6-10"><a href="#cb6-10"></a>ll dfs(<span class="dt">int</span> a,<span class="dt">int</span> b,<span class="dt">int</span> c,<span class="dt">int</span> d,<span class="dt">int</span> e,<span class="dt">int</span> g){</span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="cf">if</span>(a+b+c+d+e==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">1</span>; <span class="dt">long</span> <span class="dt">long</span> &amp;ff=f[a][b][c][d][e][g];</span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="cf">if</span>(ff!=-<span class="dv">1</span>)<span class="cf">return</span> ff; ff=<span class="dv">0</span>;</span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="cf">if</span>(a)ff=(ff+(ll)(a-(g==<span class="dv">1</span>))*dfs(a-<span class="dv">1</span>,b,c,d,e,<span class="dv">0</span>))%mod;</span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span class="cf">if</span>(b)ff=(ff+(ll)(b-(g==<span class="dv">2</span>))*dfs(a+<span class="dv">1</span>,b-<span class="dv">1</span>,c,d,e,<span class="dv">1</span>))%mod;</span>
<span id="cb6-15"><a href="#cb6-15"></a>    <span class="cf">if</span>(c)ff=(ff+(ll)(c-(g==<span class="dv">3</span>))*dfs(a,b+<span class="dv">1</span>,c-<span class="dv">1</span>,d,e,<span class="dv">2</span>))%mod;</span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="cf">if</span>(d)ff=(ff+(ll)(d-(g==<span class="dv">4</span>))*dfs(a,b,c+<span class="dv">1</span>,d-<span class="dv">1</span>,e,<span class="dv">3</span>))%mod;</span>
<span id="cb6-17"><a href="#cb6-17"></a>    <span class="cf">if</span>(e)ff=(ff+(ll)(e-(g==<span class="dv">5</span>))*dfs(a,b,c,d+<span class="dv">1</span>,e-<span class="dv">1</span>,<span class="dv">4</span>))%mod;</span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="cf">return</span> ff;</span>
<span id="cb6-19"><a href="#cb6-19"></a>}</span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="dt">int</span> main(){</span>
<span id="cb6-21"><a href="#cb6-21"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;k); inc(i,<span class="dv">1</span>,k)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;c[i]),rem[c[i]]++;</span>
<span id="cb6-22"><a href="#cb6-22"></a>    memset(f,-<span class="dv">1</span>,<span class="kw">sizeof</span>(f)); printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,dfs(rem[<span class="dv">1</span>],rem[<span class="dv">2</span>],rem[<span class="dv">3</span>],rem[<span class="dv">4</span>],rem[<span class="dv">5</span>],<span class="dv">0</span>));</span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-24"><a href="#cb6-24"></a>}</span></code></pre></div>
<h3 id="bzoj1029jsoi2007建筑抢修2016.5.17">bzoj1029[JSOI2007]建筑抢修（2016.5.17）</h3>
<h4 id="题意-6">题意</h4>
<p>抢修N个建筑。修理工人一次只能修理一个建筑，如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。求一个能抢修尽可能多的建筑的抢修顺序。</p>
<h4 id="题解-6">题解</h4>
<p>贪心。首先按毁坏时间排序，如果按照当前的时间计算能修好这个建筑，就修好它；如果修不好，就找以前修过的建筑，如果修理时间最长的建筑比它修理时间长，就不修这个建筑，改修当前建筑，使当前时间缩短。这个操作用优先队列维护。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">struct</span> task{<span class="dt">int</span> t1,t2;}; task tasks[<span class="dv">200000</span>];</span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="dt">bool</span> cmp(task a,task b){<span class="cf">return</span> a.t2&lt;b.t2;}</span>
<span id="cb7-10"><a href="#cb7-10"></a>priority_queue &lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="dt">int</span> n,tim,ans,a;</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="dt">int</span> main(){</span>
<span id="cb7-13"><a href="#cb7-13"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;tasks[i].t1,&amp;tasks[i].t2); sort(tasks+<span class="dv">1</span>,tasks+n+<span class="dv">1</span>,cmp); tim=ans=<span class="dv">0</span>;</span>
<span id="cb7-14"><a href="#cb7-14"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb7-15"><a href="#cb7-15"></a>        <span class="cf">if</span>(tim+tasks[i].t1&lt;=tasks[i].t2)tim+=tasks[i].t1,q.push(tasks[i].t1),ans++;</span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="cf">else</span> <span class="cf">if</span>(!q.empty()&amp;&amp;tasks[i].t1&lt;(a=q.top())&amp;&amp;tim-a+tasks[i].t1&lt;=tasks[i].t2)</span>
<span id="cb7-17"><a href="#cb7-17"></a>            tim=tim-a+tasks[i].t1,q.pop(),q.push(tasks[i].t1);</span>
<span id="cb7-18"><a href="#cb7-18"></a>    }</span>
<span id="cb7-19"><a href="#cb7-19"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);</span>
<span id="cb7-20"><a href="#cb7-20"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-21"><a href="#cb7-21"></a>}</span></code></pre></div>
<h3 id="bzoj4582usaco2016-opendiamond-collector2016.5.19">bzoj4582[Usaco2016 Open]Diamond Collector（2016.5.19）</h3>
<h4 id="题意-7">题意</h4>
<p>n个钻石，每个都有一个大小，现在将其装进2个盒子里，每个盒子里的钻石最大的与最小的大小不能超过k，问最多能装多少个。n最大50000。</p>
<h4 id="题解-7">题解</h4>
<p>我真傻，真的~首先对大小排序，然后找以i为左端点的可装区间，这个操作两个指针就可以搞，我却以为要二分查找。预处理完了，因为不交错的区间肯定比交错的区间优，所以从n到1递推一下从n到i最大的区间大小是多少，然后枚举每个区间，找到当前区间大小加上右端点+1到n中最大的区间大小中的最大值输出即可。我却以为要找与最大区间不交错的第二大区间，结果WA了好几发，才发现这是错误的贪心QAQ</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="pp">#define maxn </span><span class="dv">60000</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="dt">int</span> n,k,sz[maxn],r,cnt[maxn],mx[maxn];</span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="dt">int</span> main(){</span>
<span id="cb8-11"><a href="#cb8-11"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;sz[i]); sort(sz+<span class="dv">1</span>,sz+n+<span class="dv">1</span>); r=<span class="dv">1</span>;</span>
<span id="cb8-12"><a href="#cb8-12"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb8-13"><a href="#cb8-13"></a>        <span class="cf">while</span>(r&lt;=n&amp;&amp;sz[r]-sz[i]&lt;=k)r++; cnt[i]=r-i;</span>
<span id="cb8-14"><a href="#cb8-14"></a>    }</span>
<span id="cb8-15"><a href="#cb8-15"></a>    mx[n+<span class="dv">1</span>]=<span class="dv">0</span>; dec(i,n,<span class="dv">1</span>)mx[i]=max(mx[i+<span class="dv">1</span>],cnt[i]);</span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="dt">int</span> ans=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)ans=max(ans,cnt[i]+mx[i+cnt[i]]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb8-18"><a href="#cb8-18"></a>}</span></code></pre></div>
<h3 id="bzoj1040zjoi2008骑士2016.5.19">bzoj1040[ZJOI2008]骑士（2016.5.19）</h3>
<h4 id="题意-8">题意</h4>
<p>n个骑士，每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），且有一个战斗力。求从所有的骑士中选出一个骑士之间没有矛盾的骑士军团最大战斗力之和。n最大10e6</p>
<h4 id="题解-8">题解</h4>
<p>厌恶关系实际上是无向的。从每个骑士出发，沿着关系走可以得一个基环树（就是只有一个环，且断了环就会变成一棵树的连通块）。于是先dfs找环，然后断环，分别尝试以去掉的那条边的两个节点u,v为根，作树形dp，将f[u][0]与f[v][0]的最大值计入答案。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="dt">bool</span> vis[maxn]; ll f[maxn][<span class="dv">2</span>],w[maxn]; <span class="dt">int</span> n,bad;</span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,n;}; e es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){</span>
<span id="cb9-12"><a href="#cb9-12"></a>    es[++ess]=(e){f,t,g[f]}; g[f]=ess; es[++ess]=(e){t,f,g[t]}; g[t]=ess;</span>
<span id="cb9-13"><a href="#cb9-13"></a>}</span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> fa){</span>
<span id="cb9-15"><a href="#cb9-15"></a>    vis[x]=<span class="dv">1</span>;</span>
<span id="cb9-16"><a href="#cb9-16"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(i!=fa){</span>
<span id="cb9-17"><a href="#cb9-17"></a>        <span class="cf">if</span>(vis[es[i].t])bad=i;<span class="cf">else</span> dfs(es[i].t,i^<span class="dv">1</span>);</span>
<span id="cb9-18"><a href="#cb9-18"></a>    }</span>
<span id="cb9-19"><a href="#cb9-19"></a>}</span>
<span id="cb9-20"><a href="#cb9-20"></a>ll dp(<span class="dt">int</span> x,<span class="dt">int</span> fa,<span class="dt">int</span> b){</span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="cf">if</span>(f[x][b]!=-<span class="dv">1</span>)<span class="cf">return</span> f[x][b]; f[x][b]=<span class="dv">0</span>; <span class="co">//printf(&quot;%d %d %d %d %d\n&quot;,x,fa,b,f[x][b]);</span></span>
<span id="cb9-22"><a href="#cb9-22"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(i!=fa&amp;&amp;i!=bad&amp;&amp;i!=(bad^<span class="dv">1</span>)){</span>
<span id="cb9-23"><a href="#cb9-23"></a>        <span class="cf">if</span>(!b)f[x][b]+=max(dp(es[i].t,i^<span class="dv">1</span>,<span class="dv">0</span>),dp(es[i].t,i^<span class="dv">1</span>,<span class="dv">1</span>)+w[es[i].t]);</span>
<span id="cb9-24"><a href="#cb9-24"></a>        <span class="cf">else</span> f[x][b]+=dp(es[i].t,i^<span class="dv">1</span>,<span class="dv">0</span>);</span>
<span id="cb9-25"><a href="#cb9-25"></a>    }</span>
<span id="cb9-26"><a href="#cb9-26"></a>    <span class="cf">return</span> f[x][b];</span>
<span id="cb9-27"><a href="#cb9-27"></a>}</span>
<span id="cb9-28"><a href="#cb9-28"></a><span class="dt">int</span> main(){</span>
<span id="cb9-29"><a href="#cb9-29"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); ll ans=<span class="dv">0</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g)); ess=-<span class="dv">1</span>;</span>
<span id="cb9-30"><a href="#cb9-30"></a>    inc(i,<span class="dv">1</span>,n){ll a; <span class="dt">int</span> b; scanf(<span class="st">&quot;</span><span class="sc">%lld%d</span><span class="st">&quot;</span>,&amp;a,&amp;b); w[i]=a; pe(i,b);}</span>
<span id="cb9-31"><a href="#cb9-31"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!vis[i]){</span>
<span id="cb9-32"><a href="#cb9-32"></a>        dfs(i,-<span class="dv">1</span>); ll mx=<span class="dv">0</span>;</span>
<span id="cb9-33"><a href="#cb9-33"></a>        memset(f,-<span class="dv">1</span>,<span class="kw">sizeof</span>(f)); mx=max(mx,dp(es[bad].f,-<span class="dv">1</span>,<span class="dv">0</span>));</span>
<span id="cb9-34"><a href="#cb9-34"></a>        memset(f,-<span class="dv">1</span>,<span class="kw">sizeof</span>(f)); mx=max(mx,dp(es[bad].t,-<span class="dv">1</span>,<span class="dv">0</span>));</span>
<span id="cb9-35"><a href="#cb9-35"></a>        ans+=mx;</span>
<span id="cb9-36"><a href="#cb9-36"></a>    }</span>
<span id="cb9-37"><a href="#cb9-37"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans);</span>
<span id="cb9-38"><a href="#cb9-38"></a>}</span></code></pre></div>
<h3 id="bzoj1816cqoi2010扑克牌2016.5.20">bzoj1816[Cqoi2010]扑克牌（2016.5.20）</h3>
<h4 id="题意-9">题意</h4>
<p>n种牌，第i种牌的数目为ci还有m张鬼。可以用每种牌各一张来组成一套牌，其中一张可以用鬼代替。求最多可组几套牌。n最大50。</p>
<h4 id="题解-9">题解</h4>
<p>其实这道题我不是特别理解。做法是二分可组多少套，累加套数减每个ci的差，如果这个累加和大于m与套数比较的最小值就不为可行解。还要再思考。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="dt">int</span> a[<span class="dv">60</span>],n,m;</span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="dt">bool</span> check(<span class="dt">int</span> x){</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="dt">int</span> y=min(x,m); inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(x&gt;a[i]){y-=(x-a[i]); <span class="cf">if</span>(y&lt;<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">0</span>;} <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb10-10"><a href="#cb10-10"></a>}</span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="dt">int</span> main(){</span>
<span id="cb10-12"><a href="#cb10-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a[i]);</span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="dt">int</span> l=<span class="dv">0</span>,r=<span class="dv">1000000000</span>,ans;</span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="cf">while</span>(l&lt;=r){</span>
<span id="cb10-15"><a href="#cb10-15"></a>        <span class="dt">int</span> mid=l+((r-l)&gt;&gt;<span class="dv">1</span>); <span class="cf">if</span>(check(mid))ans=mid,l=mid+<span class="dv">1</span>;<span class="cf">else</span> r=mid-<span class="dv">1</span>;</span>
<span id="cb10-16"><a href="#cb10-16"></a>    }</span>
<span id="cb10-17"><a href="#cb10-17"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);</span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-19"><a href="#cb10-19"></a>}</span></code></pre></div>
<h3 id="bzoj1096zjoi2007仓库建设2016.5.20">bzoj1096[ZJOI2007]仓库建设（2016.5.20）</h3>
<h4 id="题意-10">题意</h4>
<p>N个工厂，第i个工厂目前已有成品Pi件，在第i个工厂位置建立仓库的费用是Ci。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，产品都只能运往编号更大的工厂的仓库，一件产品运送1个单位距离的费用是1。求最小总费用（建造费用+运输费用）。N最大10e6</p>
<h4 id="题解-10">题解</h4>
<p>斜率优化dp。我公式推错了3次QAQ</p>
<p>f[i]=max{f[j]+sigma(k,j+1,i)(x[i]-x[k])*p[k]+c[i]} =max{f[j]+sigma(k,j+1,i)x[i]*p[k]-sigma(k,j+1,i)x[k]*p[k]+c[i]} =max{f[j]+(sump[i]-sump[j])*x[i]-(sumxp[i]-sumxp[j])+c[i]} =max{f[j]+sump[i]*x[i]-sump[j]*x[i]-sumxp[i]+sumxp[j]+c[i]}</p>
<p>f[j]+sump[i]*x[i]-sump[j]*x[i]-sumxp[i]+sumxp[j]+c[i]&lt;f[k]+sump[i]*x[i]-sump[k]*x[i]-sumxp[i]+sumxp[k]+c[i] f[j]-f[k]+sumxp[j]-sumxp[k]&lt;sump[j]*x[i]-sump[k]*x[i] (f[j]-f[k]+sumxp[j]-sumxp[k])/(sump[j]-sump[k])&gt;x[i]（j在k前面）</p>
<p>注意开始是单调队列里要有一个f[0]，因为不需要一定在1处建仓库（本弱和标程对拍才发现这个错误，好弱啊！）</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="pp">#define maxn </span><span class="dv">1000100</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a>ll sump[maxn],sumxp[maxn],f[maxn],c[maxn],x[maxn]; <span class="dt">int</span> n,q[maxn],l,r;</span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="dt">double</span> calc(<span class="dt">int</span> j,<span class="dt">int</span> k){</span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="cf">return</span> (<span class="dt">double</span>)(f[j]-f[k]+sumxp[j]-sumxp[k])/(<span class="dt">double</span>)(sump[j]-sump[k]);</span>
<span id="cb11-13"><a href="#cb11-13"></a>}</span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="dt">int</span> main(){</span>
<span id="cb11-15"><a href="#cb11-15"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); sump[<span class="dv">0</span>]=sumxp[<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb11-16"><a href="#cb11-16"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb11-17"><a href="#cb11-17"></a>        ll p; scanf(<span class="st">&quot;</span><span class="sc">%lld%lld%lld</span><span class="st">&quot;</span>,&amp;x[i],&amp;p,&amp;c[i]); sump[i]=sump[i-<span class="dv">1</span>]+p; sumxp[i]=sumxp[i-<span class="dv">1</span>]+x[i]*p;</span>
<span id="cb11-18"><a href="#cb11-18"></a>    }</span>
<span id="cb11-19"><a href="#cb11-19"></a>    l=<span class="dv">0</span>; r=<span class="dv">0</span>; q[l]=<span class="dv">0</span>; f[<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb11-20"><a href="#cb11-20"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb11-21"><a href="#cb11-21"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[l],q[l+<span class="dv">1</span>])&lt;x[i])l++;</span>
<span id="cb11-22"><a href="#cb11-22"></a>        f[i]=f[q[l]]+sump[i]*x[i]-sump[q[l]]*x[i]-sumxp[i]+sumxp[q[l]]+c[i];</span>
<span id="cb11-23"><a href="#cb11-23"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[r],i)&lt;calc(q[r-<span class="dv">1</span>],q[r]))r--; q[++r]=i;</span>
<span id="cb11-24"><a href="#cb11-24"></a>    }</span>
<span id="cb11-25"><a href="#cb11-25"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f[n]);</span>
<span id="cb11-26"><a href="#cb11-26"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-27"><a href="#cb11-27"></a>}</span></code></pre></div>
<h3 id="bzoj2338hnoi2011数矩形2016.5.20">bzoj2338[HNOI2011]数矩形（2016.5.20）</h3>
<h4 id="题意-11">题意</h4>
<p>n个顶点，找一个矩形，使其面积最大。注意：矩形的边不一定要和坐标轴平行！</p>
<h4 id="题解-11">题解</h4>
<p>先将点两两组成线段，然后将它们按中点和长度排序，则每组中点和长度都相等的线段<strong>两两都可以组成矩形</strong>，比较它们的面积就行。求面积用叉积（即两个向量末端点与它们的和末端点组成的平行四边形的面积，公式：x1*y2-x2*y1或|a|*|b|*sin&lt;a,b&gt;）除以2。反思：本蒟蒻正因为加粗部分WA了，而且本题的数据似乎并没有那么大，才能这样写。</p>
<h4 id="两两">两两</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="pp">#define maxn </span><span class="dv">2000</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="kw">inline</span> ll sqr(ll a){<span class="cf">return</span> a*a;}</span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="kw">struct</span> line{ll x1,y1,x2,y2;}; line lines[maxn*maxn]; <span class="dt">int</span> linen;</span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="kw">inline</span> ll length(line a){<span class="cf">return</span> sqr(a.x1-a.x2)+sqr(a.y1-a.y2);}</span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="dt">bool</span> cmp(line a,line b){</span>
<span id="cb12-14"><a href="#cb12-14"></a>    <span class="cf">if</span>(a.x1+a.x2==b.x1+b.x2&amp;&amp;a.y1+a.y2==b.y1+b.y2)</span>
<span id="cb12-15"><a href="#cb12-15"></a>        <span class="cf">return</span> length(a)&lt;length(b);</span>
<span id="cb12-16"><a href="#cb12-16"></a>    <span class="cf">else</span> <span class="cf">return</span> a.x1+a.x2==b.x1+b.x2?a.y1+a.y2&lt;b.y1+b.y2:a.x1+a.x2&lt;b.x1+b.x2;</span>
<span id="cb12-17"><a href="#cb12-17"></a>}</span>
<span id="cb12-18"><a href="#cb12-18"></a>ll x[maxn],y[maxn]; <span class="dt">int</span> n;</span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="dt">int</span> main(){</span>
<span id="cb12-20"><a href="#cb12-20"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lld%lld</span><span class="st">&quot;</span>,&amp;x[i],&amp;y[i]); linen=<span class="dv">0</span>;</span>
<span id="cb12-21"><a href="#cb12-21"></a>    inc(i,<span class="dv">1</span>,n)inc(j,i+<span class="dv">1</span>,n)lines[++linen]=(line){x[i],y[i],x[j],y[j]};</span>
<span id="cb12-22"><a href="#cb12-22"></a>    sort(lines+<span class="dv">1</span>,lines+<span class="dv">1</span>+linen,cmp); ll mx=<span class="dv">0</span>;</span>
<span id="cb12-23"><a href="#cb12-23"></a>    inc(i,<span class="dv">1</span>,linen-<span class="dv">1</span>){</span>
<span id="cb12-24"><a href="#cb12-24"></a>        line &amp;a=lines[i]; <span class="dt">int</span> j=i+<span class="dv">1</span>;</span>
<span id="cb12-25"><a href="#cb12-25"></a>        <span class="cf">while</span>(j&lt;=linen&amp;&amp;length(a)==length(lines[j])&amp;&amp;a.x1+a.x2==lines[j].x1+lines[j].x2&amp;&amp;a.y1+a.y2==lines[j].y1+lines[j].y2)</span>
<span id="cb12-26"><a href="#cb12-26"></a>            mx=max(mx,abs((a.x2-a.x1)*(lines[j].y2-lines[j].y1)-(a.y2-a.y1)*(lines[j].x2-lines[j].x1))&gt;&gt;<span class="dv">1</span>),j++;</span>
<span id="cb12-27"><a href="#cb12-27"></a>    }</span>
<span id="cb12-28"><a href="#cb12-28"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,mx); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb12-29"><a href="#cb12-29"></a>}</span></code></pre></div>
<h3 id="bzoj1854scoi2010游戏2016.5.20">bzoj1854[Scoi2010]游戏（2016.5.20）</h3>
<h4 id="题意-12">题意</h4>
<p>n个装备，每种装备都有2个属性值，分别用[1,10000]之间的数表示。使用某种装备时，只能使用该装备的某一个属性。并且每种装备最多只能使用一次。攻击boss的装备所使用的属性值必须从1开始连续递增地攻击，才能对boss产生伤害。求最多能连续攻击boss多少次。</p>
<h4 id="题解-12">题解</h4>
<p>本题竟然用并查集！把每个装备看成1条无向边，当n条边没有组成一个环时，则一共可以得到n-1个属性，如果n条边组成了一个环，则可以得到n个属性。因此可以使用并查集，根据它除了并操作不会改变根节点的性质，用它维护一个vis数组表示第i个属性能否得到，当一条边插入时，如果两个端点不在一个联通块中，就将根节点表示属性小的那个联通块连到大的那个，并将小的联通块根节点的vis置为1，大的不变；如果在一个联通块中，就将该联通块根节点vis置为1。最后枚举一下vis从1到多少均为1就是答案。</p>
<p>注意：因为我的程序是枚举到vis为0的那个值退出，由于属性最大是10000，所以要枚举到10001。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="dt">bool</span> vis[<span class="dv">20000</span>]; <span class="dt">int</span> fa[<span class="dv">20000</span>],n;</span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="dt">int</span> main(){</span>
<span id="cb13-10"><a href="#cb13-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,<span class="dv">10000</span>)fa[i]=i; memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis));</span>
<span id="cb13-11"><a href="#cb13-11"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb13-12"><a href="#cb13-12"></a>        <span class="dt">int</span> a,b,x,y; scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b); x=find(a); y=find(b);</span>
<span id="cb13-13"><a href="#cb13-13"></a>        <span class="cf">if</span>(x==y)vis[x]=<span class="dv">1</span>;<span class="cf">else</span>{<span class="cf">if</span>(x&gt;y)swap(x,y); fa[x]=y; vis[x]=<span class="dv">1</span>;}</span>
<span id="cb13-14"><a href="#cb13-14"></a>    }</span>
<span id="cb13-15"><a href="#cb13-15"></a>    inc(i,<span class="dv">1</span>,<span class="dv">10001</span>)<span class="cf">if</span>(!vis[i]){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,i-<span class="dv">1</span>); <span class="cf">break</span>;}</span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-17"><a href="#cb13-17"></a>}</span></code></pre></div>
<h3 id="bzoj2561最小生成树2016.5.23">bzoj2561最小生成树（2016.5.23）</h3>
<h4 id="题意-13">题意</h4>
<p>给定一个连通无向图，假设现在加入一条边权为L的边(u,v)，求需要删掉最少多少条边，才能够使得这条边既可能出现在最小生成树上，也可能出现在最大生成树上。</p>
<h4 id="题解-13">题解</h4>
<p>最小割。如果一个边出现在最小生成树上，那么权值比它小的边一定不能使图联通。因为要求删掉最少，所以当加入这条边后整个图刚好联通。因此可以将这条边的一个端点作为源，另一端点作为汇，插入所以权值比L小的边，每条边流量为1，跑最小割，求出来的答案就是使源、汇不联通最少删掉边。最大生成树同理，插入的是权值比L大的。最后答案是两次跑最小割的结果相加。反思：注意边要开到4倍，而且图中边是无向边，在网络流插边时要插两个方向。这道题也告诉我们实际上数据范围上万的可能也是用网络流。dinic/ISAP的玄学复杂度QAQ</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="pp">#define maxn </span><span class="dv">30000</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,c,n;}; e es[maxn*<span class="dv">40</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c){</span>
<span id="cb14-12"><a href="#cb14-12"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,g[t]}; g[t]=ess;</span>
<span id="cb14-13"><a href="#cb14-13"></a>}</span>
<span id="cb14-14"><a href="#cb14-14"></a><span class="kw">inline</span> <span class="dt">void</span> init(){</span>
<span id="cb14-15"><a href="#cb14-15"></a>    ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb14-16"><a href="#cb14-16"></a>}</span>
<span id="cb14-17"><a href="#cb14-17"></a>queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> h[maxn];</span>
<span id="cb14-18"><a href="#cb14-18"></a><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb14-19"><a href="#cb14-19"></a>    memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); <span class="cf">while</span>(!q.empty())q.pop(); h[s]=<span class="dv">0</span>; q.push(s);</span>
<span id="cb14-20"><a href="#cb14-20"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb14-21"><a href="#cb14-21"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb14-22"><a href="#cb14-22"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==-<span class="dv">1</span>)h[es[i].t]=h[x]+<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb14-23"><a href="#cb14-23"></a>    }</span>
<span id="cb14-24"><a href="#cb14-24"></a>    <span class="cf">return</span> h[t]!=-<span class="dv">1</span>;</span>
<span id="cb14-25"><a href="#cb14-25"></a>}</span>
<span id="cb14-26"><a href="#cb14-26"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> t,<span class="dt">int</span> f){</span>
<span id="cb14-27"><a href="#cb14-27"></a>    <span class="cf">if</span>(x==t)<span class="cf">return</span> f; <span class="dt">int</span> u=<span class="dv">0</span>;</span>
<span id="cb14-28"><a href="#cb14-28"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==h[x]+<span class="dv">1</span>){</span>
<span id="cb14-29"><a href="#cb14-29"></a>        <span class="dt">int</span> w=dfs(es[i].t,t,min(f,es[i].c)); f-=w; u+=w; es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; <span class="cf">if</span>(f==<span class="dv">0</span>)<span class="cf">return</span> u;</span>
<span id="cb14-30"><a href="#cb14-30"></a>    }</span>
<span id="cb14-31"><a href="#cb14-31"></a>    <span class="cf">if</span>(u==<span class="dv">0</span>)h[x]=-<span class="dv">1</span>; <span class="cf">return</span> u;</span>
<span id="cb14-32"><a href="#cb14-32"></a>}</span>
<span id="cb14-33"><a href="#cb14-33"></a><span class="dt">int</span> dinic(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb14-34"><a href="#cb14-34"></a>    <span class="dt">int</span> f=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))f+=dfs(s,t,INF); <span class="cf">return</span> f;</span>
<span id="cb14-35"><a href="#cb14-35"></a>}</span>
<span id="cb14-36"><a href="#cb14-36"></a><span class="dt">int</span> n,m,u[maxn*<span class="dv">10</span>],v[maxn*<span class="dv">10</span>],w[maxn*<span class="dv">10</span>],U,V,L;</span>
<span id="cb14-37"><a href="#cb14-37"></a><span class="dt">int</span> main(){</span>
<span id="cb14-38"><a href="#cb14-38"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,m)scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;u[i],&amp;v[i],&amp;w[i]); scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;U,&amp;V,&amp;L); <span class="dt">int</span> ans=<span class="dv">0</span>;</span>
<span id="cb14-39"><a href="#cb14-39"></a>    init(); inc(i,<span class="dv">1</span>,m)<span class="cf">if</span>(w[i]&lt;L)pe(u[i],v[i],<span class="dv">1</span>),pe(v[i],u[i],<span class="dv">1</span>); ans+=dinic(U,V);</span>
<span id="cb14-40"><a href="#cb14-40"></a>    init(); inc(i,<span class="dv">1</span>,m)<span class="cf">if</span>(w[i]&gt;L)pe(u[i],v[i],<span class="dv">1</span>),pe(v[i],u[i],<span class="dv">1</span>); ans+=dinic(U,V);</span>
<span id="cb14-41"><a href="#cb14-41"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-42"><a href="#cb14-42"></a>}</span></code></pre></div>
<h3 id="bzoj1024scoi2009生日快乐2016.5.23">bzoj1024[SCOI2009]生日快乐（2016.5.23）</h3>
<h4 id="题意-14">题意</h4>
<p>一个矩形蛋糕边长分别为X和Y，须切成N块面积相等的蛋糕。每一切只能平行于一块蛋糕的任意一边，并且必须把这块蛋糕切成两块。因此必须切 N-1 次。求 N块蛋糕的长边与短边的比值的最大值的最小值。X，Y≤10000，N≤10</p>
<h4 id="题解-14">题解</h4>
<p>爆搜，dfs(x,y,cnt)表示要把长为x宽为y的蛋糕切成cnt块，因为只能切在x/cnt或y/cnt的倍数的位置上，所以每次枚举切哪个位置就行了。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">double</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb15-7"><a href="#cb15-7"></a></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="dt">double</span> dfs(<span class="dt">double</span> x,<span class="dt">double</span> y,<span class="dt">double</span> cnt){</span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="cf">if</span>(cnt==<span class="dv">1</span>)<span class="cf">return</span> max(x,y)/min(x,y); <span class="dt">double</span> ans=INF;</span>
<span id="cb15-10"><a href="#cb15-10"></a>    inc(i,<span class="dv">1</span>,cnt-<span class="dv">1</span>){</span>
<span id="cb15-11"><a href="#cb15-11"></a>        ans=min(ans,max(dfs(x/cnt*i,y,i),dfs(x/cnt*(cnt-i),y,cnt-i)));</span>
<span id="cb15-12"><a href="#cb15-12"></a>        ans=min(ans,max(dfs(x,y/cnt*i,i),dfs(x,y/cnt*(cnt-i),cnt-i)));</span>
<span id="cb15-13"><a href="#cb15-13"></a>    }</span>
<span id="cb15-14"><a href="#cb15-14"></a>    <span class="cf">return</span> ans;</span>
<span id="cb15-15"><a href="#cb15-15"></a>}</span>
<span id="cb15-16"><a href="#cb15-16"></a><span class="dt">int</span> x,y,n;</span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="dt">int</span> main(){</span>
<span id="cb15-18"><a href="#cb15-18"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y,&amp;n); printf(<span class="st">&quot;%.6lf&quot;</span>,dfs((<span class="dt">double</span>)x,(<span class="dt">double</span>)y,(<span class="dt">double</span>)n)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-19"><a href="#cb15-19"></a>}</span></code></pre></div>
<h3 id="bzoj1034zjoi2008泡泡堂bnb2016.5.24">bzoj1034[ZJOI2008]泡泡堂BNB（2016.5.24）</h3>
<h4 id="题意-15">题意</h4>
<p>n场比赛，知道自己所有选手的能力值和对方所有选手的能力值，能力值大的一定赢。比赛赢一场得2分，平局得1分，输了不得分。对方随机决定选手顺序，你想知道自己最多能得多少分和最少能得多少分。N≤100000</p>
<h4 id="题解-15">题解</h4>
<p>贪心。设一个高分方和低分方，将两方选手按能力排好序。如果高分方目前最强能赢低分方目前最强，就让他们比赛；如果高分方目前最弱能赢低分方目前最弱，也让他们比赛；否则用高分方最弱的和低分方最强的打。开始先让自己方为高分方，求最大值，再让对方做高分方，本方最小值就是2*n-对方得分。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="pp">#define maxn </span><span class="dv">200000</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="dt">int</span> a[maxn],b[maxn],n,ans,la,ra,lb,rb;</span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="dt">int</span> main(){</span>
<span id="cb16-10"><a href="#cb16-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a[i]); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;b[i]); sort(a+<span class="dv">1</span>,a+<span class="dv">1</span>+n); sort(b+<span class="dv">1</span>,b+<span class="dv">1</span>+n);</span>
<span id="cb16-11"><a href="#cb16-11"></a>    ans=<span class="dv">0</span>; la=<span class="dv">1</span>; ra=n; lb=<span class="dv">1</span>; rb=n;</span>
<span id="cb16-12"><a href="#cb16-12"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb16-13"><a href="#cb16-13"></a>        <span class="cf">if</span>(a[ra]&gt;b[rb])ra--,rb--,ans+=<span class="dv">2</span>;<span class="cf">else</span> <span class="cf">if</span>(a[la]&gt;b[lb])la++,lb++,ans+=<span class="dv">2</span>;<span class="cf">else</span> ans+=(a[la]==b[rb]),la++,rb--;</span>
<span id="cb16-14"><a href="#cb16-14"></a>    }</span>
<span id="cb16-15"><a href="#cb16-15"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>,ans); swap(a,b);</span>
<span id="cb16-16"><a href="#cb16-16"></a>    ans=<span class="dv">0</span>; la=<span class="dv">1</span>; ra=n; lb=<span class="dv">1</span>; rb=n;</span>
<span id="cb16-17"><a href="#cb16-17"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb16-18"><a href="#cb16-18"></a>        <span class="cf">if</span>(a[ra]&gt;b[rb])ra--,rb--,ans+=<span class="dv">2</span>;<span class="cf">else</span> <span class="cf">if</span>(a[la]&gt;b[lb])la++,lb++,ans+=<span class="dv">2</span>;<span class="cf">else</span> ans+=(a[la]==b[rb]),la++,rb--;</span>
<span id="cb16-19"><a href="#cb16-19"></a>    }</span>
<span id="cb16-20"><a href="#cb16-20"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,<span class="dv">2</span>*n-ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb16-21"><a href="#cb16-21"></a>}</span></code></pre></div>
<h3 id="bzoj1497noi2006最大获利2016.5.24">bzoj1497[NOI2006]最大获利（2016.5.24）</h3>
<h4 id="题意-16">题意</h4>
<p>N个地方，在i处建立通讯中转站需要的成本为Pi。M个用户，第i个用户会使用中转站Ai和中转站Bi进行通讯，公司可以获益Ci。求净获利最大值。N≤5000，M≤50000</p>
<h4 id="题解-16">题解</h4>
<p>最小割。源点向所有地方连边，流量为建站成本，第Ai个地方和第Bi个地方分别向第i个用户连边，流量无穷，所有用户向汇点连边，流量为获益。这样割源点与地方的连边表示付出成本，割用户与汇点的连边表示放弃利益。最后答案是所有获益和-最小割。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="pp">#define maxn </span><span class="dv">60000</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb17-9"><a href="#cb17-9"></a></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,c,n;}; e es[maxn*<span class="dv">20</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c){</span>
<span id="cb17-12"><a href="#cb17-12"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,g[t]}; g[t]=ess;</span>
<span id="cb17-13"><a href="#cb17-13"></a>}</span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="kw">inline</span> <span class="dt">void</span> init(){</span>
<span id="cb17-15"><a href="#cb17-15"></a>    ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb17-16"><a href="#cb17-16"></a>}</span>
<span id="cb17-17"><a href="#cb17-17"></a>queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> h[maxn];</span>
<span id="cb17-18"><a href="#cb17-18"></a><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb17-19"><a href="#cb17-19"></a>    memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); <span class="cf">while</span>(!q.empty())q.pop(); h[s]=<span class="dv">0</span>; q.push(s);</span>
<span id="cb17-20"><a href="#cb17-20"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb17-21"><a href="#cb17-21"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb17-22"><a href="#cb17-22"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==-<span class="dv">1</span>)h[es[i].t]=h[x]+<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb17-23"><a href="#cb17-23"></a>    }</span>
<span id="cb17-24"><a href="#cb17-24"></a>    <span class="cf">return</span> h[t]!=-<span class="dv">1</span>;</span>
<span id="cb17-25"><a href="#cb17-25"></a>}</span>
<span id="cb17-26"><a href="#cb17-26"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> t,<span class="dt">int</span> f){</span>
<span id="cb17-27"><a href="#cb17-27"></a>    <span class="cf">if</span>(x==t)<span class="cf">return</span> f; <span class="dt">int</span> u=<span class="dv">0</span>;</span>
<span id="cb17-28"><a href="#cb17-28"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==h[x]+<span class="dv">1</span>){</span>
<span id="cb17-29"><a href="#cb17-29"></a>        <span class="dt">int</span> w=dfs(es[i].t,t,min(f,es[i].c)); f-=w; u+=w; es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; <span class="cf">if</span>(f==<span class="dv">0</span>)<span class="cf">return</span> u;</span>
<span id="cb17-30"><a href="#cb17-30"></a>    }</span>
<span id="cb17-31"><a href="#cb17-31"></a>    <span class="cf">if</span>(u==<span class="dv">0</span>)h[x]=-<span class="dv">1</span>; <span class="cf">return</span> u;</span>
<span id="cb17-32"><a href="#cb17-32"></a>}</span>
<span id="cb17-33"><a href="#cb17-33"></a><span class="dt">int</span> dinic(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb17-34"><a href="#cb17-34"></a>    <span class="dt">int</span> f=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))f+=dfs(s,t,INF); <span class="cf">return</span> f;</span>
<span id="cb17-35"><a href="#cb17-35"></a>}</span>
<span id="cb17-36"><a href="#cb17-36"></a><span class="dt">int</span> n,m,s,t,tot;</span>
<span id="cb17-37"><a href="#cb17-37"></a><span class="dt">int</span> main(){</span>
<span id="cb17-38"><a href="#cb17-38"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); s=<span class="dv">0</span>; t=n+m+<span class="dv">1</span>; init();</span>
<span id="cb17-39"><a href="#cb17-39"></a>    inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a); pe(s,i,a);}</span>
<span id="cb17-40"><a href="#cb17-40"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a,b,c; scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); pe(a,n+i,INF); pe(b,n+i,INF); pe(n+i,t,c); tot+=c;}</span>
<span id="cb17-41"><a href="#cb17-41"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,tot-dinic(s,t)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb17-42"><a href="#cb17-42"></a>}</span></code></pre></div>
<h3 id="bzoj1878sdoi2009hh的项链2016.5.25">bzoj1878[SDOI2009]HH的项链（2016.5.25）</h3>
<h4 id="题意-17">题意</h4>
<p>N个数，M个询问求区间[L,R]中包含了多少种不同的数。</p>
<h4 id="题解-17">题解</h4>
<p>莫队好像可以做~但正解是树状数组。先将询问按左端点排序，并求出每个数的下一个与它相等的数的位置，同时将每个数第一次出现的位置在树状数组中置为1，此时query(x)求出来的就是1到x里有多少个不同的数。枚举排序后的询问，将当前左端点向右移动，每右移一位就将原位置的数的下一个与它相同的数的位置在树状数组中置为1，保证如果这个数在[l,r]中出现不会漏算。当左端点移动到询问的左端点位置时，就输出query(r)-query(l-1)，表示l到r里有多少个不同的数。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="pp">#define maxn </span><span class="dv">50100</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x;</span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="dt">int</span> a[maxn],last[maxn*<span class="dv">20</span>],next[maxn],sm[maxn],n,m;</span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="kw">struct</span> ask{<span class="dt">int</span> l,r,ans,id;}; ask asks[maxn*<span class="dv">6</span>];</span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="dt">bool</span> cmp1(ask a,ask b){<span class="cf">return</span> a.l&lt;b.l;}</span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="dt">bool</span> cmp2(ask a,ask b){<span class="cf">return</span> a.id&lt;b.id;}</span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="kw">inline</span> <span class="dt">void</span> update(<span class="dt">int</span> x,<span class="dt">int</span> v){<span class="cf">while</span>(x&lt;=n){sm[x]+=v,x+=lb(x);}}</span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="kw">inline</span> <span class="dt">int</span> query(<span class="dt">int</span> x){<span class="dt">int</span> q=<span class="dv">0</span>; <span class="cf">while</span>(x&gt;<span class="dv">0</span>){q+=sm[x],x-=lb(x);} <span class="cf">return</span> q;}</span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="dt">int</span> main(){</span>
<span id="cb18-16"><a href="#cb18-16"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a[i]);</span>
<span id="cb18-17"><a href="#cb18-17"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;m); inc(i,<span class="dv">1</span>,m)scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;asks[i].l,&amp;asks[i].r),asks[i].id=i;</span>
<span id="cb18-18"><a href="#cb18-18"></a>    memset(last,<span class="dv">0</span>,<span class="kw">sizeof</span>(last)); inc(i,<span class="dv">1</span>,n){<span class="cf">if</span>(last[a[i]])next[last[a[i]]]=i;<span class="cf">else</span> update(i,<span class="dv">1</span>); last[a[i]]=i;}</span>
<span id="cb18-19"><a href="#cb18-19"></a>    sort(asks+<span class="dv">1</span>,asks+<span class="dv">1</span>+m,cmp1); <span class="dt">int</span> l=<span class="dv">1</span>;</span>
<span id="cb18-20"><a href="#cb18-20"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb18-21"><a href="#cb18-21"></a>        <span class="cf">while</span>(l&lt;asks[i].l){<span class="cf">if</span>(next[l])update(next[l],<span class="dv">1</span>); l++;}</span>
<span id="cb18-22"><a href="#cb18-22"></a>        asks[i].ans=query(asks[i].r)-query(asks[i].l-<span class="dv">1</span>);</span>
<span id="cb18-23"><a href="#cb18-23"></a>    }</span>
<span id="cb18-24"><a href="#cb18-24"></a>    sort(asks+<span class="dv">1</span>,asks+<span class="dv">1</span>+m,cmp2); inc(i,<span class="dv">1</span>,m)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,asks[i].ans);</span>
<span id="cb18-25"><a href="#cb18-25"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-26"><a href="#cb18-26"></a>}</span></code></pre></div>
<h3 id="bzoj1047haoi2007理想的正方形2016.5.27">bzoj1047[HAOI2007]理想的正方形（2016.5.27）</h3>
<h4 id="题意-18">题意</h4>
<p>有一个a*b的整数组成的矩阵，求一个n*n的正方形区域，使得该区域所有数中的最大值和最小值的差最小。a,b≤1000，n≤100</p>
<h4 id="题解-18">题解</h4>
<p>做4次单调队列。先利用单调队列求出第i行第j列到第i行第j+n-1列的最大最小值，再利用这个求出第i行第j列到第i+n-1行第j+n-1列的最大最小值。最后枚举一下求最小的差就行了。反思：本蒟蒻单调队列开始各种符号写反，比如判断是否要l++的那个条件。以及因为INF设得太小WA了一发，拍都拍不出，最后改成2147483647乱交一发结果过了。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="pp">#define maxn </span><span class="dv">1500</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="pp">#define INF </span><span class="dv">2147483647</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb19-8"><a href="#cb19-8"></a></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="dt">int</span> maxh[maxn][maxn],minh[maxn][maxn],maxl[maxn][maxn],minl[maxn][maxn];</span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="dt">int</span> v[maxn][maxn],q1[maxn],q2[maxn],a,b,n,l,r,ans;</span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="dt">int</span> main(){</span>
<span id="cb19-12"><a href="#cb19-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;n); inc(i,<span class="dv">1</span>,a)inc(j,<span class="dv">1</span>,b)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;v[i][j]);</span>
<span id="cb19-13"><a href="#cb19-13"></a>    inc(i,<span class="dv">1</span>,a){</span>
<span id="cb19-14"><a href="#cb19-14"></a>        l=<span class="dv">1</span>; r=<span class="dv">0</span>;</span>
<span id="cb19-15"><a href="#cb19-15"></a>        inc(j,<span class="dv">1</span>,n){<span class="cf">while</span>(r&gt;=l&amp;&amp;v[i][j]&gt;q1[r])r--; q1[++r]=v[i][j]; q2[r]=j;} maxh[i][<span class="dv">1</span>]=q1[l];</span>
<span id="cb19-16"><a href="#cb19-16"></a>        inc(j,n+<span class="dv">1</span>,b){</span>
<span id="cb19-17"><a href="#cb19-17"></a>            <span class="cf">if</span>(j-n&gt;=q2[l])l++; <span class="cf">while</span>(r&gt;=l&amp;&amp;v[i][j]&gt;q1[r])r--;</span>
<span id="cb19-18"><a href="#cb19-18"></a>            q1[++r]=v[i][j]; q2[r]=j; maxh[i][j-n+<span class="dv">1</span>]=q1[l];</span>
<span id="cb19-19"><a href="#cb19-19"></a>        }</span>
<span id="cb19-20"><a href="#cb19-20"></a>    }</span>
<span id="cb19-21"><a href="#cb19-21"></a>    inc(i,<span class="dv">1</span>,a){</span>
<span id="cb19-22"><a href="#cb19-22"></a>        l=<span class="dv">1</span>; r=<span class="dv">0</span>;</span>
<span id="cb19-23"><a href="#cb19-23"></a>        inc(j,<span class="dv">1</span>,n){<span class="cf">while</span>(r&gt;=l&amp;&amp;v[i][j]&lt;q1[r])r--; q1[++r]=v[i][j]; q2[r]=j;} minh[i][<span class="dv">1</span>]=q1[l];</span>
<span id="cb19-24"><a href="#cb19-24"></a>        inc(j,n+<span class="dv">1</span>,b){</span>
<span id="cb19-25"><a href="#cb19-25"></a>            <span class="cf">if</span>(j-n&gt;=q2[l])l++; <span class="cf">while</span>(r&gt;=l&amp;&amp;v[i][j]&lt;q1[r])r--;</span>
<span id="cb19-26"><a href="#cb19-26"></a>            q1[++r]=v[i][j]; q2[r]=j; minh[i][j-n+<span class="dv">1</span>]=q1[l];</span>
<span id="cb19-27"><a href="#cb19-27"></a>        }</span>
<span id="cb19-28"><a href="#cb19-28"></a>    }</span>
<span id="cb19-29"><a href="#cb19-29"></a>    inc(j,<span class="dv">1</span>,b){</span>
<span id="cb19-30"><a href="#cb19-30"></a>        l=<span class="dv">1</span>; r=<span class="dv">0</span>;</span>
<span id="cb19-31"><a href="#cb19-31"></a>        inc(i,<span class="dv">1</span>,n){<span class="cf">while</span>(r&gt;=l&amp;&amp;maxh[i][j]&gt;q1[r])r--; q1[++r]=maxh[i][j]; q2[r]=i;} maxl[<span class="dv">1</span>][j]=q1[l];</span>
<span id="cb19-32"><a href="#cb19-32"></a>        inc(i,n+<span class="dv">1</span>,a){</span>
<span id="cb19-33"><a href="#cb19-33"></a>            <span class="cf">if</span>(i-n&gt;=q2[l])l++; <span class="cf">while</span>(r&gt;=l&amp;&amp;maxh[i][j]&gt;q1[r])r--;</span>
<span id="cb19-34"><a href="#cb19-34"></a>            q1[++r]=maxh[i][j]; q2[r]=i; maxl[i-n+<span class="dv">1</span>][j]=q1[l];</span>
<span id="cb19-35"><a href="#cb19-35"></a>        }</span>
<span id="cb19-36"><a href="#cb19-36"></a>    }</span>
<span id="cb19-37"><a href="#cb19-37"></a>    inc(j,<span class="dv">1</span>,b){</span>
<span id="cb19-38"><a href="#cb19-38"></a>        l=<span class="dv">1</span>; r=<span class="dv">0</span>;</span>
<span id="cb19-39"><a href="#cb19-39"></a>        inc(i,<span class="dv">1</span>,n){<span class="cf">while</span>(r&gt;=l&amp;&amp;minh[i][j]&lt;q1[r])r--; q1[++r]=minh[i][j]; q2[r]=i;} minl[<span class="dv">1</span>][j]=q1[l];</span>
<span id="cb19-40"><a href="#cb19-40"></a>        inc(i,n+<span class="dv">1</span>,a){</span>
<span id="cb19-41"><a href="#cb19-41"></a>            <span class="cf">if</span>(i-n&gt;=q2[l])l++; <span class="cf">while</span>(r&gt;=l&amp;&amp;minh[i][j]&lt;q1[r])r--;</span>
<span id="cb19-42"><a href="#cb19-42"></a>            q1[++r]=minh[i][j]; q2[r]=i; minl[i-n+<span class="dv">1</span>][j]=q1[l];</span>
<span id="cb19-43"><a href="#cb19-43"></a>        }</span>
<span id="cb19-44"><a href="#cb19-44"></a>    }</span>
<span id="cb19-45"><a href="#cb19-45"></a>    ans=INF;</span>
<span id="cb19-46"><a href="#cb19-46"></a>    inc(i,<span class="dv">1</span>,a-n+<span class="dv">1</span>)inc(j,<span class="dv">1</span>,b-n+<span class="dv">1</span>){</span>
<span id="cb19-47"><a href="#cb19-47"></a>        ans=min(ans,maxl[i][j]-minl[i][j]);</span>
<span id="cb19-48"><a href="#cb19-48"></a>    }</span>
<span id="cb19-49"><a href="#cb19-49"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb19-50"><a href="#cb19-50"></a>}</span></code></pre></div>
<h3 id="bzoj1927sdoi2010星际竞速2016.5.27">bzoj1927[Sdoi2010]星际竞速（2016.5.27）</h3>
<h4 id="题意-19">题意</h4>
<p>赛车大赛的赛场由N颗行星和M条双向星际航路构成，其中每颗行星都有一个不同的引力值。大赛要求车手们从一颗与这N颗行星之间没有任何航路的天体出发，访问这N颗行星每颗恰好一次。赛车超能电驴在高速航行模式下，沿星际航路航行，但只能由每个星球飞往引力比它大的星球。在能力爆发模式下，超能电驴在经过一段时间的定位之后，能瞬间移动到任意一个行星。求完成比赛最短时间。N≤800，M≤15000</p>
<h4 id="题解-19">题解</h4>
<p>费用流。对每个点拆成X，Y两个点，源向每个Y点连边，流量为1，费用为对这个行星的定位时间，表示直接经过这个行星。源再向每个X点连边流量1，费用0，每个Y点向汇连边，流量1，费用0。X与Y之间按“星际航路”连边，表示从X点到Y点。我们不关心从哪里到这个行星再到哪里去，我们只考虑每个行星只能经过一次。反思：本智障一开始看不懂任何题解，后来发现自己以为是能力爆发模式需要受引力限制，不审题退役QAQ</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="pp">#define maxn </span><span class="dv">2000</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb20-9"><a href="#cb20-9"></a></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,c,w,n;}; e es[maxn*<span class="dv">40</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c,<span class="dt">int</span> w){</span>
<span id="cb20-12"><a href="#cb20-12"></a>    es[++ess]=(e){f,t,c,w,g[f]}; g[f]=ess; es[++ess]=(e){t,f,<span class="dv">0</span>,-w,g[t]}; g[t]=ess;</span>
<span id="cb20-13"><a href="#cb20-13"></a>}</span>
<span id="cb20-14"><a href="#cb20-14"></a><span class="dt">void</span> init(){ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="dt">int</span> d[maxn],fr[maxn]; <span class="dt">bool</span> inq[maxn]; queue &lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="dt">bool</span> spfa(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb20-17"><a href="#cb20-17"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); memset(d,-<span class="dv">1</span>,<span class="kw">sizeof</span>(d));</span>
<span id="cb20-18"><a href="#cb20-18"></a>    inq[s]=<span class="dv">1</span>; d[s]=<span class="dv">0</span>; q.push(s); fr[s]=-<span class="dv">1</span>;</span>
<span id="cb20-19"><a href="#cb20-19"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb20-20"><a href="#cb20-20"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb20-21"><a href="#cb20-21"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;(d[es[i].t]==-<span class="dv">1</span>||d[es[i].t]&gt;d[x]+es[i].w)){</span>
<span id="cb20-22"><a href="#cb20-22"></a>            d[es[i].t]=d[x]+es[i].w; fr[es[i].t]=i; <span class="cf">if</span>(!inq[es[i].t])inq[es[i].t]=<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb20-23"><a href="#cb20-23"></a>        }</span>
<span id="cb20-24"><a href="#cb20-24"></a>    }</span>
<span id="cb20-25"><a href="#cb20-25"></a>    <span class="cf">return</span> d[t]!=-<span class="dv">1</span>;</span>
<span id="cb20-26"><a href="#cb20-26"></a>}</span>
<span id="cb20-27"><a href="#cb20-27"></a><span class="dt">int</span> advanced(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb20-28"><a href="#cb20-28"></a>    <span class="dt">int</span> a=INF,c=<span class="dv">0</span>;</span>
<span id="cb20-29"><a href="#cb20-29"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=fr[t];i!=-<span class="dv">1</span>;i=fr[es[i].f])a=min(a,es[i].c);</span>
<span id="cb20-30"><a href="#cb20-30"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=fr[t];i!=-<span class="dv">1</span>;i=fr[es[i].f])es[i].c-=a,es[i^<span class="dv">1</span>].c+=a,c+=(a*es[i].w);</span>
<span id="cb20-31"><a href="#cb20-31"></a>    <span class="cf">return</span> c;</span>
<span id="cb20-32"><a href="#cb20-32"></a>}</span>
<span id="cb20-33"><a href="#cb20-33"></a><span class="dt">int</span> maxflowmincost(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb20-34"><a href="#cb20-34"></a>    <span class="dt">int</span> c=<span class="dv">0</span>; <span class="cf">while</span>(spfa(s,t))c+=advanced(s,t); <span class="cf">return</span> c;</span>
<span id="cb20-35"><a href="#cb20-35"></a>}</span>
<span id="cb20-36"><a href="#cb20-36"></a><span class="dt">int</span> n,m,s,t;</span>
<span id="cb20-37"><a href="#cb20-37"></a><span class="dt">int</span> main(){</span>
<span id="cb20-38"><a href="#cb20-38"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); s=<span class="dv">0</span>; t=<span class="dv">2</span>*n+<span class="dv">1</span>; init();</span>
<span id="cb20-39"><a href="#cb20-39"></a>    inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;a); pe(s,i+n,<span class="dv">1</span>,a);}</span>
<span id="cb20-40"><a href="#cb20-40"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a,b,c; scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); pe(min(a,b),max(a,b)+n,<span class="dv">1</span>,c);}</span>
<span id="cb20-41"><a href="#cb20-41"></a>    inc(i,<span class="dv">1</span>,n)pe(s,i,<span class="dv">1</span>,<span class="dv">0</span>),pe(i+n,t,<span class="dv">1</span>,<span class="dv">0</span>);</span>
<span id="cb20-42"><a href="#cb20-42"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,maxflowmincost(s,t)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb20-43"><a href="#cb20-43"></a>}</span></code></pre></div>
<h3 id="bzoj20392009国家集训队employ人员雇佣2016.5.30">bzoj2039[2009国家集训队]employ人员雇佣（2016.5.30）</h3>
<h4 id="题意-20">题意</h4>
<p>有N个经理，Ei,j表示i经理对j经理的了解程度，当经理i和经理j同时被雇佣时，利润增加Ei,j*2。同时，雇佣每一个经理都需要花费一定的金钱Ai。没有被雇佣的人会被竞争对手所雇佣，使得所赚得的利润减少Ei,j（意思是经理i和j如果只雇佣一个，就会少Ei,j，如果两个都没被雇佣就不扣钱）。求最大利润。N≤1000</p>
<h4 id="题解-20">题解</h4>
<p>S集表示雇佣，T集表示不雇佣。每个经理拆成x，y两点。s向所有x点连，流量为雇佣费用。对于每个Ei,j，i，j经理连一条流量为2*Ei,j的无向边，同时i和j都向t连流量为Ei,j的边，最小割为所有Ei,j*2减最大流。由于边数大，需要合并一下边。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="pp">#define maxn </span><span class="dv">1100</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="pp">#define INF </span><span class="dv">1000000000000000000</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb21-10"><a href="#cb21-10"></a></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="kw">struct</span> e{<span class="dt">int</span> t;ll c;<span class="dt">int</span> n;}; e es[maxn*<span class="dv">2000</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="kw">inline</span> <span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,ll c){</span>
<span id="cb21-13"><a href="#cb21-13"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,g[t]}; g[t]=ess;</span>
<span id="cb21-14"><a href="#cb21-14"></a>}</span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="kw">inline</span> <span class="dt">void</span> pe2(<span class="dt">int</span> f,<span class="dt">int</span> t,ll c){</span>
<span id="cb21-16"><a href="#cb21-16"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,c,g[t]}; g[t]=ess;</span>
<span id="cb21-17"><a href="#cb21-17"></a>}</span>
<span id="cb21-18"><a href="#cb21-18"></a><span class="kw">inline</span> <span class="dt">void</span> init(){</span>
<span id="cb21-19"><a href="#cb21-19"></a>    ess=-<span class="dv">1</span>; memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb21-20"><a href="#cb21-20"></a>}</span>
<span id="cb21-21"><a href="#cb21-21"></a>queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> h[maxn];</span>
<span id="cb21-22"><a href="#cb21-22"></a><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb21-23"><a href="#cb21-23"></a>    memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); <span class="cf">while</span>(!q.empty())q.pop(); h[s]=<span class="dv">0</span>; q.push(s);</span>
<span id="cb21-24"><a href="#cb21-24"></a>    <span class="cf">while</span>(! q.empty()){</span>
<span id="cb21-25"><a href="#cb21-25"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb21-26"><a href="#cb21-26"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==-<span class="dv">1</span>)h[es[i].t]=h[x]+<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb21-27"><a href="#cb21-27"></a>    }</span>
<span id="cb21-28"><a href="#cb21-28"></a>    <span class="cf">return</span> h[t]!=-<span class="dv">1</span>;</span>
<span id="cb21-29"><a href="#cb21-29"></a>}</span>
<span id="cb21-30"><a href="#cb21-30"></a>ll dfs(<span class="dt">int</span> x,<span class="dt">int</span> t,ll f){</span>
<span id="cb21-31"><a href="#cb21-31"></a>    <span class="cf">if</span>(x==t)<span class="cf">return</span> f; ll u=<span class="dv">0</span>;</span>
<span id="cb21-32"><a href="#cb21-32"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==h[x]+<span class="dv">1</span>){</span>
<span id="cb21-33"><a href="#cb21-33"></a>        ll w=dfs(es[i].t,t,min(f,es[i].c)); f-=w; u+=w; es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; <span class="cf">if</span>(f==<span class="dv">0</span>)<span class="cf">return</span> u;</span>
<span id="cb21-34"><a href="#cb21-34"></a>    }</span>
<span id="cb21-35"><a href="#cb21-35"></a>    <span class="cf">if</span>(u==<span class="dv">0</span>)h[x]=-<span class="dv">1</span>; <span class="cf">return</span> u;</span>
<span id="cb21-36"><a href="#cb21-36"></a>}</span>
<span id="cb21-37"><a href="#cb21-37"></a>ll dinic(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb21-38"><a href="#cb21-38"></a>    ll f=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))f+=dfs(s,t,INF); <span class="cf">return</span> f;</span>
<span id="cb21-39"><a href="#cb21-39"></a>}</span>
<span id="cb21-40"><a href="#cb21-40"></a><span class="dt">int</span> n,s,t; ll a[maxn],b,tot;</span>
<span id="cb21-41"><a href="#cb21-41"></a><span class="dt">int</span> main(){</span>
<span id="cb21-42"><a href="#cb21-42"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); s=<span class="dv">0</span>; t=n+<span class="dv">1</span>; init(); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;b),pe(s,i,b); memset(a,<span class="dv">0</span>,<span class="kw">sizeof</span>(a));</span>
<span id="cb21-43"><a href="#cb21-43"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n){</span>
<span id="cb21-44"><a href="#cb21-44"></a>        scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;b); <span class="cf">if</span>(i&gt;j||b==<span class="dv">0</span>)<span class="cf">continue</span>; a[i]+=b; a[j]+=b; pe2(i,j,<span class="dv">2</span>*b); tot+=<span class="dv">2</span>*b;</span>
<span id="cb21-45"><a href="#cb21-45"></a>    }</span>
<span id="cb21-46"><a href="#cb21-46"></a>    inc(i,<span class="dv">1</span>,n)pe(i,t,a[i]); printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,tot-dinic(s,t)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb21-47"><a href="#cb21-47"></a>}</span></code></pre></div>
<h3 id="bzoj2333scoi2011棘手的操作2016.5.30">bzoj2333[SCOI2011]棘手的操作（2016.5.30）</h3>
<h4 id="题意-21">题意</h4>
<p>有N个节点，M个操作：连接两个节点、单个节点的权值增加v、节点所在的连通块的所有节点的权值增加v、所有节点的权值增加v、询问节点当前的权值、询问节点所在的连通块中权值最大的节点的权值、询问所有节点中权值最大的节点的权值。N，M≤300000</p>
<h4 id="题解-21">题解</h4>
<p>可并堆，虽然听说配对堆非常快，但教程太少了不会写，所以去学了斜堆，比较好写。斜堆实际上是一棵二叉树，核心是合并操作，这是一个递归过程，有点像treap的删除操作。斜堆保证复杂度的方法是每次递归合并右节点，合并完后交换左右节点，使整棵树和splay一样，可以“自动”平衡，也是玄学。要修改整个连通块，打标记就行了。这道题特殊的一点在于询问所有节点权值的最大值，可以用STL的set维护所有连通块的根节点，当连边和修改权值时如果根节点被修改需要维护一下set。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="pp">#define maxn </span><span class="dv">300100</span></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb22-9"><a href="#cb22-9"></a></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="dt">int</span> fa[maxn],ch[maxn][<span class="dv">2</span>],tg[maxn],v[maxn],n,m,add;</span>
<span id="cb22-11"><a href="#cb22-11"></a>multiset &lt;<span class="dt">int</span>&gt; st;</span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb22-13"><a href="#cb22-13"></a>    <span class="cf">if</span>(tg[x]){</span>
<span id="cb22-14"><a href="#cb22-14"></a>        <span class="cf">if</span>(ch[x][<span class="dv">0</span>])tg[ch[x][<span class="dv">0</span>]]+=tg[x],v[ch[x][<span class="dv">0</span>]]+=tg[x];</span>
<span id="cb22-15"><a href="#cb22-15"></a>        <span class="cf">if</span>(ch[x][<span class="dv">1</span>])tg[ch[x][<span class="dv">1</span>]]+=tg[x],v[ch[x][<span class="dv">1</span>]]+=tg[x];</span>
<span id="cb22-16"><a href="#cb22-16"></a>        tg[x]=<span class="dv">0</span>;</span>
<span id="cb22-17"><a href="#cb22-17"></a>    }</span>
<span id="cb22-18"><a href="#cb22-18"></a>}</span>
<span id="cb22-19"><a href="#cb22-19"></a><span class="dt">int</span> dt[maxn],dts;</span>
<span id="cb22-20"><a href="#cb22-20"></a><span class="dt">int</span> find(<span class="dt">int</span> x){</span>
<span id="cb22-21"><a href="#cb22-21"></a>    dt[dts=<span class="dv">1</span>]=x; <span class="cf">while</span>(fa[x])x=fa[x],dt[++dts]=x;</span>
<span id="cb22-22"><a href="#cb22-22"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=dts;i&gt;=<span class="dv">1</span>;i--)pushdown(dt[i]); <span class="cf">return</span> x;</span>
<span id="cb22-23"><a href="#cb22-23"></a>}</span>
<span id="cb22-24"><a href="#cb22-24"></a><span class="dt">int</span> merge(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb22-25"><a href="#cb22-25"></a>    <span class="cf">if</span>(!x||!y)<span class="cf">return</span> x+y; <span class="cf">if</span>(v[x]&lt;v[y])swap(x,y); pushdown(x);</span>
<span id="cb22-26"><a href="#cb22-26"></a>    ch[x][<span class="dv">1</span>]=merge(ch[x][<span class="dv">1</span>],y); fa[ch[x][<span class="dv">1</span>]]=x; swap(ch[x][<span class="dv">0</span>],ch[x][<span class="dv">1</span>]); <span class="cf">return</span> x;</span>
<span id="cb22-27"><a href="#cb22-27"></a>}</span>
<span id="cb22-28"><a href="#cb22-28"></a><span class="dt">int</span> del(<span class="dt">int</span> x){</span>
<span id="cb22-29"><a href="#cb22-29"></a>    <span class="dt">int</span> t=merge(ch[x][<span class="dv">0</span>],ch[x][<span class="dv">1</span>]),f=fa[x]; fa[x]=ch[x][<span class="dv">0</span>]=ch[x][<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb22-30"><a href="#cb22-30"></a>    fa[t]=f; <span class="cf">if</span>(f)ch[f][ch[f][<span class="dv">1</span>]==x]=t; <span class="cf">return</span> t;</span>
<span id="cb22-31"><a href="#cb22-31"></a>}</span>
<span id="cb22-32"><a href="#cb22-32"></a><span class="dt">void</span> update1(<span class="dt">int</span> x,<span class="dt">int</span> val){</span>
<span id="cb22-33"><a href="#cb22-33"></a>    <span class="dt">int</span> y=find(x); <span class="dt">int</span> t=del(x); v[x]+=val;</span>
<span id="cb22-34"><a href="#cb22-34"></a>    <span class="cf">if</span>(y!=x){</span>
<span id="cb22-35"><a href="#cb22-35"></a>        <span class="dt">int</span> z=merge(y,x); st.erase(st.find(v[y])); st.insert(v[z]);</span>
<span id="cb22-36"><a href="#cb22-36"></a>    }<span class="cf">else</span>{</span>
<span id="cb22-37"><a href="#cb22-37"></a>        <span class="cf">if</span>(t){</span>
<span id="cb22-38"><a href="#cb22-38"></a>            <span class="dt">int</span> z=merge(t,x); st.erase(st.find(v[x]-val)),st.insert(v[z]);</span>
<span id="cb22-39"><a href="#cb22-39"></a>        }<span class="cf">else</span> st.erase(st.find(v[x]-val)),st.insert(v[x]);</span>
<span id="cb22-40"><a href="#cb22-40"></a>    }</span>
<span id="cb22-41"><a href="#cb22-41"></a>}</span>
<span id="cb22-42"><a href="#cb22-42"></a><span class="dt">void</span> update2(<span class="dt">int</span> x,<span class="dt">int</span> val){</span>
<span id="cb22-43"><a href="#cb22-43"></a>    x=find(x); tg[x]+=val; v[x]+=val; <span class="cf">if</span>(!fa[x])st.erase(st.find(v[x]-val)),st.insert(v[x]);</span>
<span id="cb22-44"><a href="#cb22-44"></a>}</span>
<span id="cb22-45"><a href="#cb22-45"></a><span class="dt">void</span> update3(<span class="dt">int</span> val){add+=val;}</span>
<span id="cb22-46"><a href="#cb22-46"></a><span class="dt">int</span> query1(<span class="dt">int</span> x){find(x); <span class="cf">return</span> v[x];}</span>
<span id="cb22-47"><a href="#cb22-47"></a><span class="dt">int</span> query2(<span class="dt">int</span> x){<span class="dt">int</span> y=find(x); <span class="cf">return</span> v[y];}</span>
<span id="cb22-48"><a href="#cb22-48"></a><span class="dt">int</span> query3(){<span class="cf">return</span> * --st.find(INF);}</span>
<span id="cb22-49"><a href="#cb22-49"></a><span class="dt">void</span> <span class="fu">connect</span>(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb22-50"><a href="#cb22-50"></a>    <span class="dt">int</span> xx=find(x),yy=find(y); <span class="cf">if</span>(xx==yy)<span class="cf">return</span>; <span class="dt">int</span> z=merge(xx,yy);</span>
<span id="cb22-51"><a href="#cb22-51"></a>    <span class="cf">if</span>(z==xx)st.erase(st.find(v[yy]));<span class="cf">else</span> st.erase(st.find(v[xx]));</span>
<span id="cb22-52"><a href="#cb22-52"></a>}</span>
<span id="cb22-53"><a href="#cb22-53"></a><span class="dt">char</span> opt[<span class="dv">3</span>];</span>
<span id="cb22-54"><a href="#cb22-54"></a><span class="dt">int</span> main(){</span>
<span id="cb22-55"><a href="#cb22-55"></a>    <span class="co">//freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin);</span></span>
<span id="cb22-56"><a href="#cb22-56"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); add=<span class="dv">0</span>; st.clear();</span>
<span id="cb22-57"><a href="#cb22-57"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb22-58"><a href="#cb22-58"></a>        scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;v[i]); st.insert(v[i]); fa[i]=ch[i][<span class="dv">0</span>]=ch[i][<span class="dv">1</span>]=tg[i]=<span class="dv">0</span>;</span>
<span id="cb22-59"><a href="#cb22-59"></a>    }</span>
<span id="cb22-60"><a href="#cb22-60"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;m);</span>
<span id="cb22-61"><a href="#cb22-61"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb22-62"><a href="#cb22-62"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,opt); <span class="dt">int</span> x,y;</span>
<span id="cb22-63"><a href="#cb22-63"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;U&#39;</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y),<span class="fu">connect</span>(x,y);</span>
<span id="cb22-64"><a href="#cb22-64"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;A&#39;</span>){</span>
<span id="cb22-65"><a href="#cb22-65"></a>            <span class="cf">if</span>(opt[<span class="dv">1</span>]==<span class="ch">&#39;1&#39;</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y),update1(x,y);</span>
<span id="cb22-66"><a href="#cb22-66"></a>            <span class="cf">if</span>(opt[<span class="dv">1</span>]==<span class="ch">&#39;2&#39;</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;x,&amp;y),update2(x,y);</span>
<span id="cb22-67"><a href="#cb22-67"></a>            <span class="cf">if</span>(opt[<span class="dv">1</span>]==<span class="ch">&#39;3&#39;</span>)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x),update3(x);</span>
<span id="cb22-68"><a href="#cb22-68"></a>        }</span>
<span id="cb22-69"><a href="#cb22-69"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;F&#39;</span>){</span>
<span id="cb22-70"><a href="#cb22-70"></a>            <span class="cf">if</span>(opt[<span class="dv">1</span>]==<span class="ch">&#39;1&#39;</span>)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x),printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query1(x)+add);</span>
<span id="cb22-71"><a href="#cb22-71"></a>            <span class="cf">if</span>(opt[<span class="dv">1</span>]==<span class="ch">&#39;2&#39;</span>)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x),printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query2(x)+add);</span>
<span id="cb22-72"><a href="#cb22-72"></a>            <span class="cf">if</span>(opt[<span class="dv">1</span>]==<span class="ch">&#39;3&#39;</span>)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query3()+add);</span>
<span id="cb22-73"><a href="#cb22-73"></a>        }</span>
<span id="cb22-74"><a href="#cb22-74"></a>        <span class="co">//if(i==2)break;</span></span>
<span id="cb22-75"><a href="#cb22-75"></a>    }</span>
<span id="cb22-76"><a href="#cb22-76"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb22-77"><a href="#cb22-77"></a>}</span></code></pre></div>
<h3 id="bzoj2809apio2012dispatching2016.5.31">bzoj2809[Apio2012]dispatching（2016.5.31）</h3>
<h4 id="题意-22">题意</h4>
<p>n个点组成一棵树，每个点都有一个领导力和费用，可以让一个点当领导，然后在这个点的子树中选择一些费用之和不超过m的点，得到领导的领导力乘选择的点的个数（领导可不被选择）的利润。求利润最大值。n≤100000</p>
<h4 id="题解-22">题解</h4>
<p>可并堆。可以得到一个结论，就是在子树中选点的时候，先选所有点，如果费用超了，就不断把费用最大的剔除，直到费用不超，这样得到的选点数量最大，这过程可以用堆维护。同时每个点的堆都可以由子树的堆合并得到，所以需要可并堆。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="pp">#define maxn </span><span class="dv">100100</span></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb23-8"><a href="#cb23-8"></a></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="dt">int</span> ch[maxn][<span class="dv">2</span>],rt[maxn],n,m,st; ll sz[maxn],v[maxn],ans,sm[maxn],gd[maxn];</span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess;}</span>
<span id="cb23-12"><a href="#cb23-12"></a><span class="dt">void</span> init(){ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));}</span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="dt">void</span> update(<span class="dt">int</span> x){sz[x]=sz[ch[x][<span class="dv">0</span>]]+sz[ch[x][<span class="dv">1</span>]]+<span class="dv">1</span>; sm[x]=sm[ch[x][<span class="dv">0</span>]]+sm[ch[x][<span class="dv">1</span>]]+v[x];}</span>
<span id="cb23-14"><a href="#cb23-14"></a><span class="dt">int</span> merge(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb23-15"><a href="#cb23-15"></a>    <span class="cf">if</span>(!x||!y)<span class="cf">return</span> x+y; <span class="cf">if</span>(v[x]&lt;v[y])swap(x,y); ch[x][<span class="dv">1</span>]=merge(ch[x][<span class="dv">1</span>],y);</span>
<span id="cb23-16"><a href="#cb23-16"></a>    swap(ch[x][<span class="dv">0</span>],ch[x][<span class="dv">1</span>]); update(x); <span class="cf">return</span> x;</span>
<span id="cb23-17"><a href="#cb23-17"></a>}</span>
<span id="cb23-18"><a href="#cb23-18"></a><span class="dt">void</span> pop(<span class="dt">int</span> &amp;x){</span>
<span id="cb23-19"><a href="#cb23-19"></a>    <span class="dt">int</span> y=merge(ch[x][<span class="dv">0</span>],ch[x][<span class="dv">1</span>]); ch[x][<span class="dv">0</span>]=ch[x][<span class="dv">1</span>]=<span class="dv">0</span>; sz[x]=<span class="dv">1</span>; sm[x]=v[x]; x=y;</span>
<span id="cb23-20"><a href="#cb23-20"></a>}</span>
<span id="cb23-21"><a href="#cb23-21"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb23-22"><a href="#cb23-22"></a>    rt[x]=x; <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)dfs(es[i].t),rt[x]=merge(rt[x],rt[es[i].t]);</span>
<span id="cb23-23"><a href="#cb23-23"></a>    <span class="cf">while</span>(sz[rt[x]]&amp;&amp;sm[rt[x]]&gt;m)pop(rt[x]); ans=max(ans,sz[rt[x]]*gd[x]);</span>
<span id="cb23-24"><a href="#cb23-24"></a>}</span>
<span id="cb23-25"><a href="#cb23-25"></a><span class="dt">int</span> main(){</span>
<span id="cb23-26"><a href="#cb23-26"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); init();</span>
<span id="cb23-27"><a href="#cb23-27"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb23-28"><a href="#cb23-28"></a>        <span class="dt">int</span> a; ll b,c; scanf(<span class="st">&quot;</span><span class="sc">%d%lld%lld</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); <span class="cf">if</span>(a)pe(a,i);<span class="cf">else</span> st=i;</span>
<span id="cb23-29"><a href="#cb23-29"></a>        v[i]=sm[i]=b; sz[i]=<span class="dv">1</span>; gd[i]=c; ch[i][<span class="dv">0</span>]=ch[i][<span class="dv">1</span>]=rt[i]=<span class="dv">0</span>;</span>
<span id="cb23-30"><a href="#cb23-30"></a>    }</span>
<span id="cb23-31"><a href="#cb23-31"></a>    ans=<span class="dv">0</span>; dfs(st); printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb23-32"><a href="#cb23-32"></a>}</span></code></pre></div>
<h3 id="bzoj1588hnoi2002营业额统计2016.5.31">bzoj1588[HNOI2002]营业额统计（2016.5.31）</h3>
<h4 id="题意-23">题意</h4>
<p>n天，每天得到一个值，要求输出每一天和这天得到的值相差最小的之前天得到的值与这个值的差的和。n不知道，不过O(nlog2n)可写。</p>
<h4 id="题解-23">题解</h4>
<p>说是平衡树模板题，不过可以用set水过去。先在set插入一个-INF和INF防溢出（yyl大爷教我的）每次在set中lower_bound这天得到的值，求出的是≤它的最大值，比较一下这个值和set中这个值的后继与这天得到的值的差。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="pp">#define INF </span><span class="dv">2147483647</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb24-8"><a href="#cb24-8"></a></span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="dt">int</span> n,ans,x; set &lt;<span class="dt">int</span>&gt; st;</span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="dt">int</span> main(){</span>
<span id="cb24-11"><a href="#cb24-11"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); st.clear(); st.insert(INF); st.insert(-INF); ans=<span class="dv">0</span>;</span>
<span id="cb24-12"><a href="#cb24-12"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb24-13"><a href="#cb24-13"></a>        scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x);</span>
<span id="cb24-14"><a href="#cb24-14"></a>        <span class="cf">if</span>(i==<span class="dv">1</span>)ans+=x;<span class="cf">else</span>{</span>
<span id="cb24-15"><a href="#cb24-15"></a>            <span class="dt">int</span> y=* (st.lower_bound(x)),z=* (--st.lower_bound(x)); <span class="co">//printf(&quot;%d %d\n&quot;,y,z);</span></span>
<span id="cb24-16"><a href="#cb24-16"></a>            <span class="cf">if</span>(y==INF)ans+=abs(x-z);<span class="cf">else</span> <span class="cf">if</span>(z==-INF)ans+=abs(x-y);<span class="cf">else</span> ans+=min(abs(x-z),abs(x-y));</span>
<span id="cb24-17"><a href="#cb24-17"></a>        }</span>
<span id="cb24-18"><a href="#cb24-18"></a>        st.insert(x);</span>
<span id="cb24-19"><a href="#cb24-19"></a>    }</span>
<span id="cb24-20"><a href="#cb24-20"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb24-21"><a href="#cb24-21"></a>}</span></code></pre></div>
<h3 id="bzoj1196hnoi2006公路修建问题2016.5.31">bzoj1196[HNOI2006]公路修建问题（2016.5.31）</h3>
<h4 id="题意-24">题意</h4>
<p>修n-1条公路将n个点连通，每个点可建一级公路也可建二级公路，要求一级公路必须有k条，要求花费最多的公路花费最少。</p>
<h4 id="题解-24">题解</h4>
<p>首先二分最大花费，接着判定：先在不产生环的前提下（用并查集维护）让每条路尽量修一级公路，如果最后无法构成树则考虑修二级公路。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="pp">#define maxn </span><span class="dv">10500</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="dt">int</span> n,k,m,u[maxn*<span class="dv">2</span>],v[maxn*<span class="dv">2</span>],c1[maxn*<span class="dv">2</span>],c2[maxn*<span class="dv">2</span>],mx,fa[maxn],cnt;</span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="dt">bool</span> check(<span class="dt">int</span> lim){</span>
<span id="cb25-11"><a href="#cb25-11"></a>    inc(i,<span class="dv">1</span>,n)fa[i]=i; cnt=<span class="dv">0</span>;</span>
<span id="cb25-12"><a href="#cb25-12"></a>    inc(i,<span class="dv">1</span>,m)<span class="cf">if</span>(c1[i]&lt;=lim){</span>
<span id="cb25-13"><a href="#cb25-13"></a>        <span class="dt">int</span> x=find(u[i]),y=find(v[i]); <span class="cf">if</span>(x==y)<span class="cf">continue</span>; fa[y]=x; cnt++;</span>
<span id="cb25-14"><a href="#cb25-14"></a>    }</span>
<span id="cb25-15"><a href="#cb25-15"></a>    <span class="cf">if</span>(cnt&lt;k)<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb25-16"><a href="#cb25-16"></a>    inc(i,<span class="dv">1</span>,m)<span class="cf">if</span>(c2[i]&lt;=lim){</span>
<span id="cb25-17"><a href="#cb25-17"></a>        <span class="dt">int</span> x=find(u[i]),y=find(v[i]); <span class="cf">if</span>(x==y)<span class="cf">continue</span>; fa[y]=x; cnt++;</span>
<span id="cb25-18"><a href="#cb25-18"></a>    }</span>
<span id="cb25-19"><a href="#cb25-19"></a>    <span class="cf">if</span>(cnt&lt;n-<span class="dv">1</span>)<span class="cf">return</span> <span class="dv">0</span>; <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb25-20"><a href="#cb25-20"></a>}</span>
<span id="cb25-21"><a href="#cb25-21"></a><span class="dt">int</span> main(){</span>
<span id="cb25-22"><a href="#cb25-22"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k,&amp;m); mx=<span class="dv">0</span>;</span>
<span id="cb25-23"><a href="#cb25-23"></a>    inc(i,<span class="dv">1</span>,m-<span class="dv">1</span>)scanf(<span class="st">&quot;</span><span class="sc">%d%d%d%d</span><span class="st">&quot;</span>,&amp;u[i],&amp;v[i],&amp;c1[i],&amp;c2[i]),mx=max(mx,c1[i]),mx=max(mx,c2[i]);</span>
<span id="cb25-24"><a href="#cb25-24"></a>    <span class="dt">int</span> l=<span class="dv">0</span>,r=mx,ans;</span>
<span id="cb25-25"><a href="#cb25-25"></a>    <span class="cf">while</span>(l&lt;=r){</span>
<span id="cb25-26"><a href="#cb25-26"></a>        <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb25-27"><a href="#cb25-27"></a>        <span class="cf">if</span>(check(mid))ans=mid,r=mid-<span class="dv">1</span>;<span class="cf">else</span> l=mid+<span class="dv">1</span>;</span>
<span id="cb25-28"><a href="#cb25-28"></a>    }</span>
<span id="cb25-29"><a href="#cb25-29"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb25-30"><a href="#cb25-30"></a>}</span></code></pre></div>
<footer>
    <hr>
    <center>
        Powered by <a href="https://github.com/ZimingYuan/Yblogs" target="_blank">Yblogs</a><br>
        转载请注明出处<br>
        © 2025 VnYzm的博客<br>
        <span id="busuanzi_container_site_pv">2025年10月7日以来总访问量为<span id="busuanzi_value_site_pv"></span>次</span>
    </center>
</footer>
</body>
</html>
