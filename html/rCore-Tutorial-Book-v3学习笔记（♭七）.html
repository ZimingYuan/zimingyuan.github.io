<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-h: 1.4rem/1.5 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input').value;
          if (word.length == 0) {
              alert('搜索内容不能为空！');
          } else {
              location.href = '/search.html?' + word;
          }
      };
  </script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <title>rCore-Tutorial-Book-v3学习笔记（♭七）</title>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>ZimingYuan的博客</big></li>
            <li><a href="/index.html">首页</a></li>
            <li><a href="/html/随笔.html">随笔</a></li>
            <li><a href="/html/CSP模板.html">CSP模板</a></li>
            <li class="float-right sticky"><button onclick="search()">Go</button></li>
            <li class="float-right sticky"><input type="text" placeholder="搜索"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">rCore-Tutorial-Book-v3学习笔记（♭七）</h1>
<hr>
</header>
<h3 id="概述">概述</h3>
<p>文件系统果然是内核设计中boss级别的存在，花了我大量时间。主要是对文件系统格式的解析非常繁琐，以及之前没有在sbi环境下考虑过设备中断问题，网上也没有资料，走了不少弯路。因此这一块分为两节，本节主要介绍文件系统格式的解析，本身可以独立出来作为外部程序，相当于内核文件系统的预备部分，所以是“降”第七节；下一节主要介绍块设备的处理，以及附带的命令行参数、重定向等实现。</p>
<h3 id="内容">内容</h3>
<p>rcore和xv6使用的都是其自创的文件系统。但是我经过权衡，决定使用ext2文件系统，好处有两个：一是这个文件系统是被广泛应用的文件系统，其家族的ext4更是Linux默认的文件系统，因此网上有大量的教程和工具，Linux更是在系统上支持它，比如使用mke2fs可以很方便的对映像文件格式化，也可以直接将映像文件挂载到某文件夹下，进行文件的创建、删除和编辑；二是相比于fat家族、ntfs等文件系统，ext2文件系统和rcore、xv6的文件系统更加接近，都是以块为单位管理，每个文件和文件夹抽象为一个inode节点，方便参考。</p>
<p>内核设计中整个文件系统分为4层：</p>
<ul>
<li>文件描述符层，这层在第六节实现管道的时候已经完成了框架，这一节主要就是实现这一层的read、write、close、clone以及创建五个函数，下一节再详细介绍。</li>
<li>文件节点层，这层是文件系统中的重中之重，包括按照路径查找文件、读写文件、清空文件及其相关的辅助函数，繁琐的地方在于这些函数都是直接对文件系统的格式进行处理，比如说查找文件，需要先找到存inode的块，找到根目录对应的inode，根据inode找到根目录包含的子文件信息所在的块，然后根据子文件信息找到子文件对应的inode，以此类推。在下面会详细介绍。</li>
<li>块缓存层，访问磁盘一般比较慢，所以需要缓存。上一层在读写磁盘块的时候都调用了这一层的函数。因为前几天课内做了CSAPP的cachelab实验的第一部分，所以基本思想还比较清楚，下面也会详细介绍。</li>
<li>设备驱动层，这一层是直接和设备打交道的代码，类似xv6实验中的net实验，主要也是各类寄存器操作和环形缓冲的读写，我就直接用了xv6的virtio_disk.c。</li>
</ul>
<p>先说文件节点层，和文件描述符绑定的结构体定义为FNode：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">typedef</span> <span class="kw">struct</span> FNode {</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="dt">int</span> refcnt, dnum; usize offset;</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="dt">char</span> dinode[<span class="dv">128</span>];</span>
<span id="cb1-4"><a href="#cb1-4"></a>} FNode;</span></code></pre></div>
<p>其中refcnt是引用计数，offset是读写偏移量。dnum表示该FNode对应文件系统的inode编号，dinode包含的是该FNode对应文件系统的inode中的全部信息。</p>
<p>ext2格式的定义可以看<a href="https://wiki.osdev.org/Ext2">这个网站</a>，讲的很详细，我这里就只介绍和实现有关的重点。首先ext2格式最小同时是默认的块大小是1024个字节。文件映像的第一个块是引导块，不放和文件系统有关的任何信息，第二个块称为超级块，存储的是整个文件系统的元信息，我们关心的有前8个字节存储的文件系统总块数和总inode数，用来在后面确定位视图大小；以及第12-19字节存储的文件系统未分配块数和未分配inode数，后面分配两者的时候需要修改这8个字节。第32-39字节存储文件系统每组的有多少块和多少inode，ext2会将整个文件系统所有的块和inode划分成一定数量的组，默认每组是8192个块，而我创建的文件映像大小只有4MiB，即4096个块，所以整个映像只有一个组，可以不关心这个属性。</p>
<p>下一个块描述各块组的信息，称为块组描述表。每串描述对应一个组，共32字节，我们需要关心的有0-3个字节、4-7字节和8-11字节分别记录块视图、inode视图和inode表的块地址；以及12-13字节和14-15字节记录的该组未分配的块和inode。这些都是分配和释放块和inode需要修改和查询的信息。初始化函数就是记录上面所述的这些信息：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">void</span> init_ext2() {</span>
<span id="cb2-2"><a href="#cb2-2"></a>    bcache_init();</span>
<span id="cb2-3"><a href="#cb2-3"></a>    bcache_rw(<span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">8</span>, superblock, <span class="dv">0</span>);</span>
<span id="cb2-4"><a href="#cb2-4"></a>    bcache_rw(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">4</span>, &amp;inode_cnt, <span class="dv">0</span>);</span>
<span id="cb2-5"><a href="#cb2-5"></a>    bcache_rw(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">4</span>, &amp;block_cnt, <span class="dv">0</span>);</span>
<span id="cb2-6"><a href="#cb2-6"></a>    bcache_rw(<span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">4</span>, &amp;block_bitmap_addr, <span class="dv">0</span>);</span>
<span id="cb2-7"><a href="#cb2-7"></a>    bcache_rw(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">4</span>, &amp;inode_bitmap_addr, <span class="dv">0</span>);</span>
<span id="cb2-8"><a href="#cb2-8"></a>    bcache_rw(<span class="dv">2</span>, <span class="dv">8</span>, <span class="dv">4</span>, &amp;inode_table, <span class="dv">0</span>);</span>
<span id="cb2-9"><a href="#cb2-9"></a>    bcache_rw(<span class="dv">2</span>, <span class="dv">12</span>, <span class="dv">4</span>, gdt_num, <span class="dv">0</span>);</span>
<span id="cb2-10"><a href="#cb2-10"></a>    block_bitmap = bd_malloc(block_cnt / <span class="dv">8</span>);</span>
<span id="cb2-11"><a href="#cb2-11"></a>    inode_bitmap = bd_malloc(inode_cnt / <span class="dv">8</span>);</span>
<span id="cb2-12"><a href="#cb2-12"></a>    bcache_rw(block_bitmap_addr, <span class="dv">0</span>, block_cnt / <span class="dv">8</span>, block_bitmap, <span class="dv">0</span>);</span>
<span id="cb2-13"><a href="#cb2-13"></a>    bcache_rw(inode_bitmap_addr, <span class="dv">0</span>, inode_cnt / <span class="dv">8</span>, inode_bitmap, <span class="dv">0</span>);</span>
<span id="cb2-14"><a href="#cb2-14"></a>}</span></code></pre></div>
<p>块缓存层暴露给文件节点层的函数读写函数是bcache_rw，参数有块号、读写位置在块里的偏移和长度、数据指针和控制读写的开关。由于对块视图和inode视图的操作比较复杂，需要对位进行处理，所以这里把整个视图都保存到内存了，每次写入就在内存中写在写回磁盘。</p>
<p>下一个是查找路径的函数，这里我们只处理绝对路径，具体思路就是首先置当前路径为根目录，然后不断地从路径中获得文件夹，然后在当前路径中查找，如果找到这个文件夹就把当前路径设为该文件夹的操作。到达最后一个“/”符号后，需要进行一个判断，如果这个“/”符号在最后，说明这个路径是一个文件夹，那么直接返回这个文件夹；否则，说明这个路径是文件，需要再在当前路径中查找这个文件，如果找到了，直接返回。找不到则根据当前函数的参数确定是否要创建这个文件，如果要创建，需要在磁盘上分配一个新inode，把这个inode记录到父文件夹中，再初始化这个inode，然后才返回：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">char</span> dinode[<span class="dv">128</span>];</span>
<span id="cb3-2"><a href="#cb3-2"></a>FNode *inode_get(<span class="dt">char</span> *path, <span class="dt">int</span> create) {</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="cf">if</span> (path[<span class="dv">0</span>] != <span class="ch">&#39;/&#39;</span>) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-4"><a href="#cb3-4"></a>    get_inode(<span class="dv">2</span>, dinode); <span class="dt">int</span> len = strlen(path);</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="dt">int</span> j = <span class="dv">1</span>, inodep_num = <span class="dv">2</span>;</span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt; len; i++) {</span>
<span id="cb3-7"><a href="#cb3-7"></a>        <span class="cf">if</span> (path[i] == <span class="ch">&#39;/&#39;</span>) {</span>
<span id="cb3-8"><a href="#cb3-8"></a>            <span class="cf">if</span> (i != j) {</span>
<span id="cb3-9"><a href="#cb3-9"></a>                inodep_num = find_file(path + j, i - j, dinode);</span>
<span id="cb3-10"><a href="#cb3-10"></a>                <span class="cf">if</span> (! inodep_num) panic(<span class="st">&quot;inode_get:path not found&quot;</span>);</span>
<span id="cb3-11"><a href="#cb3-11"></a>                get_inode(inodep_num, dinode);</span>
<span id="cb3-12"><a href="#cb3-12"></a>            }</span>
<span id="cb3-13"><a href="#cb3-13"></a>            j = i + <span class="dv">1</span>;</span>
<span id="cb3-14"><a href="#cb3-14"></a>        }</span>
<span id="cb3-15"><a href="#cb3-15"></a>    }</span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="cf">if</span> (j == len) {</span>
<span id="cb3-17"><a href="#cb3-17"></a>        FNode *fn = bd_malloc(<span class="kw">sizeof</span>(FNode)); fn-&gt;dnum = inodep_num;</span>
<span id="cb3-18"><a href="#cb3-18"></a>        memcpy(fn-&gt;dinode, dinode, <span class="dv">128</span>); <span class="cf">return</span> fn;</span>
<span id="cb3-19"><a href="#cb3-19"></a>    }</span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="dt">int</span> inode_num = find_file(path + j, len - j, dinode);</span>
<span id="cb3-21"><a href="#cb3-21"></a>    <span class="cf">if</span> (inode_num) get_inode(inode_num, dinode);</span>
<span id="cb3-22"><a href="#cb3-22"></a>    <span class="cf">else</span> {</span>
<span id="cb3-23"><a href="#cb3-23"></a>        <span class="cf">if</span> (! create) <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-24"><a href="#cb3-24"></a>        inode_num = alloc_inode();</span>
<span id="cb3-25"><a href="#cb3-25"></a>        add_file(path + j, len - j, inode_num, inodep_num, dinode);</span>
<span id="cb3-26"><a href="#cb3-26"></a>        init_inode(inode_num, dinode);</span>
<span id="cb3-27"><a href="#cb3-27"></a>    }</span>
<span id="cb3-28"><a href="#cb3-28"></a>    FNode *fn = bd_malloc(<span class="kw">sizeof</span>(FNode)); fn-&gt;dnum = inode_num;</span>
<span id="cb3-29"><a href="#cb3-29"></a>    memcpy(fn-&gt;dinode, dinode, <span class="dv">128</span>); <span class="cf">return</span> fn;</span>
<span id="cb3-30"><a href="#cb3-30"></a>}</span></code></pre></div>
<p>其中，find_file传入当前路径的inode（dinode存储当前路径）和文件（夹）名在里面查找指定的文件（夹），返回其inode号（注意inode号一律从1开始，根目录的inode号固定为2），get_inode函数根据inode号赋值dinode，即修改当前路径。在创建文件时，注意add_file和init_inode两个函数不能反着执行，因为init_inode里会将dinode修改成刚分配的新inode，而add_file需要dinode里保存的父文件夹。</p>
<p>get_inode函数获得inode信息，每个inode是一个128字节的字符串，连续排放在块组描述表给出的块地址中，所以可以利用整除和取模运算根据inode编号获得inode。upd_inode用来更新inode，和get_inode几乎一样，一并给出：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">void</span> get_inode(<span class="dt">int</span> inode_num, <span class="dt">char</span> *buf) {                                          bcache_rw(inode_table + (inode_num - <span class="dv">1</span>) * <span class="dv">128</span> / BSIZE,</span>
<span id="cb4-2"><a href="#cb4-2"></a>            ((inode_num - <span class="dv">1</span>) * <span class="dv">128</span>) % BSIZE, <span class="dv">128</span>, buf, <span class="dv">0</span>);</span>
<span id="cb4-3"><a href="#cb4-3"></a>}</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="dt">void</span> upd_inode(<span class="dt">int</span> inode_num, <span class="dt">char</span> *buf) {</span>
<span id="cb4-5"><a href="#cb4-5"></a>    bcache_rw(inode_table + (inode_num - <span class="dv">1</span>) * <span class="dv">128</span> / BSIZE,</span>
<span id="cb4-6"><a href="#cb4-6"></a>            ((inode_num - <span class="dv">1</span>) * <span class="dv">128</span>) % BSIZE, <span class="dv">128</span>, buf, <span class="dv">1</span>);</span>
<span id="cb4-7"><a href="#cb4-7"></a>}</span></code></pre></div>
<p>从inode中可以查找该inode对应的文件或文件夹的内容，查找方法后面介绍。文件的内容自然就是其本身的内容，而文件夹的内容是连续排列的一组入口索引。每个入口索引大小不定，包含其对应的子文件（夹）的inode编号（4字节）、索引大小（2字节）、文件（夹）名长度（1字节）、类型（1字节）和文件（夹）名（不定长）。注意入口索引不能跨块，需要按4字节对齐同时存放入口索引的块内不能有空隙，所以最后一个入口索引往往会比较大以充满整个块，这时就会出现入口索引的大小大于其所有属性大小的和的情况。find_file函数就是对入口索引进行查找：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">int</span> find_file(<span class="dt">char</span> *s, <span class="dt">int</span> len, <span class="dt">char</span> *dinode) {</span>
<span id="cb5-2"><a href="#cb5-2"></a>    <span class="dt">int</span> size = TO32(dinode + <span class="dv">4</span>); <span class="dt">char</span> *entry = bd_malloc(size);</span>
<span id="cb5-3"><a href="#cb5-3"></a>    read_inode(dinode, <span class="dv">0</span>, size, entry);</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; size; i += TO16(entry + i + <span class="dv">4</span>)) {</span>
<span id="cb5-5"><a href="#cb5-5"></a>        u8 l = entry[i + <span class="dv">6</span>];</span>
<span id="cb5-6"><a href="#cb5-6"></a>        <span class="cf">if</span> (l == len) {</span>
<span id="cb5-7"><a href="#cb5-7"></a>            <span class="dt">int</span> f = <span class="dv">0</span>;</span>
<span id="cb5-8"><a href="#cb5-8"></a>            <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; l; j++)</span>
<span id="cb5-9"><a href="#cb5-9"></a>                <span class="cf">if</span> (entry[i + <span class="dv">8</span> + j] != s[j]) {</span>
<span id="cb5-10"><a href="#cb5-10"></a>                    f = <span class="dv">1</span>; <span class="cf">break</span>;</span>
<span id="cb5-11"><a href="#cb5-11"></a>                }</span>
<span id="cb5-12"><a href="#cb5-12"></a>            <span class="cf">if</span> (!f) {</span>
<span id="cb5-13"><a href="#cb5-13"></a>                <span class="dt">int</span> r = TO32(entry + i); bd_free(entry);</span>
<span id="cb5-14"><a href="#cb5-14"></a>                <span class="cf">return</span> r;</span>
<span id="cb5-15"><a href="#cb5-15"></a>            }</span>
<span id="cb5-16"><a href="#cb5-16"></a>        }</span>
<span id="cb5-17"><a href="#cb5-17"></a>    }</span>
<span id="cb5-18"><a href="#cb5-18"></a>    bd_free(entry); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-19"><a href="#cb5-19"></a>}</span></code></pre></div>
<p>这里不能使用strcmp进行匹配，因为入口索引中文件（夹）名不一定是以0结尾。该函数也用到了read_inode函数，这个函数用来读取inode对应的文件内容，由于入口索引表是文件夹的所有内容，所以这里获取大小（inode的第四个字节开始的32位整数时文件大小）然后整个读出。这里也可以解释我们平常使用<code>ls -l</code>命令看到的文件夹的大小是什么含义，指的就是其入口索引表的大小。</p>
<p>和find_file类似的一个函数是列举文件夹下子文件（夹）的inode_list函数，这个函数目前只用来在内核开始前用来打印根目录下的内容，以后可能会扩展为系统调用：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1"></a><span class="dt">char</span>* inode_list(FNode *fn, <span class="dt">int</span> *slen) {</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="dt">int</span> size = TO32(dinode + <span class="dv">4</span>); <span class="dt">char</span> *entry = bd_malloc(size);</span>
<span id="cb6-3"><a href="#cb6-3"></a>    read_inode(dinode, <span class="dv">0</span>, size, entry); <span class="dt">int</span> len = <span class="dv">0</span>;</span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; size; i += TO16(entry + i + <span class="dv">4</span>))</span>
<span id="cb6-5"><a href="#cb6-5"></a>        len += (u8)entry[i + <span class="dv">6</span>] + <span class="dv">1</span>;</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="dt">char</span> *s = bd_malloc(len); len = <span class="dv">0</span>;</span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; size; i += TO16(entry + i + <span class="dv">4</span>)) {</span>
<span id="cb6-8"><a href="#cb6-8"></a>        u8 l = entry[i + <span class="dv">6</span>]; memcpy(s + len, entry + i + <span class="dv">8</span>, l);</span>
<span id="cb6-9"><a href="#cb6-9"></a>        s[len + l] = <span class="ch">&#39;\0&#39;</span>; len += l + <span class="dv">1</span>;</span>
<span id="cb6-10"><a href="#cb6-10"></a>    }</span>
<span id="cb6-11"><a href="#cb6-11"></a>    bd_free(entry); *slen = len; <span class="cf">return</span> s;</span>
<span id="cb6-12"><a href="#cb6-12"></a>} </span></code></pre></div>
<p>alloc_inode函数用来分配inode，分两步，第一步是在inode视图中找一个不为1的位（需要用到位运算），将它修改为1，第二步是修改超级块和块组描述表里的“未分配inode”数量，然后返回第一步找到的位对应的inode编号：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">int</span> alloc_inode() {</span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; inode_cnt; i++)</span>
<span id="cb7-3"><a href="#cb7-3"></a>        <span class="cf">if</span> (!(inode_bitmap[i / <span class="dv">8</span>] &amp; (<span class="dv">1</span> &lt;&lt; (i % <span class="dv">8</span>)))) {</span>
<span id="cb7-4"><a href="#cb7-4"></a>            inode_bitmap[i / <span class="dv">8</span>] |= (<span class="dv">1</span> &lt;&lt; (i % <span class="dv">8</span>));</span>
<span id="cb7-5"><a href="#cb7-5"></a>            bcache_rw(inode_bitmap_addr, <span class="dv">0</span>, inode_cnt / <span class="dv">8</span>, inode_bitmap, <span class="dv">1</span>);</span>
<span id="cb7-6"><a href="#cb7-6"></a>            superblock[<span class="dv">1</span>]--; gdt_num[<span class="dv">1</span>]--;</span>
<span id="cb7-7"><a href="#cb7-7"></a>            bcache_rw(<span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">8</span>, superblock, <span class="dv">1</span>);</span>
<span id="cb7-8"><a href="#cb7-8"></a>            bcache_rw(<span class="dv">2</span>, <span class="dv">12</span>, <span class="dv">4</span>, gdt_num, <span class="dv">1</span>);</span>
<span id="cb7-9"><a href="#cb7-9"></a>            <span class="cf">return</span> i + <span class="dv">1</span>;</span>
<span id="cb7-10"><a href="#cb7-10"></a>        }</span>
<span id="cb7-11"><a href="#cb7-11"></a>    panic(<span class="st">&quot;alloc_inode: no free inode&quot;</span>);</span>
<span id="cb7-12"><a href="#cb7-12"></a>}</span></code></pre></div>
<p>add_file函数在指定文件夹的入口索引表中创建一个新入口索引，将文件名、大小、名字、inode号等填入索引。这里比较麻烦的就是如前所述，最后一个入口索引往往会比较大以充满整个块。如果每次创建新入口索引的时候都是直接创建在最后一个入口索引后面，那么相当于每个入口索引都要占一个块，会浪费大量空间，所以这里需要看一下最后一个入口索引在文件名后面到块末尾还有没有足够的空间装下新索引，有的话就缩小一下它的大小，然后让新索引填满剩下的空间：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1"></a><span class="dt">void</span> add_file(<span class="dt">char</span> *name, <span class="dt">int</span> len, <span class="dt">int</span> inode_num, <span class="dt">int</span> inodep_num, <span class="dt">char</span> *dinode)     <span class="dt">int</span> size = TO32(dinode + <span class="dv">4</span>); <span class="dt">char</span> *entry = bd_malloc(size);</span>
<span id="cb8-2"><a href="#cb8-2"></a>    read_inode(dinode, <span class="dv">0</span>, size, entry); <span class="dt">int</span> i = <span class="dv">0</span>;</span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="cf">while</span> (i + TO16(entry + i + <span class="dv">4</span>) &lt; size) i += TO16(entry + i + <span class="dv">4</span>);</span>
<span id="cb8-4"><a href="#cb8-4"></a>    u8 l = entry[i + <span class="dv">6</span>]; <span class="dt">int</span> real_size = (<span class="dv">8</span> + l + <span class="dv">3</span>) / <span class="dv">4</span> * <span class="dv">4</span>;</span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="cf">if</span> (TO16(entry + i + <span class="dv">4</span>) - real_size &gt;= (<span class="dv">8</span> + len + <span class="dv">3</span>) / <span class="dv">4</span> * <span class="dv">4</span>) {</span>
<span id="cb8-6"><a href="#cb8-6"></a>        TO16(entry + i + <span class="dv">4</span>) = real_size;</span>
<span id="cb8-7"><a href="#cb8-7"></a>        TO32(entry + i + real_size) = inode_num;</span>
<span id="cb8-8"><a href="#cb8-8"></a>        TO16(entry + i + real_size + <span class="dv">4</span>) = size - i - real_size;</span>
<span id="cb8-9"><a href="#cb8-9"></a>        entry[i + real_size + <span class="dv">6</span>] = len; entry[i + real_size + <span class="dv">7</span>] = <span class="dv">1</span>;</span>
<span id="cb8-10"><a href="#cb8-10"></a>        memcpy(entry + i + real_size + <span class="dv">8</span>, name, len);</span>
<span id="cb8-11"><a href="#cb8-11"></a>        write_inode(inodep_num, dinode, <span class="dv">0</span>, size, entry);</span>
<span id="cb8-12"><a href="#cb8-12"></a>    } <span class="cf">else</span> {</span>
<span id="cb8-13"><a href="#cb8-13"></a>        real_size = (<span class="dv">8</span> + len + <span class="dv">3</span>) / <span class="dv">4</span> * <span class="dv">4</span>; memset(entry, <span class="dv">0</span>, real_size);</span>
<span id="cb8-14"><a href="#cb8-14"></a>        TO32(entry) = inode_num; TO16(entry + <span class="dv">4</span>) = BSIZE;</span>
<span id="cb8-15"><a href="#cb8-15"></a>        entry[<span class="dv">6</span>] = len; entry[<span class="dv">7</span>] = <span class="dv">1</span>; memcpy(entry + <span class="dv">8</span>, name, len);</span>
<span id="cb8-16"><a href="#cb8-16"></a>        write_inode(inodep_num, dinode, size, size + real_size, entry);</span>
<span id="cb8-17"><a href="#cb8-17"></a>    }</span>
<span id="cb8-18"><a href="#cb8-18"></a>    bd_free(entry);</span>
<span id="cb8-19"><a href="#cb8-19"></a>}</span></code></pre></div>
<p>这里用到了write_inode函数，这个函数会自动扩大文件大小使得所有数据都能被写到文件中。所以当新索引挤不进最后一个索引内的时候就直接把新索引写到最后一个索引后面（注意要按4字节对齐）。</p>
<p>init_inode就比较简单了，大部分属性都可以填成0。但值得注意的是前两个字节，存放文件类型和权限，文件类型是普通文件（8），权限设置成类似平常用的<code>chmod 777</code>里的777，这个777是8进制，十六进制1ff。根据这个属性的定义，高4字节是文件类型，低12字节是权限，所以这个属性应赋值为81ff：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1"></a><span class="dt">void</span> init_inode(<span class="dt">int</span> inode_num, <span class="dt">char</span> *dinode) {                                      memset(dinode, <span class="dv">0</span>, <span class="dv">128</span>);</span>
<span id="cb9-2"><a href="#cb9-2"></a>    TO16(dinode) = <span class="bn">0x81ff</span>; TO16(dinode + <span class="dv">26</span>) = <span class="dv">1</span>;</span>
<span id="cb9-3"><a href="#cb9-3"></a>    upd_inode(inode_num, dinode);</span>
<span id="cb9-4"><a href="#cb9-4"></a>}</span></code></pre></div>
<p>根据文件系统的设计，写文件的时候文件基本只能越写越大，因此需要清空文件的函数。其内容就是将inode的文件大小属性设置为0，然后将文件占用的块全部清空。ext2格式文件内容的组织是由零级索引、一级索引、二级索引……组成的。对于inode，其第40字节开始就是索引。共12个零级索引，1个一级索引，一个二级索引，一个三级索引。每个索引都是4字节，如果一个块为1024字节，那么共可索引的块数是12+256+256*256+256*256*256。要清除文件占用的所有块，可以递归对这些索引进行查找：</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1"></a><span class="dt">int</span> dfs_clear(<span class="dt">int</span> block_num, <span class="dt">int</span> dep) {</span>
<span id="cb10-2"><a href="#cb10-2"></a>    <span class="cf">if</span> (block_num == <span class="dv">0</span>) <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="cf">if</span> (dep == <span class="dv">0</span>) {</span>
<span id="cb10-4"><a href="#cb10-4"></a>        free_block(block_num); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-5"><a href="#cb10-5"></a>    }</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="dt">int</span> *table = bd_malloc(BSIZE);</span>
<span id="cb10-7"><a href="#cb10-7"></a>    bcache_rw(block_num, <span class="dv">0</span>, BSIZE, table, <span class="dv">0</span>);</span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="dt">int</span> f = <span class="dv">0</span>;</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; BSIZE / <span class="dv">4</span>; i++)</span>
<span id="cb10-10"><a href="#cb10-10"></a>        <span class="cf">if</span> (dfs_clear(table[i], dep - <span class="dv">1</span>)) { f = <span class="dv">1</span>; <span class="cf">break</span>; }</span>
<span id="cb10-11"><a href="#cb10-11"></a>    bd_free(table); free_block(block_num); <span class="cf">return</span> f;</span>
<span id="cb10-12"><a href="#cb10-12"></a>}</span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="dt">void</span> inode_clear(FNode *fn) {</span>
<span id="cb10-14"><a href="#cb10-14"></a>    TO32(fn-&gt;dinode + <span class="dv">4</span>) = <span class="dv">0</span>;</span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">12</span>; i++)</span>
<span id="cb10-16"><a href="#cb10-16"></a>        <span class="cf">if</span> (dfs_clear(TO32(fn-&gt;dinode + <span class="dv">40</span> + i * <span class="dv">4</span>), <span class="dv">0</span>)) <span class="cf">goto</span> write;</span>
<span id="cb10-17"><a href="#cb10-17"></a>    <span class="cf">if</span> (dfs_clear(TO32(fn-&gt;dinode + <span class="dv">88</span>), <span class="dv">1</span>)) <span class="cf">goto</span> write;</span>
<span id="cb10-18"><a href="#cb10-18"></a>    <span class="cf">if</span> (dfs_clear(TO32(fn-&gt;dinode + <span class="dv">92</span>), <span class="dv">2</span>)) <span class="cf">goto</span> write;</span>
<span id="cb10-19"><a href="#cb10-19"></a>    dfs_clear(TO32(fn-&gt;dinode + <span class="dv">96</span>), <span class="dv">3</span>);</span>
<span id="cb10-20"><a href="#cb10-20"></a>write:</span>
<span id="cb10-21"><a href="#cb10-21"></a>    memset(fn-&gt;dinode + <span class="dv">40</span>, <span class="dv">0</span>, <span class="dv">60</span>); upd_inode(fn-&gt;dnum, fn-&gt;dinode);</span>
<span id="cb10-22"><a href="#cb10-22"></a>}</span></code></pre></div>
<p>dep=0表示当前块号是直接存储文件内容的块。如果递归dfs_clear返回1表示接下来不用再递归后面的索引了。</p>
<p>关于块的分配和释放，与inode的分配类似：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1"></a><span class="dt">int</span> alloc_block() {</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; block_cnt; i++)</span>
<span id="cb11-3"><a href="#cb11-3"></a>        <span class="cf">if</span> (!(block_bitmap[i / <span class="dv">8</span>] &amp; (<span class="dv">1</span> &lt;&lt; (i % <span class="dv">8</span>)))) {</span>
<span id="cb11-4"><a href="#cb11-4"></a>            block_bitmap[i / <span class="dv">8</span>] |= (<span class="dv">1</span> &lt;&lt; (i % <span class="dv">8</span>));</span>
<span id="cb11-5"><a href="#cb11-5"></a>            bcache_rw(block_bitmap_addr, <span class="dv">0</span>, block_cnt / <span class="dv">8</span>, block_bitmap, <span class="dv">1</span>);</span>
<span id="cb11-6"><a href="#cb11-6"></a>            superblock[<span class="dv">0</span>]--; gdt_num[<span class="dv">0</span>]--;</span>
<span id="cb11-7"><a href="#cb11-7"></a>            bcache_rw(<span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">8</span>, superblock, <span class="dv">1</span>);</span>
<span id="cb11-8"><a href="#cb11-8"></a>            bcache_rw(<span class="dv">2</span>, <span class="dv">12</span>, <span class="dv">4</span>, gdt_num, <span class="dv">1</span>);</span>
<span id="cb11-9"><a href="#cb11-9"></a>            <span class="dt">char</span>* zero = bd_malloc(BSIZE); memset(zero, <span class="dv">0</span>, BSIZE);</span>
<span id="cb11-10"><a href="#cb11-10"></a>            bcache_rw(i, <span class="dv">0</span>, BSIZE, zero, <span class="dv">1</span>); bd_free(zero); <span class="cf">return</span> i;</span>
<span id="cb11-11"><a href="#cb11-11"></a>        }</span>
<span id="cb11-12"><a href="#cb11-12"></a>    panic(<span class="st">&quot;alloc_block: no free block&quot;</span>);</span>
<span id="cb11-13"><a href="#cb11-13"></a>}</span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="dt">void</span> free_block(<span class="dt">int</span> block_no) {</span>
<span id="cb11-15"><a href="#cb11-15"></a>    <span class="cf">if</span> (!(block_bitmap[block_no / <span class="dv">8</span>] &amp; (<span class="dv">1</span> &lt;&lt; (block_no % <span class="dv">8</span>))))</span>
<span id="cb11-16"><a href="#cb11-16"></a>        panic(<span class="st">&quot;free_block: block has been freed&quot;</span>);</span>
<span id="cb11-17"><a href="#cb11-17"></a>    <span class="cf">else</span> {</span>
<span id="cb11-18"><a href="#cb11-18"></a>        block_bitmap[block_no / <span class="dv">8</span>] &amp;= (~(<span class="dv">1</span> &lt;&lt; (block_no % <span class="dv">8</span>)));</span>
<span id="cb11-19"><a href="#cb11-19"></a>        bcache_rw(block_bitmap_addr, <span class="dv">0</span>, block_cnt / <span class="dv">8</span>, block_bitmap, <span class="dv">1</span>);</span>
<span id="cb11-20"><a href="#cb11-20"></a>        superblock[<span class="dv">0</span>]++; gdt_num[<span class="dv">0</span>]++;</span>
<span id="cb11-21"><a href="#cb11-21"></a>        bcache_rw(<span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">8</span>, superblock, <span class="dv">1</span>);</span>
<span id="cb11-22"><a href="#cb11-22"></a>        bcache_rw(<span class="dv">2</span>, <span class="dv">12</span>, <span class="dv">4</span>, gdt_num, <span class="dv">1</span>);</span>
<span id="cb11-23"><a href="#cb11-23"></a>    }</span>
<span id="cb11-24"><a href="#cb11-24"></a>}</span></code></pre></div>
<p>接下来是inode_read和inode_write函数，注意我定义了两组函数，一组是inode_read/inode_write，另一组是read_inode/write_inode。前者供文件描述符层调用，接收的参数是FNode类型，根据FNode里的offset属性确定读写起始位置，然后调用后者，后者才是真正对inode进行操作。前者的inode_read函数还需要判断当前读的长度是否超过了文件大小，如果超过了则只读能够读的最大长度：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1"></a>usize inode_read(FNode *fn, <span class="dt">char</span> *buf, usize len) {</span>
<span id="cb12-2"><a href="#cb12-2"></a>    <span class="cf">if</span> (fn-&gt;offset + len &gt; TO32(fn-&gt;dinode + <span class="dv">4</span>)) {</span>
<span id="cb12-3"><a href="#cb12-3"></a>        usize r = TO32(fn-&gt;dinode + <span class="dv">4</span>) - fn-&gt;offset;</span>
<span id="cb12-4"><a href="#cb12-4"></a>        read_inode(fn-&gt;dinode, fn-&gt;offset, r, buf);</span>
<span id="cb12-5"><a href="#cb12-5"></a>        fn-&gt;offset += r; <span class="cf">return</span> r;</span>
<span id="cb12-6"><a href="#cb12-6"></a>    } <span class="cf">else</span> {</span>
<span id="cb12-7"><a href="#cb12-7"></a>        read_inode(fn-&gt;dinode, fn-&gt;offset, len, buf);</span>
<span id="cb12-8"><a href="#cb12-8"></a>        fn-&gt;offset += len; <span class="cf">return</span> len;</span>
<span id="cb12-9"><a href="#cb12-9"></a>    }</span>
<span id="cb12-10"><a href="#cb12-10"></a>}</span>
<span id="cb12-11"><a href="#cb12-11"></a>usize inode_write(FNode *fn, <span class="dt">char</span> *buf, usize len) {</span>
<span id="cb12-12"><a href="#cb12-12"></a>    write_inode(fn-&gt;dnum, fn-&gt;dinode, fn-&gt;offset, len, buf);</span>
<span id="cb12-13"><a href="#cb12-13"></a>    fn-&gt;offset += len; <span class="cf">return</span> len;</span>
<span id="cb12-14"><a href="#cb12-14"></a>}</span></code></pre></div>
<p>read_inode函数就比较复杂了。重点是“找文件内容的下一个块”操作，由于我们用的文件映像比较小，所以也不会出现需要用到三级索引的超大文件，这里就忽略它了。于是我就用l0、l1、l2表示当前所在的各级索引。在函数最开始先根据读的起始位置算出l0、l1、l2的初始值，然后将读的长度切分成以块为单位，不断跳到下一个块，根据l0、l1、l2逐级找到要读的内容。下一个块的各级索引则根据各种边界判断进行计算，具体见代码：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1"></a><span class="dt">void</span> read_inode(<span class="dt">char</span> *dinode, usize st, usize len, <span class="dt">char</span> *buf) {</span>
<span id="cb13-2"><a href="#cb13-2"></a>    <span class="dt">int</span> l0, l1, l2;</span>
<span id="cb13-3"><a href="#cb13-3"></a>    find_block(dinode, st, &amp;l0, &amp;l1, &amp;l2);</span>
<span id="cb13-4"><a href="#cb13-4"></a>    usize cpoff = <span class="dv">0</span>; st %= BSIZE;</span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="cf">while</span> (len) {</span>
<span id="cb13-6"><a href="#cb13-6"></a>        usize cplen = min(BSIZE - st, len);</span>
<span id="cb13-7"><a href="#cb13-7"></a>        <span class="cf">if</span> (l0 &lt; <span class="dv">12</span>) {</span>
<span id="cb13-8"><a href="#cb13-8"></a>            bcache_rw(TO32(dinode + <span class="dv">40</span> + <span class="dv">4</span> * l0), st, cplen, buf + cpoff, <span class="dv">0</span>);</span>
<span id="cb13-9"><a href="#cb13-9"></a>            l0++;</span>
<span id="cb13-10"><a href="#cb13-10"></a>        } <span class="cf">else</span> <span class="cf">if</span> (l0 == <span class="dv">12</span>) {</span>
<span id="cb13-11"><a href="#cb13-11"></a>            <span class="dt">int</span> block_no; bcache_rw(TO32(dinode + <span class="dv">88</span>), l1 * <span class="dv">4</span>, <span class="dv">4</span>, &amp;block_no, <span class="dv">0</span>);            bcache_rw(block_no, st, cplen, buf + cpoff, <span class="dv">0</span>); l1++;</span>
<span id="cb13-12"><a href="#cb13-12"></a>            <span class="cf">if</span> (l1 == BSIZE / <span class="dv">4</span>) { l1 = <span class="dv">0</span>; l0++; }</span>
<span id="cb13-13"><a href="#cb13-13"></a>        } <span class="cf">else</span> <span class="cf">if</span> (l0 == <span class="dv">13</span>) {</span>
<span id="cb13-14"><a href="#cb13-14"></a>            <span class="dt">int</span> block_no; bcache_rw(TO32(dinode + <span class="dv">92</span>), l1 * <span class="dv">4</span>, <span class="dv">4</span>, &amp;block_no, <span class="dv">0</span>);            bcache_rw(block_no, l2 * <span class="dv">4</span>, <span class="dv">4</span>, &amp;block_no, <span class="dv">0</span>);</span>
<span id="cb13-15"><a href="#cb13-15"></a>            bcache_rw(block_no, st, cplen, buf + cpoff, <span class="dv">0</span>); l2++;</span>
<span id="cb13-16"><a href="#cb13-16"></a>            <span class="cf">if</span> (l2 == BSIZE / <span class="dv">4</span>) { l2 = <span class="dv">0</span>; l1++; }</span>
<span id="cb13-17"><a href="#cb13-17"></a>            <span class="cf">if</span> (l1 == BSIZE / <span class="dv">4</span>) panic(<span class="st">&quot;read_inode: len too large&quot;</span>);</span>
<span id="cb13-18"><a href="#cb13-18"></a>        } <span class="cf">else</span> panic(<span class="st">&quot;read_inode: len too large&quot;</span>);</span>
<span id="cb13-19"><a href="#cb13-19"></a>        st = <span class="dv">0</span>; len -= cplen; cpoff += cplen;</span>
<span id="cb13-20"><a href="#cb13-20"></a>    }</span>
<span id="cb13-21"><a href="#cb13-21"></a>}</span></code></pre></div>
<p>find_block函数用来计算l0、l1、l2的初始值，具体也是各种条件判断：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1"></a><span class="dt">void</span> find_block(<span class="dt">char</span> *dinode, usize st, <span class="dt">int</span> *l0, <span class="dt">int</span> *l1, <span class="dt">int</span> *l2) {                *l0 = <span class="dv">0</span>, *l1 = <span class="dv">0</span>, *l2 = <span class="dv">0</span>; <span class="dt">int</span> bn = BSIZE / <span class="dv">4</span>;</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="cf">if</span> (st &lt; BSIZE * <span class="dv">12</span>) *l0 = st / BSIZE;</span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="cf">else</span> <span class="cf">if</span> (st &lt; BSIZE * <span class="dv">12</span> + bn * BSIZE) {</span>
<span id="cb14-4"><a href="#cb14-4"></a>        *l0 = <span class="dv">12</span>; *l1 = (st - BSIZE * <span class="dv">12</span>) % BSIZE;</span>
<span id="cb14-5"><a href="#cb14-5"></a>    } <span class="cf">else</span> <span class="cf">if</span> (st &lt; BSIZE * <span class="dv">12</span> + bn * BSIZE + bn * bn * BSIZE) {</span>
<span id="cb14-6"><a href="#cb14-6"></a>        *l0 = <span class="dv">13</span>; *l1 = (st - BSIZE * <span class="dv">12</span>) / (bn * BSIZE);</span>
<span id="cb14-7"><a href="#cb14-7"></a>        *l2 = ((st - BSIZE * <span class="dv">12</span>) % (bn * BSIZE)) / BSIZE;</span>
<span id="cb14-8"><a href="#cb14-8"></a>    } <span class="cf">else</span> panic(<span class="st">&quot;find_block: offset too large&quot;</span>);</span>
<span id="cb14-9"><a href="#cb14-9"></a>}</span></code></pre></div>
<p>write_inode在read_inode的基础上就是需要当待写的块不存在时，需要分配块并把块号填入到索引中：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1"></a><span class="dt">void</span> write_inode(<span class="dt">int</span> inode_num, <span class="dt">char</span> *dinode, usize st, usize len, <span class="dt">char</span> *buf) {</span>
<span id="cb15-2"><a href="#cb15-2"></a>    <span class="cf">if</span> (st + len &gt; TO32(dinode + <span class="dv">4</span>)) {</span>
<span id="cb15-3"><a href="#cb15-3"></a>        TO32(dinode + <span class="dv">4</span>) = st + len;</span>
<span id="cb15-4"><a href="#cb15-4"></a>        upd_inode(inode_num, dinode);</span>
<span id="cb15-5"><a href="#cb15-5"></a>    }</span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="dt">int</span> l0, l1, l2;</span>
<span id="cb15-7"><a href="#cb15-7"></a>    find_block(dinode, st, &amp;l0, &amp;l1, &amp;l2);</span>
<span id="cb15-8"><a href="#cb15-8"></a>    usize cpoff = <span class="dv">0</span>; st %= BSIZE;</span>
<span id="cb15-9"><a href="#cb15-9"></a>    <span class="cf">while</span> (len) {</span>
<span id="cb15-10"><a href="#cb15-10"></a>        usize cplen = min(BSIZE - st, len);</span>
<span id="cb15-11"><a href="#cb15-11"></a>        <span class="cf">if</span> (TO32(dinode + <span class="dv">40</span> + <span class="dv">4</span> * l0) == <span class="dv">0</span>) {</span>
<span id="cb15-12"><a href="#cb15-12"></a>            TO32(dinode + <span class="dv">40</span> + <span class="dv">4</span> * l0) = alloc_block();</span>
<span id="cb15-13"><a href="#cb15-13"></a>            upd_inode(inode_num, dinode);</span>
<span id="cb15-14"><a href="#cb15-14"></a>        }</span>
<span id="cb15-15"><a href="#cb15-15"></a>        <span class="cf">if</span> (l0 &lt; <span class="dv">12</span>) {</span>
<span id="cb15-16"><a href="#cb15-16"></a>            bcache_rw(TO32(dinode + <span class="dv">40</span> + <span class="dv">4</span> * l0), st, cplen, buf + cpoff, <span class="dv">1</span>); l0++;        } <span class="cf">else</span> <span class="cf">if</span> (l0 == <span class="dv">12</span>) {</span>
<span id="cb15-17"><a href="#cb15-17"></a>            <span class="dt">int</span> block_no = get_alloc_block(TO32(dinode + <span class="dv">88</span>), l1);</span>
<span id="cb15-18"><a href="#cb15-18"></a>            bcache_rw(block_no, st, cplen, buf + cpoff, <span class="dv">1</span>); l1++;</span>
<span id="cb15-19"><a href="#cb15-19"></a>            <span class="cf">if</span> (l1 == BSIZE / <span class="dv">4</span>) { l1 = <span class="dv">0</span>; l0++; }</span>
<span id="cb15-20"><a href="#cb15-20"></a>        } <span class="cf">else</span> <span class="cf">if</span> (l0 == <span class="dv">13</span>) {</span>
<span id="cb15-21"><a href="#cb15-21"></a>            <span class="dt">int</span> block_no = get_alloc_block(TO32(dinode + <span class="dv">92</span>), l1);</span>
<span id="cb15-22"><a href="#cb15-22"></a>            block_no = get_alloc_block(block_no, l1);</span>
<span id="cb15-23"><a href="#cb15-23"></a>            bcache_rw(block_no, st, cplen, buf + cpoff, <span class="dv">1</span>); l2++;</span>
<span id="cb15-24"><a href="#cb15-24"></a>            <span class="cf">if</span> (l2 == BSIZE / <span class="dv">4</span>) { l2 = <span class="dv">0</span>; l1++; }</span>
<span id="cb15-25"><a href="#cb15-25"></a>            <span class="cf">if</span> (l1 == BSIZE / <span class="dv">4</span>) panic(<span class="st">&quot;write_inode: len too large&quot;</span>);</span>
<span id="cb15-26"><a href="#cb15-26"></a>        } <span class="cf">else</span> panic(<span class="st">&quot;write_inode: len too large&quot;</span>);</span>
<span id="cb15-27"><a href="#cb15-27"></a>        st = <span class="dv">0</span>; len -= cplen; cpoff += cplen;</span>
<span id="cb15-28"><a href="#cb15-28"></a>    }</span>
<span id="cb15-29"><a href="#cb15-29"></a>}</span></code></pre></div>
<p>当inode上的索引为空时，肯定是要分配的，不管它是零级还是一级还是其他级，分配完就更新inode。在逐级找到要写入的块时，我用get_alloc_block函数把重复操作包装起来了，主要就是如果索引中该块大于0则返回，等于0则分配新块并写到索引中：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1"></a><span class="dt">int</span> get_alloc_block(<span class="dt">int</span> now_block, <span class="dt">int</span> index) {                                         <span class="dt">int</span> x; bcache_rw(now_block, index * <span class="dv">4</span>, <span class="dv">4</span>, &amp;x, <span class="dv">0</span>);</span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="cf">if</span> (!x) {</span>
<span id="cb16-3"><a href="#cb16-3"></a>        x = alloc_block(); bcache_rw(now_block, index * <span class="dv">4</span>, <span class="dv">4</span>, &amp;x, <span class="dv">1</span>);</span>
<span id="cb16-4"><a href="#cb16-4"></a>    }</span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="cf">return</span> x;</span>
<span id="cb16-6"><a href="#cb16-6"></a>}</span></code></pre></div>
<p>注意当写入的内容大于文件大小时，inode_write还要更新文件大小。</p>
<p>以上是文件节点层的内容，非常复杂和繁琐。其本质也就是对二进制格式文件的读写，复杂性主要在于三个方面，一个是文件系统本身的复杂性，像各类算法竞赛、考试，文件系统相关的题目一直一来都是各色”大模拟“题、”码农“题的常客，既包括对路径的字符串解析、又包括对文件树的操作，操作往往有多个种类，这就涉及状态的处理了；二是二进制格式文件的写比读要困难的多，因为读只需要关注想读的内容在哪、多大就行了，而写则需要适应整个格式的要求，除了写对应的内容，还需要修改各类元数据以满足文件格式的要求。就像我这个程序，如果只需要读取文件的话，那么和分配inode、block、创建文件相关的函数全部可以扔掉了，代码至少少掉七成；三是文件系统布局本身的复杂性，尤其是inode的多级索引那块比较繁琐。</p>
<p>块缓存层就比较简单了，替换策略用的是LRU算法，通过时间戳实现。具体而言，每次读写块分三步：</p>
<ol type="1">
<li>枚举所有缓存，找到一个已使用缓存且其块号和待读写块号相等，则读写该块，跳过后面步骤。</li>
<li>枚举所有缓存，找到一个未使用缓存，则从磁盘中加载待读写块到缓存，读写该块，跳过后面步骤。</li>
<li>在第2步中同时找到已使用的时间戳最大的缓存，如果到达该步则需要淘汰这个时间戳最大的缓存，那么就检查该缓存是否被修改过，是则写回，然后从磁盘中加载待的读写块到缓存，读写该块。</li>
</ol>
<p>每次读写完一个缓存时将其时间戳置为0，每次返回时将所有已使用缓存的时间戳加1：</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1"></a><span class="dt">void</span> bcache_rw(<span class="dt">int</span> blockno, <span class="dt">int</span> st, <span class="dt">int</span> len, <span class="dt">void</span> *data, <span class="dt">int</span> write) {</span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="cf">while</span> (bcache_state) suspend_current_and_run_next(); bcache_state = <span class="dv">1</span>;</span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NBUF; i++)</span>
<span id="cb17-4"><a href="#cb17-4"></a>        <span class="cf">if</span> (buf[i].occupied &amp;&amp; buf[i].blockno == blockno) {</span>
<span id="cb17-5"><a href="#cb17-5"></a>            <span class="cf">if</span> (write) {</span>
<span id="cb17-6"><a href="#cb17-6"></a>                memcpy(buf[i].data + st, data, len); buf[i].modify = <span class="dv">1</span>;</span>
<span id="cb17-7"><a href="#cb17-7"></a>            } <span class="cf">else</span> memcpy(data, buf[i].data + st, len);</span>
<span id="cb17-8"><a href="#cb17-8"></a>            buf[i].time = <span class="dv">0</span>; <span class="cf">goto</span> updtime;</span>
<span id="cb17-9"><a href="#cb17-9"></a>        }</span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="dt">int</span> mx = <span class="dv">0</span>;</span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NBUF; i++)</span>
<span id="cb17-12"><a href="#cb17-12"></a>        <span class="cf">if</span> (!buf[i].occupied) {</span>
<span id="cb17-13"><a href="#cb17-13"></a>            buf[i].occupied = <span class="dv">1</span>; buf[i].blockno = blockno;</span>
<span id="cb17-14"><a href="#cb17-14"></a>            virtio_disk_rw(buf + i, <span class="dv">0</span>);</span>
<span id="cb17-15"><a href="#cb17-15"></a>            <span class="cf">if</span> (write) {</span>
<span id="cb17-16"><a href="#cb17-16"></a>                memcpy(buf[i].data + st, data, len); buf[i].modify = <span class="dv">1</span>;</span>
<span id="cb17-17"><a href="#cb17-17"></a>            } <span class="cf">else</span> {</span>
<span id="cb17-18"><a href="#cb17-18"></a>                memcpy(data, buf[i].data + st, len); buf[i].modify = <span class="dv">0</span>;</span>
<span id="cb17-19"><a href="#cb17-19"></a>            }</span>
<span id="cb17-20"><a href="#cb17-20"></a>            buf[i].time = <span class="dv">0</span>; <span class="cf">goto</span> updtime;</span>
<span id="cb17-21"><a href="#cb17-21"></a>        } <span class="cf">else</span> <span class="cf">if</span> (buf[i].time &gt; buf[mx].time) mx = i;</span>
<span id="cb17-22"><a href="#cb17-22"></a>    buf[mx].time = <span class="dv">0</span>; <span class="cf">if</span> (buf[mx].modify) virtio_disk_rw(buf + mx, <span class="dv">1</span>);</span>
<span id="cb17-23"><a href="#cb17-23"></a>    buf[mx].blockno = blockno; virtio_disk_rw(buf + mx, <span class="dv">0</span>);</span>
<span id="cb17-24"><a href="#cb17-24"></a>    <span class="cf">if</span> (write) {</span>
<span id="cb17-25"><a href="#cb17-25"></a>        memcpy(buf[mx].data + st, data, len); buf[mx].modify = <span class="dv">1</span>;</span>
<span id="cb17-26"><a href="#cb17-26"></a>    } <span class="cf">else</span> {</span>
<span id="cb17-27"><a href="#cb17-27"></a>        memcpy(data, buf[mx].data + st, len); buf[mx].modify = <span class="dv">0</span>;</span>
<span id="cb17-28"><a href="#cb17-28"></a>    }</span>
<span id="cb17-29"><a href="#cb17-29"></a>updtime:</span>
<span id="cb17-30"><a href="#cb17-30"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NBUF; i++)</span>
<span id="cb17-31"><a href="#cb17-31"></a>        <span class="cf">if</span> (buf[i].occupied) buf[i].time++;</span>
<span id="cb17-32"><a href="#cb17-32"></a>    bcache_state = <span class="dv">0</span>;</span>
<span id="cb17-33"><a href="#cb17-33"></a>}</span></code></pre></div>
<p>注意这里用了一个变量bcache_state，这个变量起到的作用类似锁。为什么没有时钟中断，这里还需要用锁呢？我们知道，锁主要防止的是一个任务数据写到一半被另一个任务读取。这里主要可能导致这一点就是在virtio_disk里等待磁盘响应过程中的suspend_current_and_run_next函数切换进程。在其他地方，这个函数执行的时候并没有”数据写到一半“的情况，但这里不一样，像缓存淘汰的过程中，需要先写回缓存的原数据，然后再修改块号，再读入新数据，这涉及到多次对缓存属性的更新，同时又可能在读写磁盘的过程中被打断更新，被另一个进程读取，这就会发生错误，所以这里用了一个锁。当然由于没有时钟中断和多核处理，这个锁的状态就不需要用原子操作去修改，直接赋值就行了。</p>
<p>缓存层还提供了一个bcache_save函数，一次性保存所有已使用且修改过的缓存。每次close文件的时候通过这个函数来使得所有的写操作即时得到保存：</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1"></a><span class="dt">void</span> bcache_save() {</span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="cf">while</span> (bcache_state) suspend_current_and_run_next(); bcache_state = <span class="dv">1</span>;</span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NBUF; i++) <span class="cf">if</span> (buf[i].occupied &amp;&amp; buf[i].modify) {</span>
<span id="cb18-4"><a href="#cb18-4"></a>        virtio_disk_rw(buf + i, <span class="dv">1</span>); buf[i].modify = <span class="dv">0</span>;</span>
<span id="cb18-5"><a href="#cb18-5"></a>    }</span>
<span id="cb18-6"><a href="#cb18-6"></a>    bcache_state = <span class="dv">0</span>;</span>
<span id="cb18-7"><a href="#cb18-7"></a>}</span></code></pre></div>
<p>这两层的独立性比较强，用一个源文件把virtio_rw等函数替换成直接访问文件映像之类的函数，配上一个主程序，就可以用宿主机的编译器编译运行，方便调试，也可以独立出来作为读写ext2文件映像的工具程序。</p>
<footer>
    <hr><center>转载请注明出处<br>© 2022 ZimingYuan的博客</center>
</footer>
</body>
</html>
