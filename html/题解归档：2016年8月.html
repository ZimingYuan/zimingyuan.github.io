<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="题解归档：2016年8月" />
  <meta name="keywords" content="" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 "LXGW Bright", Georgia, serif;
    --font-h: 1.4rem/1.5 "LXGW Bright", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" type="text/css" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css"/>
  <title>题解归档：2016年8月</title>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">技术</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li><a href="/friends.html">友链</a></li>
            <li><a href="/html/关于.html">关于</a></li>
            <li><a href="https://www.travellings.cn/go.html" target="_blank">开往</a></li>
            <li class="float-right sticky"><button style="margin: 0" onclick="search()">
              <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M15.7955 15.8111L21 21M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>
            </button></li>
            <li class="float-right sticky"><input type="search" placeholder="搜索标题" style="margin: 0"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">题解归档：2016年8月</h1>
<hr>
</header>
<h3 id="bzoj1623usaco2008-opencow-cars-奶牛飞车2016.8.1">bzoj1623[Usaco2008 Open]Cow Cars 奶牛飞车*（2016.8.1）</h3>
<h4 id="题意">题意</h4>
<p>n头奶牛开车，第i头速度上限为si，高速上有m个车道，如果在一头奶牛前面有d头奶牛位于它所在车道，这头奶牛的实际速度为si-k*d，高速最低速度为l，求一共可以让多少头奶牛上高速。n，m≤50000</p>
<h4 id="题解">题解</h4>
<p>先让所有奶牛按速度上限排序，然后依次选取：求出当前奶牛前面最多可以有多少头奶牛x，然后二分求出m条车道中当前奶牛数小于等于x且最大的那条车道，把这头奶牛放入这个车道；如果没位置可放或这头奶牛速度上限小于l，就将它弃置。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#define maxn </span><span class="dv">50100</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb1-13"><a href="#cb1-13"></a>}</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="dt">int</span> n,m,d,l,a[maxn],b[maxn],ans;</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="dt">int</span> find(<span class="dt">int</span> x){</span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="dt">int</span> l=<span class="dv">1</span>,r=m,ans=-<span class="dv">1</span>;</span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="cf">while</span>(l&lt;=r){<span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(x&gt;=b[mid])ans=mid,r=mid-<span class="dv">1</span>;<span class="cf">else</span> l=mid+<span class="dv">1</span>;}</span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="cf">return</span> ans;</span>
<span id="cb1-19"><a href="#cb1-19"></a>}</span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="dt">int</span> main(){</span>
<span id="cb1-21"><a href="#cb1-21"></a>    n=read(); m=read(); d=read(); l=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); sort(a+<span class="dv">1</span>,a+<span class="dv">1</span>+n);</span>
<span id="cb1-22"><a href="#cb1-22"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb1-23"><a href="#cb1-23"></a>        <span class="cf">if</span>(a[i]&lt;l)<span class="cf">continue</span>; <span class="dt">int</span> c=(a[i]-l)/d,e=find(c); <span class="cf">if</span>(e==-<span class="dv">1</span>)<span class="cf">continue</span>;<span class="cf">else</span> b[e]++,ans++;</span>
<span id="cb1-24"><a href="#cb1-24"></a>    }</span>
<span id="cb1-25"><a href="#cb1-25"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-26"><a href="#cb1-26"></a>}</span></code></pre></div>
<h3 id="bzoj1616usaco2008-marcow-travelling游荡的奶牛2016.8.2">bzoj1616[Usaco2008 Mar]Cow Travelling游荡的奶牛*（2016.8.2）</h3>
<h4 id="题意-1">题意</h4>
<p>n行m列的草地上有一些位置有障碍物。第0时刻奶牛在(r1,c1)，第t时刻奶牛在(r2,c2)（注意这里都是行在前，列在后），求奶牛走的方案数。n，m≤100，t≤15。</p>
<h4 id="题解-1">题解</h4>
<p>dp。f[i][j][k]表示当前为第i时刻，在j行k列，则f[i][j][k]=f[i+1][j-1][k]+f[i+1][j+1][k]+f[i+1][j][k-1]+f[i+1][j][k+1]，前提是这些位置不出边界且不为障碍物。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="dt">int</span> n,m,t,x[maxn][maxn],y[maxn][maxn],x1,y1,x2,y2; <span class="dt">char</span> map[maxn][maxn];</span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="dt">int</span> main(){</span>
<span id="cb2-11"><a href="#cb2-11"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m,&amp;t); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,map[i]+<span class="dv">1</span>); scanf(<span class="st">&quot;</span><span class="sc">%d%d%d%d</span><span class="st">&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2); x[x2][y2]=<span class="dv">1</span>;</span>
<span id="cb2-12"><a href="#cb2-12"></a>    dec(i,t,<span class="dv">1</span>){</span>
<span id="cb2-13"><a href="#cb2-13"></a>        memset(y,<span class="dv">0</span>,<span class="kw">sizeof</span>(y));</span>
<span id="cb2-14"><a href="#cb2-14"></a>        inc(j,<span class="dv">1</span>,n)inc(k,<span class="dv">1</span>,m){</span>
<span id="cb2-15"><a href="#cb2-15"></a>            <span class="cf">if</span>(j+<span class="dv">1</span>&lt;=n&amp;&amp;map[j+<span class="dv">1</span>][k]!=<span class="ch">&#39;*&#39;</span>)y[j][k]+=x[j+<span class="dv">1</span>][k];</span>
<span id="cb2-16"><a href="#cb2-16"></a>            <span class="cf">if</span>(j-<span class="dv">1</span>&gt;=<span class="dv">1</span>&amp;&amp;map[j-<span class="dv">1</span>][k]!=<span class="ch">&#39;*&#39;</span>)y[j][k]+=x[j-<span class="dv">1</span>][k];</span>
<span id="cb2-17"><a href="#cb2-17"></a>            <span class="cf">if</span>(k+<span class="dv">1</span>&lt;=m&amp;&amp;map[j][k+<span class="dv">1</span>]!=<span class="ch">&#39;*&#39;</span>)y[j][k]+=x[j][k+<span class="dv">1</span>];</span>
<span id="cb2-18"><a href="#cb2-18"></a>            <span class="cf">if</span>(k-<span class="dv">1</span>&gt;=<span class="dv">1</span>&amp;&amp;map[j][k-<span class="dv">1</span>]!=<span class="ch">&#39;*&#39;</span>)y[j][k]+=x[j][k-<span class="dv">1</span>];</span>
<span id="cb2-19"><a href="#cb2-19"></a>        }</span>
<span id="cb2-20"><a href="#cb2-20"></a>        swap(x,y);</span>
<span id="cb2-21"><a href="#cb2-21"></a>    }</span>
<span id="cb2-22"><a href="#cb2-22"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,x[x1][y1]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-23"><a href="#cb2-23"></a>}</span></code></pre></div>
<h3 id="bzoj1642usaco2007-novmilking-time-挤奶时间2016.8.2">bzoj1642[Usaco2007 Nov]Milking Time 挤奶时间*（2016.8.2）</h3>
<h4 id="题意-2">题意</h4>
<p>m个挤奶时间段，每个时间段有一个产奶量，每次产完奶奶牛要休息r分钟，问最多产多少奶。m≤1000，时间≤1000000。</p>
<h4 id="题解-2">题解</h4>
<p>类似bzoj1664，方程改为f[i]=max(f[i+1],f[range[j].r+range[j].value],j为时刻i开始的产奶时间段)。然而本弱的写法时间和空间复杂度都排倒数，神犇们都是用背包dp的写法（我不会）QAQ</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb3-13"><a href="#cb3-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb3-14"><a href="#cb3-14"></a>}</span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="kw">struct</span> rg{<span class="dt">int</span> r; ll w; <span class="dt">int</span> n;}; rg rgs[maxn]; ll f[maxn*<span class="dv">2000</span>]; <span class="dt">int</span> n,m,r,g[maxn*<span class="dv">1000</span>],mx;</span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="dt">int</span> main(){</span>
<span id="cb3-17"><a href="#cb3-17"></a>    n=read(); m=read(); r=read();</span>
<span id="cb3-18"><a href="#cb3-18"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(),c=read(); rgs[i]=(rg){b,c,g[a]}; g[a]=i; mx=max(mx,a);}</span>
<span id="cb3-19"><a href="#cb3-19"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=mx;i&gt;=<span class="dv">0</span>;i--){</span>
<span id="cb3-20"><a href="#cb3-20"></a>        f[i]=f[i+<span class="dv">1</span>]; <span class="cf">for</span>(<span class="dt">int</span> j=g[i];j;j=rgs[j].n)f[i]=max(f[i],f[rgs[j].r+r]+rgs[j].w);</span>
<span id="cb3-21"><a href="#cb3-21"></a>    }</span>
<span id="cb3-22"><a href="#cb3-22"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f[<span class="dv">0</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-23"><a href="#cb3-23"></a>}</span></code></pre></div>
<h3 id="bzoj1646usaco2007-opencatch-that-cow-抓住那只牛2016.8.2">bzoj1646[Usaco2007 Open]Catch That Cow 抓住那只牛*（2016.8.2）</h3>
<h4 id="题意-3">题意</h4>
<p>数轴上，起点在n，终点在k，每次走可以向左走一步或向右走一步或瞬移到当前坐标的两倍位置，问最少走几次。0≤n，k≤100000。</p>
<h4 id="题解-3">题解</h4>
<p>bfs，允许走的位置边界为[0,max(n,k)+1]。下界为0原因是如果走到小于0的位置，k≥0，则瞬移和往左走都是南辕北辙，只能向右走，那么一开始就不应该走到小于0的位置导致浪费时间。上界为max(n,k)+1的原因是如果你走到了大于这个数的位置，k必定小于当前位置，则你必须一步一步的往回走，而这样做显然比之前就别走到这个位置花更多时间……（我承认我乱扯一通）所以复杂度为100000。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="pp">#define maxn </span><span class="dv">100100</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>queue &lt;<span class="dt">int</span>&gt; q; <span class="dt">int</span> tim[maxn],n,k,mx;</span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="dt">int</span> main(){</span>
<span id="cb4-11"><a href="#cb4-11"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k); memset(tim,-<span class="dv">1</span>,<span class="kw">sizeof</span>(tim)); q.push(n); tim[n]=<span class="dv">0</span>; mx=max(n,k)+<span class="dv">1</span>;</span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb4-13"><a href="#cb4-13"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb4-14"><a href="#cb4-14"></a>        <span class="cf">if</span>(x+<span class="dv">1</span>&lt;=mx&amp;&amp;tim[x+<span class="dv">1</span>]==-<span class="dv">1</span>){q.push(x+<span class="dv">1</span>); tim[x+<span class="dv">1</span>]=tim[x]+<span class="dv">1</span>; <span class="cf">if</span>(x+<span class="dv">1</span>==k)<span class="cf">break</span>;}</span>
<span id="cb4-15"><a href="#cb4-15"></a>        <span class="cf">if</span>(x-<span class="dv">1</span>&gt;=<span class="dv">0</span>&amp;&amp;tim[x-<span class="dv">1</span>]==-<span class="dv">1</span>){q.push(x-<span class="dv">1</span>); tim[x-<span class="dv">1</span>]=tim[x]+<span class="dv">1</span>; <span class="cf">if</span>(x-<span class="dv">1</span>==k)<span class="cf">break</span>;}</span>
<span id="cb4-16"><a href="#cb4-16"></a>        <span class="cf">if</span>(x&lt;&lt;<span class="dv">1</span>&lt;=mx&amp;&amp;tim[x&lt;&lt;<span class="dv">1</span>]==-<span class="dv">1</span>){q.push(x&lt;&lt;<span class="dv">1</span>),tim[x&lt;&lt;<span class="dv">1</span>]=tim[x]+<span class="dv">1</span>; <span class="cf">if</span>(x&lt;&lt;<span class="dv">1</span>==k)<span class="cf">break</span>;}</span>
<span id="cb4-17"><a href="#cb4-17"></a>    }</span>
<span id="cb4-18"><a href="#cb4-18"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,tim[k]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb4-19"><a href="#cb4-19"></a>}</span></code></pre></div>
<h3 id="bzoj3767ab-problem加强版2016.8.28">bzoj3767A+B Problem加强版（2016.8.28）</h3>
<h4 id="题意-4">题意</h4>
<p>求两个数的和，每个数绝对值≤10<sup>(10</sup>7)。</p>
<h4 id="题解-4">题解</h4>
<p>又用Python水过了……</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1"></a>a<span class="op">=</span><span class="bu">raw_input</span>()</span>
<span id="cb5-2"><a href="#cb5-2"></a>b<span class="op">=</span>a.split()</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="bu">print</span> <span class="bu">int</span>(b[<span class="dv">0</span>])<span class="op">+</span><span class="bu">int</span>(b[<span class="dv">1</span>])</span></code></pre></div>
<h3 id="bzoj1631usaco2007-febcow-party2016.8.3">bzoj1631[Usaco2007 Feb]Cow Party*（2016.8.3）</h3>
<h4 id="题意-5">题意</h4>
<p>给一个带权有向图，和一个源点，求往返源点最短距离最长的点往返源点的最短距离。</p>
<h4 id="题解-5">题解</h4>
<p>正插边做spfa，倒着插边再做一次spfa。两次最短路之和最大值为所求。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="pp">#define INF </span><span class="bn">0x3ffffff</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb6-15"><a href="#cb6-15"></a>}</span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; e es[maxn*<span class="dv">100</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess;}</span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="dt">int</span> d[maxn],sm[maxn],f[maxn*<span class="dv">100</span>],t[maxn*<span class="dv">100</span>],w[maxn*<span class="dv">100</span>],n,m,s; <span class="dt">bool</span> inq[maxn];</span>
<span id="cb6-19"><a href="#cb6-19"></a>queue &lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="dt">void</span> spfa(){</span>
<span id="cb6-21"><a href="#cb6-21"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); inc(i,<span class="dv">1</span>,n)d[i]=INF;</span>
<span id="cb6-22"><a href="#cb6-22"></a>    q.push(s); inq[s]=<span class="dv">1</span>; d[s]=<span class="dv">0</span>;</span>
<span id="cb6-23"><a href="#cb6-23"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb6-24"><a href="#cb6-24"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb6-25"><a href="#cb6-25"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[x]+es[i].w&lt;d[es[i].t]){</span>
<span id="cb6-26"><a href="#cb6-26"></a>            d[es[i].t]=d[x]+es[i].w;</span>
<span id="cb6-27"><a href="#cb6-27"></a>            <span class="cf">if</span>(!inq[es[i].t])inq[es[i].t]=<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb6-28"><a href="#cb6-28"></a>        }</span>
<span id="cb6-29"><a href="#cb6-29"></a>    }</span>
<span id="cb6-30"><a href="#cb6-30"></a>}</span>
<span id="cb6-31"><a href="#cb6-31"></a><span class="dt">int</span> main(){</span>
<span id="cb6-32"><a href="#cb6-32"></a>    n=read(); m=read(); s=read(); inc(i,<span class="dv">1</span>,m)f[i]=read(),t[i]=read(),w[i]=read();</span>
<span id="cb6-33"><a href="#cb6-33"></a>    ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g)); inc(i,<span class="dv">1</span>,m)pe(f[i],t[i],w[i]); spfa(); inc(i,<span class="dv">1</span>,n)sm[i]+=d[i];</span>
<span id="cb6-34"><a href="#cb6-34"></a>    ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g)); inc(i,<span class="dv">1</span>,m)pe(t[i],f[i],w[i]); spfa(); inc(i,<span class="dv">1</span>,n)sm[i]+=d[i];</span>
<span id="cb6-35"><a href="#cb6-35"></a>    <span class="dt">int</span> ans=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)ans=max(ans,sm[i]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-36"><a href="#cb6-36"></a>}</span></code></pre></div>
<h3 id="bzoj1681usaco2005-marchecking-an-alibi-不在场的证明2016.8.3">bzoj1681[Usaco2005 Mar]Checking an Alibi 不在场的证明*（2016.8.3）</h3>
<h4 id="题意-6">题意</h4>
<p>给个点集，求无向有权图中点集里的哪些点到点1的距离小于等于M。点集内点数≤100，图中点数≤500，边数≤1000。</p>
<h4 id="题解-6">题解</h4>
<p>spfa。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="pp">#define maxn </span><span class="dv">510</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="pp">#define INF </span><span class="bn">0x3ffffff</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb7-15"><a href="#cb7-15"></a>}</span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; e es[maxn*<span class="dv">4</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){</span>
<span id="cb7-18"><a href="#cb7-18"></a>    es[++ess]=(e){t,w,g[f]}; g[f]=ess; es[++ess]=(e){f,w,g[t]}; g[t]=ess;</span>
<span id="cb7-19"><a href="#cb7-19"></a>}</span>
<span id="cb7-20"><a href="#cb7-20"></a><span class="dt">int</span> d[maxn],f,p,c,m,cow[maxn],tot; <span class="dt">bool</span> inq[maxn];</span>
<span id="cb7-21"><a href="#cb7-21"></a>queue &lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="dt">void</span> spfa(){</span>
<span id="cb7-23"><a href="#cb7-23"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); inc(i,<span class="dv">1</span>,f)d[i]=INF;</span>
<span id="cb7-24"><a href="#cb7-24"></a>    q.push(<span class="dv">1</span>); inq[<span class="dv">1</span>]=<span class="dv">1</span>; d[<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb7-25"><a href="#cb7-25"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb7-26"><a href="#cb7-26"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb7-27"><a href="#cb7-27"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[x]+es[i].w&lt;d[es[i].t]){</span>
<span id="cb7-28"><a href="#cb7-28"></a>            d[es[i].t]=d[x]+es[i].w;</span>
<span id="cb7-29"><a href="#cb7-29"></a>            <span class="cf">if</span>(!inq[es[i].t])inq[es[i].t]=<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb7-30"><a href="#cb7-30"></a>        }</span>
<span id="cb7-31"><a href="#cb7-31"></a>    }</span>
<span id="cb7-32"><a href="#cb7-32"></a>}</span>
<span id="cb7-33"><a href="#cb7-33"></a><span class="dt">int</span> main(){</span>
<span id="cb7-34"><a href="#cb7-34"></a>    f=read(); p=read(); c=read(); m=read(); inc(i,<span class="dv">1</span>,p){<span class="dt">int</span> x=read(),y=read(),z=read(); pe(x,y,z);}</span>
<span id="cb7-35"><a href="#cb7-35"></a>    inc(i,<span class="dv">1</span>,c)cow[i]=read(); spfa(); inc(i,<span class="dv">1</span>,c)<span class="cf">if</span>(d[cow[i]]&lt;=m)tot++; printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,tot);</span>
<span id="cb7-36"><a href="#cb7-36"></a>    inc(i,<span class="dv">1</span>,c)<span class="cf">if</span>(d[cow[i]]&lt;=m)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,i); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-37"><a href="#cb7-37"></a>}</span></code></pre></div>
<h3 id="bzoj1617usaco2008-marriver-crossing渡河问题2016.8.3">bzoj1617[Usaco2008 Mar]River Crossing渡河问题*（2016.8.3）</h3>
<h4 id="题意-7">题意</h4>
<p>一个人和n牛渡河，人载i头牛渡河所需时间为m+sigma(j,1,i)a[j]，人不载牛所需时间为m，到了对岸如果还要载牛必须花时间m把船开回来。问最短时间。n≤2500</p>
<h4 id="题解-7">题解</h4>
<p>dp。f[i][j]=min(f[i+1][j+1]+a[j+1],f[i+1][0]+a[j+1]+m*2)，最后答案为f[1][0]+m。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="pp">#define maxn </span><span class="dv">3000</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb8-14"><a href="#cb8-14"></a>}</span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="dt">int</span> n,m,a[maxn],x[maxn],y[maxn];</span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="dt">int</span> main(){</span>
<span id="cb8-17"><a href="#cb8-17"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)a[i]=read();</span>
<span id="cb8-18"><a href="#cb8-18"></a>    dec(i,n,<span class="dv">1</span>){</span>
<span id="cb8-19"><a href="#cb8-19"></a>        memset(y,<span class="dv">0</span>,<span class="kw">sizeof</span>(y)); inc(j,<span class="dv">0</span>,i)y[j]=min(x[j+<span class="dv">1</span>]+a[j+<span class="dv">1</span>],x[<span class="dv">0</span>]+a[j+<span class="dv">1</span>]+m*<span class="dv">2</span>); swap(x,y);</span>
<span id="cb8-20"><a href="#cb8-20"></a>    }</span>
<span id="cb8-21"><a href="#cb8-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,x[<span class="dv">0</span>]+m); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb8-22"><a href="#cb8-22"></a>}</span></code></pre></div>
<h3 id="bzoj1624usaco2008-open-clear-and-present-danger-寻宝之路2016.8.4">bzoj1624[Usaco2008 Open] Clear And Present Danger 寻宝之路*（2016.8.4）</h3>
<h4 id="题意-8">题意</h4>
<p>求按点1-a1-a2…-an-n走的最短路长度是多少。点数小于等于100。</p>
<h4 id="题解-8">题解</h4>
<p>floyd。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb9-7"><a href="#cb9-7"></a></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb9-9"><a href="#cb9-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb9-12"><a href="#cb9-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb9-13"><a href="#cb9-13"></a>}</span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="dt">int</span> map[maxn][maxn],a[maxn*<span class="dv">100</span>],n,m,ans;</span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="dt">int</span> main(){</span>
<span id="cb9-16"><a href="#cb9-16"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m)a[i]=read(); inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n)map[i][j]=read();</span>
<span id="cb9-17"><a href="#cb9-17"></a>    inc(k,<span class="dv">1</span>,n)inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n)<span class="cf">if</span>(map[i][k]+map[k][j]&lt;map[i][j])map[i][j]=map[i][k]+map[k][j];</span>
<span id="cb9-18"><a href="#cb9-18"></a>    ans+=map[<span class="dv">1</span>][a[<span class="dv">1</span>]]; inc(i,<span class="dv">2</span>,m)ans+=map[a[i-<span class="dv">1</span>]][a[i]]; ans+=map[a[m]][n]; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb9-19"><a href="#cb9-19"></a>}</span></code></pre></div>
<h3 id="bzoj1660usaco2006-novbad-hair-day-乱发节2016.8.4">bzoj1660[Usaco2006 Nov]Bad Hair Day 乱发节*（2016.8.4）</h3>
<h4 id="题意-9">题意</h4>
<p>给一个序列a，令ci=ai+1到an第一个比ai大的位置j与i的距离。求sigma(i,1,n)ci。</p>
<h4 id="题解-9">题解</h4>
<p>用一个递减的单调栈维护。注意最后答案要开long long。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="pp">#define maxn </span><span class="dv">80100</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb10-8"><a href="#cb10-8"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb10-10"><a href="#cb10-10"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb10-12"><a href="#cb10-12"></a>}</span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="dt">int</span> n,a[maxn],x[maxn],y[maxn],sz; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="dt">int</span> main(){</span>
<span id="cb10-15"><a href="#cb10-15"></a>    n=read(); <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=n;i++)a[i]=read(); x[<span class="dv">0</span>]=<span class="bn">0x3fffffff</span>; y[<span class="dv">0</span>]=n+<span class="dv">1</span>; sz=<span class="dv">0</span>;</span>
<span id="cb10-16"><a href="#cb10-16"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--){<span class="cf">while</span>(a[i]&gt;x[sz])sz--; ans+=(y[sz]-i-<span class="dv">1</span>); x[++sz]=a[i]; y[sz]=i;}</span>
<span id="cb10-17"><a href="#cb10-17"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-18"><a href="#cb10-18"></a>}</span></code></pre></div>
<h3 id="bzoj1677usaco2005-jansumsets-求和2016.8.4">bzoj1677[Usaco2005 Jan]Sumsets 求和*（2016.8.4）</h3>
<h4 id="题意-10">题意</h4>
<p>给出一个N，使用一些2的若干次幂的数相加来求之．问有多少种方法。N≤1000000。</p>
<h4 id="题解-10">题解</h4>
<p>可以写完全背包，然而排名会倒数~正解是一个递推式：</p>
<p>f[i]=f[i-1]，当i为奇数，f[1]=1</p>
<p>f[i]=f[i-1]+f[i/2]，当i为偶数</p>
<p>神犇们的证明我没看懂QAQ。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="pp">#define maxn </span><span class="dv">1000001</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="pp">#define mod </span><span class="dv">1000000000</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="dt">int</span> n,f[maxn];</span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="dt">int</span> main(){</span>
<span id="cb11-11"><a href="#cb11-11"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); f[<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb11-12"><a href="#cb11-12"></a>    inc(i,<span class="dv">2</span>,n){f[i]=f[i-<span class="dv">1</span>]; <span class="cf">if</span>(!(i&amp;<span class="dv">1</span>))f[i]=(f[i]+f[i&gt;&gt;<span class="dv">1</span>])%mod;}</span>
<span id="cb11-13"><a href="#cb11-13"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[n]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-14"><a href="#cb11-14"></a>}</span></code></pre></div>
<h3 id="bzoj3670noi2014动物园2016.8.6">bzoj3670[Noi2014]动物园（2016.8.6）</h3>
<h4 id="题意-11">题意</h4>
<p>对于字符串S的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作num[i]。给出字符串S求所有num[i]+1的乘积模1000000007。字符串长度≤1000000</p>
<h4 id="题解-11">题解</h4>
<p>先求一遍fail函数，得到数组记为next1，然后再求next2数组，表示满足next1[j]*2≤i的next1[j]，这一过程也是可以递推的。同时用cnt数组记录next1[j]有多少个。num[i]就是cnt[next2[i]]。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="pp">#define maxn </span><span class="dv">1000100</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="pp">#define mod </span><span class="dv">1000000007</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="dt">char</span> s[maxn]; <span class="dt">int</span> next1[maxn],next2[maxn],cnt[maxn],t,len; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="dt">int</span> main(){</span>
<span id="cb12-11"><a href="#cb12-11"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;t);</span>
<span id="cb12-12"><a href="#cb12-12"></a>    <span class="cf">while</span>(t--){</span>
<span id="cb12-13"><a href="#cb12-13"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>); len=strlen(s+<span class="dv">1</span>); next1[<span class="dv">1</span>]=<span class="dv">0</span>; cnt[<span class="dv">1</span>]=<span class="dv">1</span>; next2[<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb12-14"><a href="#cb12-14"></a>        inc(i,<span class="dv">2</span>,len){</span>
<span id="cb12-15"><a href="#cb12-15"></a>            <span class="dt">int</span> j=next1[i-<span class="dv">1</span>]; <span class="cf">while</span>(j&amp;&amp;s[j+<span class="dv">1</span>]!=s[i])j=next1[j];</span>
<span id="cb12-16"><a href="#cb12-16"></a>            <span class="cf">if</span>(s[j+<span class="dv">1</span>]==s[i])next1[i]=j+<span class="dv">1</span>,cnt[i]=cnt[next1[i]]+<span class="dv">1</span>;<span class="cf">else</span> next1[i]=<span class="dv">0</span>,cnt[i]=<span class="dv">1</span>;</span>
<span id="cb12-17"><a href="#cb12-17"></a>        }</span>
<span id="cb12-18"><a href="#cb12-18"></a>        inc(i,<span class="dv">2</span>,len){</span>
<span id="cb12-19"><a href="#cb12-19"></a>            <span class="dt">int</span> j=next2[i-<span class="dv">1</span>]; <span class="cf">if</span>(j*<span class="dv">2</span>+<span class="dv">2</span>&gt;i)j=next1[j]; <span class="cf">while</span>(j&amp;&amp;s[j+<span class="dv">1</span>]!=s[i])j=next1[j];</span>
<span id="cb12-20"><a href="#cb12-20"></a>            <span class="cf">if</span>(s[j+<span class="dv">1</span>]==s[i])next2[i]=j+<span class="dv">1</span>;<span class="cf">else</span> next2[i]=<span class="dv">0</span>;</span>
<span id="cb12-21"><a href="#cb12-21"></a>        }</span>
<span id="cb12-22"><a href="#cb12-22"></a>        ans=<span class="dv">1</span>; inc(i,<span class="dv">1</span>,len)ans=ans*(cnt[next2[i]]+<span class="dv">1</span>)%mod; printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb12-23"><a href="#cb12-23"></a>    }</span>
<span id="cb12-24"><a href="#cb12-24"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb12-25"><a href="#cb12-25"></a>}</span></code></pre></div>
<h3 id="bzoj1673usaco2005-decscales-天平2016.8.6">bzoj1673[Usaco2005 Dec]Scales 天平*（2016.8.6）</h3>
<h4 id="题意-12">题意</h4>
<p>n个砝码，每个砝码重量大于前两个砝码质量和，天平承重为c，求天平上最多可放多种的砝码。n≤1000，c≤2^30。</p>
<h4 id="题解-12">题解</h4>
<p>斐波那契数列到30多项就爆int了，所以本题n其实≤30。故爆搜即可，加个剪枝：当前选的砝码质量和+剩下砝码质量和仍≤ans就返回。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb13-9"><a href="#cb13-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb13-10"><a href="#cb13-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb13-12"><a href="#cb13-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb13-13"><a href="#cb13-13"></a>}</span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="dt">int</span> n,a[maxn],c,ans; <span class="dt">long</span> <span class="dt">long</span> sm[maxn];</span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="cf">if</span>(sm[x]+y&lt;=ans)<span class="cf">return</span>; ans=max(ans,y); <span class="cf">for</span>(<span class="dt">int</span> i=x;i&gt;=<span class="dv">1</span>;i--)<span class="cf">if</span>(y+a[i]&lt;=c)dfs(i-<span class="dv">1</span>,y+a[i]);</span>
<span id="cb13-17"><a href="#cb13-17"></a>}</span>
<span id="cb13-18"><a href="#cb13-18"></a><span class="dt">int</span> main(){</span>
<span id="cb13-19"><a href="#cb13-19"></a>    n=read(); c=read();</span>
<span id="cb13-20"><a href="#cb13-20"></a>    inc(i,<span class="dv">1</span>,n)a[i]=read(),sm[i]=sm[i-<span class="dv">1</span>]+a[i]; <span class="cf">while</span>(a[n]&gt;c)n--; dfs(n,<span class="dv">0</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);</span>
<span id="cb13-21"><a href="#cb13-21"></a>}</span></code></pre></div>
<h3 id="bzoj1657usaco2006-marmooo-奶牛的歌声2016.8.8">bzoj1657[Usaco2006 Mar]Mooo 奶牛的歌声*（2016.8.8）</h3>
<h4 id="题意-13">题意</h4>
<p>n头奶牛，每头一个身高和音量。每头牛的音量会被左边离它最近的比它高的和右边离它最近的比它高的牛听到。问牛听到的最大音量。n≤50000</p>
<h4 id="题解-13">题解</h4>
<p>单调栈维护牛的身高递减。左右各做一次，累加求解。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="pp">#define maxn </span><span class="dv">50100</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="dt">int</span> s1[maxn],s2[maxn],h[maxn],vol[maxn],ss,n,ans[maxn];</span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb14-12"><a href="#cb14-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb14-13"><a href="#cb14-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb14-14"><a href="#cb14-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb14-15"><a href="#cb14-15"></a>}</span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="dt">int</span> main(){</span>
<span id="cb14-17"><a href="#cb14-17"></a>    n=read(); inc(i,<span class="dv">1</span>,n)h[i]=read(),vol[i]=read();</span>
<span id="cb14-18"><a href="#cb14-18"></a>    s1[<span class="dv">1</span>]=h[<span class="dv">1</span>]; s2[<span class="dv">1</span>]=<span class="dv">1</span>; ss=<span class="dv">1</span>;</span>
<span id="cb14-19"><a href="#cb14-19"></a>    inc(i,<span class="dv">2</span>,n){<span class="cf">while</span>(ss&amp;&amp;s1[ss]&lt;h[i])ss--; <span class="cf">if</span>(ss)ans[s2[ss]]+=vol[i]; s1[++ss]=h[i]; s2[ss]=i;}</span>
<span id="cb14-20"><a href="#cb14-20"></a>    s1[<span class="dv">1</span>]=h[n]; s2[<span class="dv">1</span>]=n; ss=<span class="dv">1</span>;</span>
<span id="cb14-21"><a href="#cb14-21"></a>    dec(i,n-<span class="dv">1</span>,<span class="dv">1</span>){<span class="cf">while</span>(ss&amp;&amp;s1[ss]&lt;h[i])ss--; <span class="cf">if</span>(ss)ans[s2[ss]]+=vol[i]; s1[++ss]=h[i]; s2[ss]=i;}</span>
<span id="cb14-22"><a href="#cb14-22"></a>    inc(i,<span class="dv">1</span>,n)ans[<span class="dv">0</span>]=max(ans[<span class="dv">0</span>],ans[i]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans[<span class="dv">0</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-23"><a href="#cb14-23"></a>}</span></code></pre></div>
<h3 id="bzoj1638usaco2007-marcow-traffic-奶牛交通2016.8.8">bzoj1638[Usaco2007 Mar]Cow Traffic 奶牛交通*（2016.8.8）</h3>
<h4 id="题意-14">题意</h4>
<p>N点M边有向图，每个入度为0的点都有无限只奶牛，现在它们要回宿舍（点1），求通过量最大的路的通过量。N≤5000，M≤50000</p>
<h4 id="题解-14">题解</h4>
<p>一条路的通过量=到达节点到入度为0节点的方案数*点1到出发节点的方案数（其实我也不知道为什么，这题意完全是模糊的），2次dfs就行了。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="pp">#define maxn </span><span class="dv">5010</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb15-8"><a href="#cb15-8"></a></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb15-11"><a href="#cb15-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb15-13"><a href="#cb15-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb15-14"><a href="#cb15-14"></a>}</span>
<span id="cb15-15"><a href="#cb15-15"></a><span class="dt">int</span> f1[maxn],f2[maxn],n,m,f[maxn*<span class="dv">10</span>],t[maxn*<span class="dv">10</span>];</span>
<span id="cb15-16"><a href="#cb15-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn*<span class="dv">10</span>]; <span class="dt">int</span> g[maxn];</span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="dt">int</span> dfs1(<span class="dt">int</span> x){</span>
<span id="cb15-18"><a href="#cb15-18"></a>    <span class="cf">if</span>(f1[x])<span class="cf">return</span> f1[x];</span>
<span id="cb15-19"><a href="#cb15-19"></a>    <span class="cf">if</span>(!g[x])f1[x]=<span class="dv">1</span>;<span class="cf">else</span>{</span>
<span id="cb15-20"><a href="#cb15-20"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n){f1[x]+=dfs1(es[i].t);}</span>
<span id="cb15-21"><a href="#cb15-21"></a>    }</span>
<span id="cb15-22"><a href="#cb15-22"></a>    <span class="cf">return</span> f1[x];</span>
<span id="cb15-23"><a href="#cb15-23"></a>}</span>
<span id="cb15-24"><a href="#cb15-24"></a><span class="dt">int</span> dfs2(<span class="dt">int</span> x){</span>
<span id="cb15-25"><a href="#cb15-25"></a>    <span class="cf">if</span>(f2[x])<span class="cf">return</span> f2[x];</span>
<span id="cb15-26"><a href="#cb15-26"></a>    <span class="cf">if</span>(!g[x])f2[x]=<span class="dv">1</span>;<span class="cf">else</span>{</span>
<span id="cb15-27"><a href="#cb15-27"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n){f2[x]+=dfs2(es[i].t);}</span>
<span id="cb15-28"><a href="#cb15-28"></a>    }</span>
<span id="cb15-29"><a href="#cb15-29"></a>    <span class="cf">return</span> f2[x];</span>
<span id="cb15-30"><a href="#cb15-30"></a>}</span>
<span id="cb15-31"><a href="#cb15-31"></a><span class="dt">int</span> main(){</span>
<span id="cb15-32"><a href="#cb15-32"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m)f[i]=read(),t[i]=read();</span>
<span id="cb15-33"><a href="#cb15-33"></a>    memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g)); inc(i,<span class="dv">1</span>,m)es[i]=(e){f[i],g[t[i]]},g[t[i]]=i; dfs1(n);</span>
<span id="cb15-34"><a href="#cb15-34"></a>    memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g)); inc(i,<span class="dv">1</span>,m)es[i]=(e){t[i],g[f[i]]},g[f[i]]=i; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!f2[i])dfs2(i);</span>
<span id="cb15-35"><a href="#cb15-35"></a>    inc(i,<span class="dv">1</span>,m)f1[<span class="dv">0</span>]=max(f1[<span class="dv">0</span>],f1[f[i]]*f2[t[i]]);</span>
<span id="cb15-36"><a href="#cb15-36"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f1[<span class="dv">0</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-37"><a href="#cb15-37"></a>}</span></code></pre></div>
<h3 id="bzoj1680usaco2005-maryogurt-factorybzoj1740usaco2005-maryogurt-factory-奶酪工厂2016.8.8">bzoj1680[Usaco2005 Mar]Yogurt factory*&amp;bzoj1740[Usaco2005 mar]Yogurt factory 奶酪工厂*（2016.8.8）</h3>
<h4 id="题意-15">题意</h4>
<p>n个月，每月有一个酸奶需求量（吨）和酸奶成本（元每吨）。酸奶可以保存，费用为S（元每月每吨），求最小总费用。n≤10000</p>
<h4 id="题解-15">题解</h4>
<p>第i月每吨酸奶的成本为Cj+s*(i-j),j∈[1,i]，化简得Cj-s*j+s*i，因为s*i只和当前相关，所以维护一个最小的Cj-s*j即可。注意开long long。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb16-6"><a href="#cb16-6"></a></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb16-12"><a href="#cb16-12"></a>}</span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="dt">int</span> n,s,mn; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="dt">int</span> main(){</span>
<span id="cb16-15"><a href="#cb16-15"></a>    n=read(); s=read();</span>
<span id="cb16-16"><a href="#cb16-16"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb16-17"><a href="#cb16-17"></a>        <span class="dt">int</span> a=read(),b=read(); <span class="cf">if</span>(i==<span class="dv">1</span>)mn=a-s*i;<span class="cf">else</span> mn=min(mn,a-s*i); ans+=(mn+s*i)*b;</span>
<span id="cb16-18"><a href="#cb16-18"></a>    }</span>
<span id="cb16-19"><a href="#cb16-19"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb16-20"><a href="#cb16-20"></a>}</span></code></pre></div>
<h3 id="bzoj1699usaco2007-janbalanced-lineup排队bzoj1636usaco2007-janbalanced-lineup2016.8.8">bzoj1699[Usaco2007 Jan]Balanced Lineup排队*&amp;bzoj1636[Usaco2007 Jan]Balanced Lineup*（2016.8.8）</h3>
<h4 id="题意-16">题意</h4>
<p>询问区间最大值减区间最小值的差。序列大小≤50000</p>
<h4 id="题解-16">题解</h4>
<p>RMQ问题。注意log2区间长度可先递推好，这样可以保证询问O(1)。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="pp">#define maxn </span><span class="dv">50100</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb17-13"><a href="#cb17-13"></a>}</span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="dt">int</span> n,m,a[maxn],lg[maxn],mx[maxn][<span class="dv">20</span>],mn[maxn][<span class="dv">20</span>];</span>
<span id="cb17-15"><a href="#cb17-15"></a><span class="dt">int</span> main(){</span>
<span id="cb17-16"><a href="#cb17-16"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)a[i]=read();</span>
<span id="cb17-17"><a href="#cb17-17"></a>    inc(i,<span class="dv">1</span>,n)mx[i][<span class="dv">0</span>]=a[i],mn[i][<span class="dv">0</span>]=a[i];</span>
<span id="cb17-18"><a href="#cb17-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;<span class="dv">1</span>&lt;&lt;i&lt;=n;i++)lg[<span class="dv">1</span>&lt;&lt;i]=i; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!lg[i])lg[i]=lg[i-<span class="dv">1</span>];</span>
<span id="cb17-19"><a href="#cb17-19"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;<span class="dv">1</span>&lt;&lt;i&lt;=n;i++)inc(j,<span class="dv">1</span>,n)<span class="cf">if</span>(j+(<span class="dv">1</span>&lt;&lt;i)-<span class="dv">1</span>&lt;=n)</span>
<span id="cb17-20"><a href="#cb17-20"></a>        mx[j][i]=max(mx[j][i-<span class="dv">1</span>],mx[j+(<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>))][i-<span class="dv">1</span>]),mn[j][i]=min(mn[j][i-<span class="dv">1</span>],mn[j+(<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>))][i-<span class="dv">1</span>]);</span>
<span id="cb17-21"><a href="#cb17-21"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb17-22"><a href="#cb17-22"></a>        <span class="dt">int</span> a=read(),b=read(),c=lg[b-a+<span class="dv">1</span>];</span>
<span id="cb17-23"><a href="#cb17-23"></a>        printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,max(mx[a][c],mx[b-(<span class="dv">1</span>&lt;&lt;c)+<span class="dv">1</span>][c])-min(mn[a][c],mn[b-(<span class="dv">1</span>&lt;&lt;c)+<span class="dv">1</span>][c]));</span>
<span id="cb17-24"><a href="#cb17-24"></a>    }</span>
<span id="cb17-25"><a href="#cb17-25"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb17-26"><a href="#cb17-26"></a>}</span></code></pre></div>
<h3 id="bzoj1634usaco2007-janprotecting-the-flowers-护花2016.8.8">bzoj1634[Usaco2007 Jan]Protecting the Flowers 护花*（2016.8.8）</h3>
<h4 id="题意-17">题意</h4>
<p>n只牛在啃花，第i只每分钟啃ai朵，赶走它需要2*bi分钟，问最少会被啃掉多少朵。n≤100000</p>
<h4 id="题解-17">题解</h4>
<p>贪心。只考虑第i只牛与第j只牛孰先孰后，如果第i只牛先会多啃掉2<em>bi</em>aj朵，第j只牛先会被啃掉2<em>ai</em>bj朵，因此按这个排序就行了。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb18-7"><a href="#cb18-7"></a></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb18-9"><a href="#cb18-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb18-10"><a href="#cb18-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb18-12"><a href="#cb18-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb18-13"><a href="#cb18-13"></a>}</span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="kw">struct</span> nd{<span class="dt">int</span> t,d,id;}; nd nds[maxn]; <span class="dt">int</span> n,sm; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="dt">bool</span> cmp(nd a,nd b){<span class="cf">return</span> a.t*b.d&lt;b.t*a.d;}</span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="dt">int</span> main(){</span>
<span id="cb18-17"><a href="#cb18-17"></a>    n=read(); inc(i,<span class="dv">1</span>,n)nds[i].t=read(),nds[i].d=read(),nds[i].id=i; sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+n,cmp);</span>
<span id="cb18-18"><a href="#cb18-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--)ans+=sm*nds[i].t*<span class="dv">2</span>,sm+=nds[i].d;</span>
<span id="cb18-19"><a href="#cb18-19"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-20"><a href="#cb18-20"></a>}</span></code></pre></div>
<h3 id="bzoj1669usaco2006-octhungry-cows饥饿的奶牛2016.8.8">bzoj1669[Usaco2006 Oct]Hungry Cows饥饿的奶牛*（2016.8.8）</h3>
<h4 id="题意-18">题意</h4>
<p>求最长单调递增子序列，序列大小≤5000</p>
<h4 id="题解-18">题解</h4>
<p>蒟蒻弱写了一个O(n^2)的。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="pp">#define maxn </span><span class="dv">5100</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb19-7"><a href="#cb19-7"></a></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb19-9"><a href="#cb19-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb19-10"><a href="#cb19-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb19-11"><a href="#cb19-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb19-12"><a href="#cb19-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb19-13"><a href="#cb19-13"></a>}</span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="dt">int</span> a[maxn],f[maxn],n;</span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="dt">int</span> main(){</span>
<span id="cb19-16"><a href="#cb19-16"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read();</span>
<span id="cb19-17"><a href="#cb19-17"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb19-18"><a href="#cb19-18"></a>        f[i]=<span class="dv">1</span>; inc(j,<span class="dv">1</span>,i-<span class="dv">1</span>)<span class="cf">if</span>(a[j]&lt;a[i])f[i]=max(f[i],f[j]+<span class="dv">1</span>);</span>
<span id="cb19-19"><a href="#cb19-19"></a>    }</span>
<span id="cb19-20"><a href="#cb19-20"></a>    inc(i,<span class="dv">1</span>,n)f[<span class="dv">0</span>]=max(f[<span class="dv">0</span>],f[i]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[<span class="dv">0</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb19-21"><a href="#cb19-21"></a>}</span></code></pre></div>
<h3 id="bzoj1641usaco2007-novcow-hurdles-奶牛跨栏2016.8.8">bzoj1641[Usaco2007 Nov]Cow Hurdles 奶牛跨栏*（2016.8.8）</h3>
<h4 id="题意-19">题意</h4>
<p>n点m边有向图，每次给出询问x，y求x到y路径中最大边权的最小值是多少。n≤500</p>
<h4 id="题解-19">题解</h4>
<p>floyd变形。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#define maxn </span><span class="dv">310</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb20-10"><a href="#cb20-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb20-11"><a href="#cb20-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb20-12"><a href="#cb20-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb20-13"><a href="#cb20-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb20-14"><a href="#cb20-14"></a>}</span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="dt">int</span> n,m,t,g[maxn][maxn];</span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="dt">int</span> main(){</span>
<span id="cb20-17"><a href="#cb20-17"></a>    n=read(); m=read(); t=read(); inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n)g[i][j]=INF;</span>
<span id="cb20-18"><a href="#cb20-18"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(); g[a][b]=read();}</span>
<span id="cb20-19"><a href="#cb20-19"></a>    inc(k,<span class="dv">1</span>,n)inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n)g[i][j]=min(g[i][j],max(g[i][k],g[k][j]));</span>
<span id="cb20-20"><a href="#cb20-20"></a>    inc(i,<span class="dv">1</span>,t){<span class="dt">int</span> a=read(),b=read(); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,g[a][b]==INF?-<span class="dv">1</span>:g[a][b]);}</span>
<span id="cb20-21"><a href="#cb20-21"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb20-22"><a href="#cb20-22"></a>}</span></code></pre></div>
<h3 id="bzoj1696usaco2007-febbuilding-a-new-barn新牛舍2016.8.9">bzoj1696[Usaco2007 Feb]Building A New Barn新牛舍*（2016.8.9）</h3>
<h4 id="题意-20">题意</h4>
<p>n头牛在不同坐标处吃草，没有牛相邻。求一个没有牛的点到所有点曼哈顿距离和最小和这样点的个数。n≤10000</p>
<h4 id="题解-20">题解</h4>
<p>先求x坐标的中位数区间，再求y坐标的中位数区间，如果n为偶数，答案为这个二维区间点数-落在这个区间里的牛数。n为奇数，且这个中位数点有牛的话，就在这个点的上下左右调整，然后找距离和最小的点和这样点的个数。情况比较多，容易WA。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="pp">#define maxn </span><span class="dv">10100</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb21-7"><a href="#cb21-7"></a></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb21-9"><a href="#cb21-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb21-11"><a href="#cb21-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb21-12"><a href="#cb21-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb21-13"><a href="#cb21-13"></a>}</span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="kw">struct</span> p{<span class="dt">int</span> x,y;}; p ps[maxn]; <span class="dt">int</span> lx,rx,ly,ry,n,tot,ans;</span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="dt">bool</span> cmp1(p a,p b){<span class="cf">return</span> a.x&lt;b.x;}</span>
<span id="cb21-16"><a href="#cb21-16"></a><span class="dt">bool</span> cmp2(p a,p b){<span class="cf">return</span> a.y&lt;b.y;}</span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="dt">int</span> main(){</span>
<span id="cb21-18"><a href="#cb21-18"></a>    n=read(); inc(i,<span class="dv">1</span>,n)ps[i].x=read(),ps[i].y=read();</span>
<span id="cb21-19"><a href="#cb21-19"></a>    sort(ps+<span class="dv">1</span>,ps+n+<span class="dv">1</span>,cmp1);</span>
<span id="cb21-20"><a href="#cb21-20"></a>    <span class="cf">if</span>(n&amp;<span class="dv">1</span>)lx=rx=ps[(n&gt;&gt;<span class="dv">1</span>)+<span class="dv">1</span>].x;<span class="cf">else</span> lx=ps[n&gt;&gt;<span class="dv">1</span>].x,rx=ps[(n&gt;&gt;<span class="dv">1</span>)+<span class="dv">1</span>].x;</span>
<span id="cb21-21"><a href="#cb21-21"></a>    sort(ps+<span class="dv">1</span>,ps+n+<span class="dv">1</span>,cmp2);</span>
<span id="cb21-22"><a href="#cb21-22"></a>    <span class="cf">if</span>(n&amp;<span class="dv">1</span>)ly=ry=ps[(n&gt;&gt;<span class="dv">1</span>)+<span class="dv">1</span>].y;<span class="cf">else</span> ly=ps[n&gt;&gt;<span class="dv">1</span>].y,ry=ps[(n&gt;&gt;<span class="dv">1</span>)+<span class="dv">1</span>].y;</span>
<span id="cb21-23"><a href="#cb21-23"></a>    tot=(rx-lx+<span class="dv">1</span>)*(ry-ly+<span class="dv">1</span>); inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(ps[i].x&gt;=lx&amp;&amp;ps[i].x&lt;=rx&amp;&amp;ps[i].y&gt;=ly&amp;&amp;ps[i].y&lt;=ry)tot--;</span>
<span id="cb21-24"><a href="#cb21-24"></a>    <span class="cf">if</span>(!tot){</span>
<span id="cb21-25"><a href="#cb21-25"></a>        <span class="dt">int</span> a[<span class="dv">4</span>]={<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>}; tot=<span class="dv">0</span>; ans=<span class="bn">0x3fffffff</span>;</span>
<span id="cb21-26"><a href="#cb21-26"></a>        lx++; inc(i,<span class="dv">1</span>,n)a[<span class="dv">0</span>]+=abs(lx-ps[i].x)+abs(ly-ps[i].y); ans=min(a[<span class="dv">0</span>],ans); lx--;</span>
<span id="cb21-27"><a href="#cb21-27"></a>        lx--; inc(i,<span class="dv">1</span>,n)a[<span class="dv">1</span>]+=abs(lx-ps[i].x)+abs(ly-ps[i].y); ans=min(a[<span class="dv">1</span>],ans); lx++;</span>
<span id="cb21-28"><a href="#cb21-28"></a>        ly++; inc(i,<span class="dv">1</span>,n)a[<span class="dv">2</span>]+=abs(lx-ps[i].x)+abs(ly-ps[i].y); ans=min(a[<span class="dv">2</span>],ans); ly--;</span>
<span id="cb21-29"><a href="#cb21-29"></a>        ly--; inc(i,<span class="dv">1</span>,n)a[<span class="dv">3</span>]+=abs(lx-ps[i].x)+abs(ly-ps[i].y); ans=min(a[<span class="dv">3</span>],ans); ly++;</span>
<span id="cb21-30"><a href="#cb21-30"></a>        inc(i,<span class="dv">0</span>,<span class="dv">3</span>)<span class="cf">if</span>(ans==a[i])tot++;</span>
<span id="cb21-31"><a href="#cb21-31"></a>    }<span class="cf">else</span>{inc(i,<span class="dv">1</span>,n)ans+=abs(lx-ps[i].x)+abs(ly-ps[i].y);}</span>
<span id="cb21-32"><a href="#cb21-32"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">&quot;</span>,ans,tot); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb21-33"><a href="#cb21-33"></a>}</span></code></pre></div>
<h3 id="bzoj1604usaco2008-opencow-neighborhoods-奶牛的邻居2016.8.9">bzoj1604[Usaco2008 Open]Cow Neighborhoods 奶牛的邻居*（2016.8.9）</h3>
<h4 id="题意-21">题意</h4>
<p>n只牛，牛结成群当且仅当两只牛曼哈顿距离≤c或存在第三头牛使两头牛与它的曼哈顿距离都≤c，求最大的群和群数。n≤100000</p>
<h4 id="题解-21">题解</h4>
<p>好神啊。先把曼哈顿距离转成切比雪夫距离，(x,y)转为(x+y,x-y)。然后按x坐标排序，用两个指针维护使x坐标差值≤c，同时将新插入的y坐标放入set，每次在set里查找出与当前y差值不超过c的最大y，将这两个点合并成一个集合，用并查集维护。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="pp">#define maxn </span><span class="dv">100100</span></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb22-9"><a href="#cb22-9"></a></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb22-12"><a href="#cb22-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb22-13"><a href="#cb22-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb22-14"><a href="#cb22-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb22-15"><a href="#cb22-15"></a>}</span>
<span id="cb22-16"><a href="#cb22-16"></a><span class="kw">struct</span> p{<span class="dt">int</span> x,y;}; p ps[maxn];</span>
<span id="cb22-17"><a href="#cb22-17"></a><span class="dt">bool</span> cmp(p a,p b){<span class="cf">return</span> a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;}</span>
<span id="cb22-18"><a href="#cb22-18"></a><span class="kw">struct</span> data{</span>
<span id="cb22-19"><a href="#cb22-19"></a>    <span class="dt">int</span> id,v;</span>
<span id="cb22-20"><a href="#cb22-20"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> data &amp;a)<span class="at">const</span>{<span class="cf">return</span> v==a.v?id&lt;a.id:v&lt;a.v;}</span>
<span id="cb22-21"><a href="#cb22-21"></a>};</span>
<span id="cb22-22"><a href="#cb22-22"></a>set&lt;data&gt; s; <span class="dt">int</span> n,c,l,fa[maxn],cnt[maxn];</span>
<span id="cb22-23"><a href="#cb22-23"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb22-24"><a href="#cb22-24"></a><span class="dt">void</span> merge(<span class="dt">int</span> _x,<span class="dt">int</span> _y){<span class="dt">int</span> x=find(_x),y=find(_y); <span class="cf">if</span>(x!=y)fa[y]=x;}</span>
<span id="cb22-25"><a href="#cb22-25"></a><span class="dt">int</span> main(){</span>
<span id="cb22-26"><a href="#cb22-26"></a>    n=read(),c=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a=read(),b=read(); ps[i]=(p){a+b,a-b};} sort(ps+<span class="dv">1</span>,ps+<span class="dv">1</span>+n,cmp);</span>
<span id="cb22-27"><a href="#cb22-27"></a>    s.clear(); s.insert((data){<span class="dv">0</span>,INF}); s.insert((data){<span class="dv">0</span>,-INF});</span>
<span id="cb22-28"><a href="#cb22-28"></a>    l=<span class="dv">1</span>; s.insert((data){<span class="dv">1</span>,ps[<span class="dv">1</span>].y}); inc(i,<span class="dv">1</span>,n)fa[i]=i;</span>
<span id="cb22-29"><a href="#cb22-29"></a>    inc(i,<span class="dv">2</span>,n){</span>
<span id="cb22-30"><a href="#cb22-30"></a>        <span class="cf">while</span>(ps[i].x-ps[l].x&gt;c)s.erase(s.find((data){l,ps[l].y})),l++;</span>
<span id="cb22-31"><a href="#cb22-31"></a>        set&lt;data&gt;::iterator x=s.lower_bound((data){<span class="dv">0</span>,ps[i].y}),y=x; y--;</span>
<span id="cb22-32"><a href="#cb22-32"></a>        <span class="cf">if</span>(x-&gt;v-ps[i].y&lt;=c)merge(i,x-&gt;id); <span class="cf">if</span>(ps[i].y-y-&gt;v&lt;=c)merge(i,y-&gt;id);</span>
<span id="cb22-33"><a href="#cb22-33"></a>        s.insert((data){i,ps[i].y});</span>
<span id="cb22-34"><a href="#cb22-34"></a>    }</span>
<span id="cb22-35"><a href="#cb22-35"></a>    inc(i,<span class="dv">1</span>,n)cnt[find(i)]++; <span class="dt">int</span> ans=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(cnt[i])ans++; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>,ans);</span>
<span id="cb22-36"><a href="#cb22-36"></a>    ans=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)ans=max(ans,cnt[i]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb22-37"><a href="#cb22-37"></a>}</span></code></pre></div>
<h3 id="bzoj1711usaco2007-opendining吃饭2016.8.9">bzoj1711[Usaco2007 Open]Dining吃饭*（2016.8.9）</h3>
<h4 id="题意-22">题意</h4>
<p>每头牛都喜欢几种食品和饮料，现在每种食品和饮料都有一个，问最多能使多少头牛同时获得喜欢的食品和饮料。牛数、饮料数、食品数≤500</p>
<h4 id="题解-22">题解</h4>
<p>最大流，源向所有食品连边，食品向被喜欢的牛连边，牛向喜欢的饮料连边，饮料向汇连边，流量都为1。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="pp">#define maxn </span><span class="dv">10000</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb23-9"><a href="#cb23-9"></a></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb23-11"><a href="#cb23-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb23-12"><a href="#cb23-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb23-13"><a href="#cb23-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb23-14"><a href="#cb23-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb23-15"><a href="#cb23-15"></a>}</span>
<span id="cb23-16"><a href="#cb23-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,c,n;}; e es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb23-17"><a href="#cb23-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c){</span>
<span id="cb23-18"><a href="#cb23-18"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,g[t]}; g[t]=ess;</span>
<span id="cb23-19"><a href="#cb23-19"></a>}</span>
<span id="cb23-20"><a href="#cb23-20"></a><span class="dt">void</span> init(){memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g)); ess=-<span class="dv">1</span>;}</span>
<span id="cb23-21"><a href="#cb23-21"></a>queue&lt;<span class="dt">int</span>&gt;q; <span class="dt">int</span> h[maxn];</span>
<span id="cb23-22"><a href="#cb23-22"></a><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb23-23"><a href="#cb23-23"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); h[s]=<span class="dv">0</span>; q.push(s);</span>
<span id="cb23-24"><a href="#cb23-24"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb23-25"><a href="#cb23-25"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb23-26"><a href="#cb23-26"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==-<span class="dv">1</span>)h[es[i].t]=h[x]+<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb23-27"><a href="#cb23-27"></a>    }</span>
<span id="cb23-28"><a href="#cb23-28"></a>    <span class="cf">return</span> h[t]!=-<span class="dv">1</span>;</span>
<span id="cb23-29"><a href="#cb23-29"></a>}</span>
<span id="cb23-30"><a href="#cb23-30"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> t,<span class="dt">int</span> f){</span>
<span id="cb23-31"><a href="#cb23-31"></a>    <span class="cf">if</span>(x==t)<span class="cf">return</span> f; <span class="dt">int</span> u=<span class="dv">0</span>;</span>
<span id="cb23-32"><a href="#cb23-32"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i!=-<span class="dv">1</span>;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==h[x]+<span class="dv">1</span>){</span>
<span id="cb23-33"><a href="#cb23-33"></a>        <span class="dt">int</span> w=dfs(es[i].t,t,min(f,es[i].c)); f-=w; u+=w; es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; <span class="cf">if</span>(!f)<span class="cf">return</span> u;</span>
<span id="cb23-34"><a href="#cb23-34"></a>    }</span>
<span id="cb23-35"><a href="#cb23-35"></a>    <span class="cf">if</span>(!u)h[x]=-<span class="dv">1</span>; <span class="cf">return</span> u;</span>
<span id="cb23-36"><a href="#cb23-36"></a>}</span>
<span id="cb23-37"><a href="#cb23-37"></a><span class="dt">int</span> dinic(<span class="dt">int</span> s,<span class="dt">int</span> t){<span class="dt">int</span> flow=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))flow+=dfs(s,t,INF); <span class="cf">return</span> flow;}</span>
<span id="cb23-38"><a href="#cb23-38"></a><span class="dt">int</span> n,f,d,s,t;</span>
<span id="cb23-39"><a href="#cb23-39"></a><span class="dt">int</span> main(){</span>
<span id="cb23-40"><a href="#cb23-40"></a>    n=read(); f=read(); d=read(); s=<span class="dv">0</span>; t=f+n*<span class="dv">2</span>+d+<span class="dv">1</span>; init();</span>
<span id="cb23-41"><a href="#cb23-41"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb23-42"><a href="#cb23-42"></a>        pe(f+i,f+n+i,<span class="dv">1</span>);</span>
<span id="cb23-43"><a href="#cb23-43"></a>        <span class="dt">int</span> a=read(),b=read();</span>
<span id="cb23-44"><a href="#cb23-44"></a>        inc(j,<span class="dv">1</span>,a){<span class="dt">int</span> c=read(); pe(c,f+i,<span class="dv">1</span>);}</span>
<span id="cb23-45"><a href="#cb23-45"></a>        inc(j,<span class="dv">1</span>,b){<span class="dt">int</span> c=read(); pe(f+n+i,f+n*<span class="dv">2</span>+c,<span class="dv">1</span>);}</span>
<span id="cb23-46"><a href="#cb23-46"></a>    }</span>
<span id="cb23-47"><a href="#cb23-47"></a>    inc(i,<span class="dv">1</span>,f)pe(s,i,<span class="dv">1</span>); inc(i,<span class="dv">1</span>,d)pe(f+n*<span class="dv">2</span>+i,t,<span class="dv">1</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dinic(s,t)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb23-48"><a href="#cb23-48"></a>}</span></code></pre></div>
<h3 id="bzoj3479usaco2014-marwatering-the-fields2016.8.10">bzoj3479[Usaco2014 Mar]Watering the Fields*（2016.8.10）</h3>
<h4 id="题意-23">题意</h4>
<p>草坪上有N个水龙头，修剪两个水管费用为欧几里得距离的平方。 修水管的人只愿意修费用大于等于c的水管，问将水龙头联通的最小总费用。N≤2000</p>
<h4 id="题解-23">题解</h4>
<p>最小生成树。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="pp">#define maxn </span><span class="dv">2010</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb24-7"><a href="#cb24-7"></a></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb24-10"><a href="#cb24-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb24-11"><a href="#cb24-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb24-12"><a href="#cb24-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb24-13"><a href="#cb24-13"></a>}</span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="dt">int</span> x[maxn],y[maxn],n,c,fa[maxn],cnt,ans;</span>
<span id="cb24-15"><a href="#cb24-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,w;}; e es[maxn*maxn]; <span class="dt">int</span> ess;</span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="kw">inline</span> <span class="dt">bool</span> cmp(<span class="at">const</span> e&amp; a,<span class="at">const</span> e&amp; b){<span class="cf">return</span> a.w&lt;b.w;}</span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb24-18"><a href="#cb24-18"></a><span class="kw">inline</span> <span class="dt">int</span> sqr(<span class="dt">int</span> x){<span class="cf">return</span> x*x;}</span>
<span id="cb24-19"><a href="#cb24-19"></a><span class="dt">int</span> main(){</span>
<span id="cb24-20"><a href="#cb24-20"></a>    n=read(); c=read(); inc(i,<span class="dv">1</span>,n)x[i]=read(),y[i]=read();</span>
<span id="cb24-21"><a href="#cb24-21"></a>    inc(i,<span class="dv">1</span>,n)inc(j,i+<span class="dv">1</span>,n){<span class="dt">int</span> a=sqr(x[i]-x[j])+sqr(y[i]-y[j]); <span class="cf">if</span>(a&gt;=c)es[++ess]=(e){i,j,a};}</span>
<span id="cb24-22"><a href="#cb24-22"></a>    sort(es+<span class="dv">1</span>,es+<span class="dv">1</span>+ess,cmp); inc(i,<span class="dv">1</span>,n)fa[i]=i;</span>
<span id="cb24-23"><a href="#cb24-23"></a>    inc(i,<span class="dv">1</span>,ess){</span>
<span id="cb24-24"><a href="#cb24-24"></a>        <span class="dt">int</span> x=find(es[i].f),y=find(es[i].t); <span class="cf">if</span>(x!=y)fa[y]=x,cnt++,ans+=es[i].w;</span>
<span id="cb24-25"><a href="#cb24-25"></a>        <span class="cf">if</span>(cnt==n-<span class="dv">1</span>)<span class="cf">break</span>;</span>
<span id="cb24-26"><a href="#cb24-26"></a>    }</span>
<span id="cb24-27"><a href="#cb24-27"></a>    <span class="cf">if</span>(cnt==n-<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans);<span class="cf">else</span> printf(<span class="st">&quot;-1&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb24-28"><a href="#cb24-28"></a>}</span></code></pre></div>
<h3 id="bzoj1648usaco2006-deccow-picnic-奶牛野餐2016.8.10">bzoj1648[Usaco2006 Dec]Cow Picnic 奶牛野餐*（2016.8.10）</h3>
<h4 id="题意-24">题意</h4>
<p> K只奶牛分散在N个牧场，问多少地点是所有奶牛都可到达的地方。n≤1000</p>
<h4 id="题解-24">题解</h4>
<p>倒插边然后对每个点dfs，如果经过的奶牛为k则累计答案。注意可能有多只牛在同个牧场，要用数组记录。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb25-9"><a href="#cb25-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb25-11"><a href="#cb25-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb25-12"><a href="#cb25-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb25-13"><a href="#cb25-13"></a>}</span>
<span id="cb25-14"><a href="#cb25-14"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn*<span class="dv">10</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb25-15"><a href="#cb25-15"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess;}</span>
<span id="cb25-16"><a href="#cb25-16"></a><span class="dt">bool</span> cow[maxn],vis[maxn]; <span class="dt">int</span> ans,tot,k,n,m,cnt;</span>
<span id="cb25-17"><a href="#cb25-17"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb25-18"><a href="#cb25-18"></a>    <span class="cf">if</span>(cow[x])tot++; <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(!vis[es[i].t])vis[es[i].t]=<span class="dv">1</span>,dfs(es[i].t);</span>
<span id="cb25-19"><a href="#cb25-19"></a>}</span>
<span id="cb25-20"><a href="#cb25-20"></a><span class="dt">int</span> main(){</span>
<span id="cb25-21"><a href="#cb25-21"></a>    k=read(),n=read(),m=read();</span>
<span id="cb25-22"><a href="#cb25-22"></a>    inc(i,<span class="dv">1</span>,k){<span class="dt">int</span> a=read(); cow[a]=<span class="dv">1</span>;} inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(); pe(b,a);}</span>
<span id="cb25-23"><a href="#cb25-23"></a>    k=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(cow[i])k++;</span>
<span id="cb25-24"><a href="#cb25-24"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb25-25"><a href="#cb25-25"></a>        memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); vis[i]=<span class="dv">1</span>; tot=<span class="dv">0</span>; dfs(i); <span class="cf">if</span>(tot==k)ans++;</span>
<span id="cb25-26"><a href="#cb25-26"></a>    }</span>
<span id="cb25-27"><a href="#cb25-27"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb25-28"><a href="#cb25-28"></a>}</span></code></pre></div>
<h3 id="bzoj3390usaco2004-decbad-cowtractors牛的报复2016.8.10">bzoj3390[Usaco2004 Dec]Bad Cowtractors牛的报复*（2016.8.10）</h3>
<h4 id="题意-25">题意</h4>
<p>最大生成树。</p>
<h4 id="题解-25">题解</h4>
<p>最大生成树。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="pp">#define maxn </span><span class="dv">25010</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb26-9"><a href="#cb26-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb26-10"><a href="#cb26-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb26-11"><a href="#cb26-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb26-12"><a href="#cb26-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb26-13"><a href="#cb26-13"></a>}</span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="dt">int</span> n,a[maxn],b[maxn],x,y,ans;</span>
<span id="cb26-15"><a href="#cb26-15"></a><span class="dt">int</span> main(){</span>
<span id="cb26-16"><a href="#cb26-16"></a>    n=read(); x=read(); y=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(),b[i]=read();</span>
<span id="cb26-17"><a href="#cb26-17"></a>    sort(a+<span class="dv">1</span>,a+n+<span class="dv">1</span>); sort(b+<span class="dv">1</span>,b+n+<span class="dv">1</span>);</span>
<span id="cb26-18"><a href="#cb26-18"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(b[i]&gt;a[i])ans+=(b[i]-a[i])*x;<span class="cf">else</span> ans+=(a[i]-b[i])*y;</span>
<span id="cb26-19"><a href="#cb26-19"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb26-20"><a href="#cb26-20"></a>}</span></code></pre></div>
<h3 id="bzoj3399usaco2009-marsand-castle城堡2016.8.10">bzoj3399[Usaco2009 Mar]Sand Castle城堡*（2016.8.10）</h3>
<h4 id="题意-26">题意</h4>
<p>给个序列a，再给个可变换顺序的序列b，求a变为b的最小代价。a增加一个单位代价为x，降低一个单位代价为y。序列大小≤25000</p>
<h4 id="题解-26">题解</h4>
<p>a，b排序，直接统计即可。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="pp">#define maxn </span><span class="dv">25010</span></span>
<span id="cb27-6"><a href="#cb27-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb27-7"><a href="#cb27-7"></a></span>
<span id="cb27-8"><a href="#cb27-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb27-10"><a href="#cb27-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb27-11"><a href="#cb27-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb27-12"><a href="#cb27-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb27-13"><a href="#cb27-13"></a>}</span>
<span id="cb27-14"><a href="#cb27-14"></a><span class="dt">int</span> n,a[maxn],b[maxn],x,y,ans;</span>
<span id="cb27-15"><a href="#cb27-15"></a><span class="dt">int</span> main(){</span>
<span id="cb27-16"><a href="#cb27-16"></a>    n=read(); x=read(); y=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(),b[i]=read();</span>
<span id="cb27-17"><a href="#cb27-17"></a>    sort(a+<span class="dv">1</span>,a+n+<span class="dv">1</span>); sort(b+<span class="dv">1</span>,b+n+<span class="dv">1</span>);</span>
<span id="cb27-18"><a href="#cb27-18"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(b[i]&gt;a[i])ans+=(b[i]-a[i])*x;<span class="cf">else</span> ans+=(a[i]-b[i])*y;</span>
<span id="cb27-19"><a href="#cb27-19"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb27-20"><a href="#cb27-20"></a>}</span></code></pre></div>
<h3 id="bzoj1455罗马游戏2016.8.10">bzoj1455罗马游戏*（2016.8.10）</h3>
<h4 id="题意-27">题意</h4>
<p>维护数据结构支持合并和弹出最小值。n≤1000000，m≤100000</p>
<h4 id="题解-27">题解</h4>
<p>可并堆，注意本题合并时要判断两个节点是否在同一个堆中。本弱写了左偏树和斜堆，发现斜堆比左偏树快，不知道为什么，求神犇解答。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb28-7"><a href="#cb28-7"></a></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb28-9"><a href="#cb28-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb28-10"><a href="#cb28-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb28-11"><a href="#cb28-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb28-12"><a href="#cb28-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb28-13"><a href="#cb28-13"></a>}</span>
<span id="cb28-14"><a href="#cb28-14"></a><span class="dt">int</span> ch[maxn][<span class="dv">2</span>],v[maxn],fa[maxn]; <span class="dt">bool</span> die[maxn];</span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">while</span>(fa[x])x=fa[x]; <span class="cf">return</span> x;}</span>
<span id="cb28-16"><a href="#cb28-16"></a><span class="dt">int</span> merge(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb28-17"><a href="#cb28-17"></a>    <span class="cf">if</span>(!x||!y)<span class="cf">return</span> x+y; <span class="cf">if</span>(v[x]&gt;v[y])swap(x,y); ch[x][<span class="dv">1</span>]=merge(ch[x][<span class="dv">1</span>],y);</span>
<span id="cb28-18"><a href="#cb28-18"></a>    fa[ch[x][<span class="dv">1</span>]]=x; swap(ch[x][<span class="dv">0</span>],ch[x][<span class="dv">1</span>]); <span class="cf">return</span> x;</span>
<span id="cb28-19"><a href="#cb28-19"></a>}</span>
<span id="cb28-20"><a href="#cb28-20"></a><span class="dt">void</span> pop(<span class="dt">int</span> x){</span>
<span id="cb28-21"><a href="#cb28-21"></a>    fa[ch[x][<span class="dv">0</span>]]=fa[ch[x][<span class="dv">1</span>]]=<span class="dv">0</span>; merge(ch[x][<span class="dv">0</span>],ch[x][<span class="dv">1</span>]); ch[x][<span class="dv">0</span>]=ch[x][<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb28-22"><a href="#cb28-22"></a>}</span>
<span id="cb28-23"><a href="#cb28-23"></a><span class="dt">int</span> n,m; <span class="dt">char</span> opt[<span class="dv">3</span>];</span>
<span id="cb28-24"><a href="#cb28-24"></a><span class="dt">int</span> main(){</span>
<span id="cb28-25"><a href="#cb28-25"></a>    n=read(); inc(i,<span class="dv">1</span>,n)v[i]=read(); m=read();</span>
<span id="cb28-26"><a href="#cb28-26"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb28-27"><a href="#cb28-27"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,opt);</span>
<span id="cb28-28"><a href="#cb28-28"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;M&#39;</span>){</span>
<span id="cb28-29"><a href="#cb28-29"></a>            <span class="dt">int</span> a=read(),b=read(); <span class="cf">if</span>(die[a]||die[b])<span class="cf">continue</span>; <span class="dt">int</span> aa=find(a),bb=find(b);</span>
<span id="cb28-30"><a href="#cb28-30"></a>            <span class="cf">if</span>(aa==bb)<span class="cf">continue</span>; merge(aa,bb);</span>
<span id="cb28-31"><a href="#cb28-31"></a>        }</span>
<span id="cb28-32"><a href="#cb28-32"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;K&#39;</span>){</span>
<span id="cb28-33"><a href="#cb28-33"></a>            <span class="dt">int</span> a=read(); <span class="cf">if</span>(die[a]||a&gt;n)puts(<span class="st">&quot;0&quot;</span>);<span class="cf">else</span>{</span>
<span id="cb28-34"><a href="#cb28-34"></a>                <span class="dt">int</span> aa=find(a); pop(aa); die[aa]=<span class="dv">1</span>; printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,v[aa]);</span>
<span id="cb28-35"><a href="#cb28-35"></a>            }</span>
<span id="cb28-36"><a href="#cb28-36"></a>        }</span>
<span id="cb28-37"><a href="#cb28-37"></a>    }</span>
<span id="cb28-38"><a href="#cb28-38"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb28-39"><a href="#cb28-39"></a>}</span></code></pre></div>
<h3 id="bzoj3410usaco2009-decselfish-grazing-自私的食草者2016.8.10">bzoj3410[Usaco2009 Dec]Selfish Grazing 自私的食草者*（2016.8.10）</h3>
<h4 id="题意-28">题意</h4>
<p>n个区间，求最多的区间集合使其互不覆盖。n≤50000</p>
<h4 id="题解-28">题解</h4>
<p>好像是第三次出现这种题了~但是区间范围可达10^9，不能dp了QAQ膜了一发题解发现只要按区间右端点排序然后贪心取即可。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="pp">#define maxn </span><span class="dv">50100</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb29-7"><a href="#cb29-7"></a></span>
<span id="cb29-8"><a href="#cb29-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb29-9"><a href="#cb29-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb29-10"><a href="#cb29-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb29-11"><a href="#cb29-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb29-12"><a href="#cb29-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb29-13"><a href="#cb29-13"></a>}</span>
<span id="cb29-14"><a href="#cb29-14"></a><span class="kw">struct</span> nd{<span class="dt">int</span> l,r;} nds[maxn];</span>
<span id="cb29-15"><a href="#cb29-15"></a><span class="kw">inline</span> <span class="dt">bool</span> cmp(<span class="at">const</span> nd &amp;a,<span class="at">const</span> nd &amp;b){<span class="cf">return</span> a.r&lt;b.r;}</span>
<span id="cb29-16"><a href="#cb29-16"></a><span class="dt">int</span> n,r,ans;</span>
<span id="cb29-17"><a href="#cb29-17"></a><span class="dt">int</span> main(){</span>
<span id="cb29-18"><a href="#cb29-18"></a>    n=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a=read(),b=read(); nds[i]=(nd){a,b};}</span>
<span id="cb29-19"><a href="#cb29-19"></a>    sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+n,cmp);</span>
<span id="cb29-20"><a href="#cb29-20"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb29-21"><a href="#cb29-21"></a>        <span class="cf">if</span>(nds[i].l&gt;=r)ans++,r=nds[i].r;</span>
<span id="cb29-22"><a href="#cb29-22"></a>    }</span>
<span id="cb29-23"><a href="#cb29-23"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb29-24"><a href="#cb29-24"></a>}</span></code></pre></div>
<h3 id="bzoj2056gift-高精度2016.8.10">bzoj2056gift? 高精度？*（2016.8.10）</h3>
<h4 id="题意-29">题意</h4>
<p>给出abcdefghi，求2<sup>a+2</sup>b+2<sup>c+2</sup>d+2<sup>e+2</sup>f+2<sup>g+2</sup>h+i。a~h≤60，i≤2^63</p>
<h4 id="题解-29">题解</h4>
<p>发现只有极限数据才会爆unsigned long long，所以先让i-1，然后把它们累加起来，发现这个数据是极限数据就手算出2^64输出字符串，否则就直接+1即可。</p>
<h4 id="ll">LL</h4>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb30-6"><a href="#cb30-6"></a></span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="dt">unsigned</span> <span class="dt">long</span> <span class="dt">long</span> a[<span class="dv">10</span>]; <span class="dt">int</span> t;</span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="dt">int</span> main(){</span>
<span id="cb30-9"><a href="#cb30-9"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;t);</span>
<span id="cb30-10"><a href="#cb30-10"></a>    <span class="cf">while</span>(t--){</span>
<span id="cb30-11"><a href="#cb30-11"></a>        inc(i,<span class="dv">0</span>,<span class="dv">8</span>)scanf(<span class="st">&quot;</span><span class="sc">%llu</span><span class="st">&quot;</span>,&amp;a[i]); a[<span class="dv">9</span>]=<span class="dv">0</span>;</span>
<span id="cb30-12"><a href="#cb30-12"></a>        <span class="cf">if</span>(a[<span class="dv">8</span>]==<span class="dv">0</span>){</span>
<span id="cb30-13"><a href="#cb30-13"></a>            inc(i,<span class="dv">0</span>,<span class="dv">7</span>)a[<span class="dv">9</span>]+=(<span class="dv">1</span><span class="bu">LL</span>&lt;&lt;a[i]); printf(<span class="st">&quot;</span><span class="sc">%llu\n</span><span class="st">&quot;</span>,a[<span class="dv">9</span>]);</span>
<span id="cb30-14"><a href="#cb30-14"></a>        }<span class="cf">else</span>{</span>
<span id="cb30-15"><a href="#cb30-15"></a>            a[<span class="dv">8</span>]--; inc(i,<span class="dv">0</span>,<span class="dv">7</span>)a[<span class="dv">9</span>]+=(<span class="dv">1</span><span class="bu">LL</span>&lt;&lt;a[i]); a[<span class="dv">9</span>]+=a[<span class="dv">8</span>];</span>
<span id="cb30-16"><a href="#cb30-16"></a>            <span class="cf">if</span>(a[<span class="dv">9</span>]==<span class="dv">18446744073709551615</span>)printf(<span class="st">&quot;18446744073709551616</span><span class="sc">\n</span><span class="st">&quot;</span>);<span class="cf">else</span> printf(<span class="st">&quot;</span><span class="sc">%llu\n</span><span class="st">&quot;</span>,a[<span class="dv">9</span>]+<span class="dv">1</span>);</span>
<span id="cb30-17"><a href="#cb30-17"></a>        }</span>
<span id="cb30-18"><a href="#cb30-18"></a>    }</span>
<span id="cb30-19"><a href="#cb30-19"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb30-20"><a href="#cb30-20"></a>}</span></code></pre></div>
<h3 id="bzoj1106poi2007立方体大作战tet2016.8.10">bzoj1106[POI2007]立方体大作战tet*（2016.8.10）</h3>
<h4 id="题意-30">题意</h4>
<p>给定玩家一个有2n个元素的栈，这些元素拥有n个不同的编号，每个编号正好有两个元素。玩家每次可以交换两个相邻的元素。如果在交换之后，两个相邻的元素编号相同，则将他们都从栈中移除，所有在他们上面的元素都会掉落下来并且可以导致连锁反应。求最少的步数将方块全部消除。</p>
<h4 id="题解-30">题解</h4>
<p>用一个栈维护，如果遇到一个没有遇到过的编号就入栈，否则就让之前的那个元素出栈，两个元素之间的元素向下移一位，并将两个元素的距离计入答案。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb31-7"><a href="#cb31-7"></a></span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb31-9"><a href="#cb31-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb31-10"><a href="#cb31-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb31-11"><a href="#cb31-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb31-12"><a href="#cb31-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb31-13"><a href="#cb31-13"></a>}</span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="dt">int</span> st[maxn],top,ans,n; <span class="dt">bool</span> in[maxn];</span>
<span id="cb31-15"><a href="#cb31-15"></a><span class="dt">int</span> main(){</span>
<span id="cb31-16"><a href="#cb31-16"></a>    n=read();</span>
<span id="cb31-17"><a href="#cb31-17"></a>    inc(i,<span class="dv">1</span>,<span class="dv">2</span>*n){</span>
<span id="cb31-18"><a href="#cb31-18"></a>        <span class="dt">int</span> x=read();</span>
<span id="cb31-19"><a href="#cb31-19"></a>        <span class="cf">if</span>(!in[x])in[x]=<span class="dv">1</span>,st[++top]=x;<span class="cf">else</span>{</span>
<span id="cb31-20"><a href="#cb31-20"></a>            <span class="dt">int</span> j=top; <span class="cf">while</span>(st[j]!=x)j--; inc(k,j,top-<span class="dv">1</span>)st[k]=st[k+<span class="dv">1</span>],ans++; top--; in[x]=<span class="dv">0</span>;</span>
<span id="cb31-21"><a href="#cb31-21"></a>        }</span>
<span id="cb31-22"><a href="#cb31-22"></a>    }</span>
<span id="cb31-23"><a href="#cb31-23"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb31-24"><a href="#cb31-24"></a>}</span></code></pre></div>
<h3 id="bzoj1861zjoi2006book-书架2016.8.11">bzoj1861[Zjoi2006]Book 书架（2016.8.11）</h3>
<h4 id="题意-31">题意</h4>
<p>维护一个序列，支持移动元素，查询元素是第几个，查询第k个元素编号。</p>
<h4 id="题解-31">题解</h4>
<p>可以用treap和splay，我写的是splay。移动元素就是先删一个节点在将这个节点插入到对应位置，注意各种分操作（如splay、find）的次序性。反思：本弱又WA又T，最后自己造了一个极限数据发现死循环了，对着大数据调了半天才发现是分操作次序不当导致错误。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="pp">#define maxn </span><span class="dv">80100</span></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb32-7"><a href="#cb32-7"></a></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="dt">int</span> ch[maxn][<span class="dv">2</span>],fa[maxn],v[maxn],sz[maxn],pos[maxn],root,book[maxn],tot,n,m;</span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb32-10"><a href="#cb32-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb32-11"><a href="#cb32-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();};</span>
<span id="cb32-12"><a href="#cb32-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb32-13"><a href="#cb32-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb32-14"><a href="#cb32-14"></a>}</span>
<span id="cb32-15"><a href="#cb32-15"></a><span class="kw">inline</span> <span class="dt">void</span> update(<span class="dt">int</span> x){sz[x]=sz[ch[x][<span class="dv">0</span>]]+sz[ch[x][<span class="dv">1</span>]]+<span class="dv">1</span>;}</span>
<span id="cb32-16"><a href="#cb32-16"></a><span class="dt">void</span> rotate(<span class="dt">int</span> x){</span>
<span id="cb32-17"><a href="#cb32-17"></a>    <span class="cf">if</span>(!x||!fa[x])<span class="cf">return</span>; <span class="dt">int</span> a=fa[x],b=fa[fa[x]]; <span class="dt">bool</span> c=x==ch[fa[x]][<span class="dv">1</span>],d=a==ch[fa[a]][<span class="dv">1</span>];</span>
<span id="cb32-18"><a href="#cb32-18"></a>    <span class="cf">if</span>(b)ch[b][d]=x; fa[x]=b; ch[a][c]=ch[x][!c]; <span class="cf">if</span>(ch[x][!c])fa[ch[x][!c]]=a; ch[x][!c]=a; fa[a]=x;</span>
<span id="cb32-19"><a href="#cb32-19"></a>    update(a); update(x); <span class="cf">if</span>(b)update(b);</span>
<span id="cb32-20"><a href="#cb32-20"></a>}</span>
<span id="cb32-21"><a href="#cb32-21"></a><span class="dt">void</span> splay(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb32-22"><a href="#cb32-22"></a>    <span class="cf">if</span>(x==y)<span class="cf">return</span>; <span class="dt">int</span> z=fa[y];</span>
<span id="cb32-23"><a href="#cb32-23"></a>    <span class="cf">while</span>(fa[x]!=z){</span>
<span id="cb32-24"><a href="#cb32-24"></a>        <span class="cf">if</span>(fa[x]!=y)(x==ch[fa[x]][<span class="dv">1</span>])^(fa[x]==ch[fa[fa[x]]][<span class="dv">1</span>])?rotate(x):rotate(fa[x]);</span>
<span id="cb32-25"><a href="#cb32-25"></a>        rotate(x);</span>
<span id="cb32-26"><a href="#cb32-26"></a>    }</span>
<span id="cb32-27"><a href="#cb32-27"></a>    <span class="cf">if</span>(root==y)root=x;</span>
<span id="cb32-28"><a href="#cb32-28"></a>}</span>
<span id="cb32-29"><a href="#cb32-29"></a><span class="dt">void</span> build(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb32-30"><a href="#cb32-30"></a>    <span class="dt">int</span> mid=l+r&gt;&gt;<span class="dv">1</span>; v[x]=book[mid]; pos[book[mid]]=x;</span>
<span id="cb32-31"><a href="#cb32-31"></a>    <span class="cf">if</span>(l&lt;=mid-<span class="dv">1</span>)ch[x][<span class="dv">0</span>]=++tot,build(ch[x][<span class="dv">0</span>],l,mid-<span class="dv">1</span>),fa[ch[x][<span class="dv">0</span>]]=x;</span>
<span id="cb32-32"><a href="#cb32-32"></a>    <span class="cf">if</span>(mid+<span class="dv">1</span>&lt;=r)ch[x][<span class="dv">1</span>]=++tot,build(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r),fa[ch[x][<span class="dv">1</span>]]=x;</span>
<span id="cb32-33"><a href="#cb32-33"></a>    update(x);</span>
<span id="cb32-34"><a href="#cb32-34"></a>}</span>
<span id="cb32-35"><a href="#cb32-35"></a><span class="dt">int</span> querynum(<span class="dt">int</span> x,<span class="dt">int</span> k){</span>
<span id="cb32-36"><a href="#cb32-36"></a>    <span class="cf">if</span>(k&lt;=sz[ch[x][<span class="dv">0</span>]])<span class="cf">return</span> querynum(ch[x][<span class="dv">0</span>],k);</span>
<span id="cb32-37"><a href="#cb32-37"></a>    <span class="cf">if</span>(k==sz[ch[x][<span class="dv">0</span>]]+<span class="dv">1</span>)<span class="cf">return</span> x;</span>
<span id="cb32-38"><a href="#cb32-38"></a>    <span class="cf">return</span> querynum(ch[x][<span class="dv">1</span>],k-sz[ch[x][<span class="dv">0</span>]]-<span class="dv">1</span>);</span>
<span id="cb32-39"><a href="#cb32-39"></a>}</span>
<span id="cb32-40"><a href="#cb32-40"></a><span class="dt">int</span> queryrank(<span class="dt">int</span> x){</span>
<span id="cb32-41"><a href="#cb32-41"></a>    splay(x,root); <span class="cf">return</span> sz[ch[x][<span class="dv">0</span>]];</span>
<span id="cb32-42"><a href="#cb32-42"></a>}</span>
<span id="cb32-43"><a href="#cb32-43"></a><span class="dt">int</span> pre(<span class="dt">int</span> y){</span>
<span id="cb32-44"><a href="#cb32-44"></a>    splay(y,root); <span class="cf">return</span> querynum(ch[y][<span class="dv">0</span>],sz[ch[y][<span class="dv">0</span>]]);</span>
<span id="cb32-45"><a href="#cb32-45"></a>}</span>
<span id="cb32-46"><a href="#cb32-46"></a><span class="dt">int</span> nex(<span class="dt">int</span> y){</span>
<span id="cb32-47"><a href="#cb32-47"></a>    splay(y,root); <span class="cf">return</span> querynum(ch[y][<span class="dv">1</span>],<span class="dv">1</span>);</span>
<span id="cb32-48"><a href="#cb32-48"></a>}</span>
<span id="cb32-49"><a href="#cb32-49"></a><span class="dt">void</span> add(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> z){</span>
<span id="cb32-50"><a href="#cb32-50"></a>    splay(y,root); splay(x,ch[root][<span class="dv">0</span>]); ch[x][<span class="dv">1</span>]=z; fa[z]=x; update(x); update(root);</span>
<span id="cb32-51"><a href="#cb32-51"></a>}</span>
<span id="cb32-52"><a href="#cb32-52"></a><span class="dt">void</span> erase(<span class="dt">int</span> z){</span>
<span id="cb32-53"><a href="#cb32-53"></a>    <span class="dt">int</span> x=pre(z),y=nex(z); splay(y,root); splay(x,ch[root][<span class="dv">0</span>]); ch[x][<span class="dv">1</span>]=<span class="dv">0</span>; fa[z]=<span class="dv">0</span>; update(x); update(root);</span>
<span id="cb32-54"><a href="#cb32-54"></a>}</span>
<span id="cb32-55"><a href="#cb32-55"></a><span class="dt">void</span> top(<span class="dt">int</span> s){</span>
<span id="cb32-56"><a href="#cb32-56"></a>    <span class="dt">int</span> x=pos[s]; erase(x); <span class="dt">int</span> y=querynum(root,<span class="dv">1</span>),z=nex(y); add(y,z,x);</span>
<span id="cb32-57"><a href="#cb32-57"></a>}</span>
<span id="cb32-58"><a href="#cb32-58"></a><span class="dt">void</span> bottom(<span class="dt">int</span> s){</span>
<span id="cb32-59"><a href="#cb32-59"></a>    <span class="dt">int</span> x=pos[s]; erase(x); <span class="dt">int</span> y=querynum(root,sz[root]-<span class="dv">1</span>),z=nex(y); add(y,z,x);</span>
<span id="cb32-60"><a href="#cb32-60"></a>}</span>
<span id="cb32-61"><a href="#cb32-61"></a><span class="dt">void</span> insert(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb32-62"><a href="#cb32-62"></a>    <span class="dt">int</span> a1=pos[s],a2=queryrank(a1)+t; erase(a1); <span class="dt">int</span> a3=querynum(root,a2),a4=nex(a3); add(a3,a4,a1);</span>
<span id="cb32-63"><a href="#cb32-63"></a>}</span>
<span id="cb32-64"><a href="#cb32-64"></a><span class="dt">int</span> ask(<span class="dt">int</span> s){<span class="cf">return</span> queryrank(pos[s])-<span class="dv">1</span>;}</span>
<span id="cb32-65"><a href="#cb32-65"></a><span class="dt">int</span> query(<span class="dt">int</span> s){<span class="cf">return</span> v[querynum(root,s+<span class="dv">1</span>)];}</span>
<span id="cb32-66"><a href="#cb32-66"></a><span class="dt">int</span> main(){</span>
<span id="cb32-67"><a href="#cb32-67"></a>    n=read(); m=read(); inc(i,<span class="dv">2</span>,n+<span class="dv">1</span>)book[i]=read(); tot=root=<span class="dv">1</span>; build(root,<span class="dv">1</span>,n+<span class="dv">2</span>);</span>
<span id="cb32-68"><a href="#cb32-68"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb32-69"><a href="#cb32-69"></a>        <span class="dt">char</span> opt[<span class="dv">8</span>]; scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,opt);</span>
<span id="cb32-70"><a href="#cb32-70"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;T&#39;</span>){<span class="dt">int</span> a=read(); top(a);}</span>
<span id="cb32-71"><a href="#cb32-71"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;B&#39;</span>){<span class="dt">int</span> a=read(); bottom(a);}</span>
<span id="cb32-72"><a href="#cb32-72"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;I&#39;</span>){<span class="dt">int</span> a=read(),b=read(); insert(a,b);}</span>
<span id="cb32-73"><a href="#cb32-73"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;A&#39;</span>){<span class="dt">int</span> a=read(); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ask(a));}</span>
<span id="cb32-74"><a href="#cb32-74"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>){<span class="dt">int</span> a=read(); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query(a));}</span>
<span id="cb32-75"><a href="#cb32-75"></a>    }</span>
<span id="cb32-76"><a href="#cb32-76"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb32-77"><a href="#cb32-77"></a>}</span></code></pre></div>
<h3 id="bzoj1614usaco2007-jantelephone-lines架设电话线2016.8.11">bzoj1614[Usaco2007 Jan]Telephone Lines架设电话线*（2016.8.11）</h3>
<h4 id="题意-32">题意</h4>
<p>n个节点，1号节点已经连入互联网，现在需要将整个图连入网络。有K条边可以免费连接，最后总费用为所有连边费用的最大值，求最小总费用。n≤10000</p>
<h4 id="题解-32">题解</h4>
<p>二分费用，将连边费用大于二分值的长度记为1，否则记为0，求最短路，如果到某个点的距离超过k，则需要增加答案，继续二分。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="pp">#define maxn </span><span class="dv">1001</span></span>
<span id="cb33-7"><a href="#cb33-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb33-9"><a href="#cb33-9"></a></span>
<span id="cb33-10"><a href="#cb33-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb33-11"><a href="#cb33-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb33-12"><a href="#cb33-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb33-13"><a href="#cb33-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb33-14"><a href="#cb33-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb33-15"><a href="#cb33-15"></a>}</span>
<span id="cb33-16"><a href="#cb33-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,y,n;}; e es[maxn*<span class="dv">20</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb33-17"><a href="#cb33-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){</span>
<span id="cb33-18"><a href="#cb33-18"></a>    es[++ess]=(e){t,<span class="dv">0</span>,w,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,w,g[t]}; g[t]=ess;</span>
<span id="cb33-19"><a href="#cb33-19"></a>}</span>
<span id="cb33-20"><a href="#cb33-20"></a><span class="dt">bool</span> inq[maxn]; <span class="dt">int</span> d[maxn],n,m,k,ans; queue&lt;<span class="dt">int</span>&gt;q;</span>
<span id="cb33-21"><a href="#cb33-21"></a><span class="dt">bool</span> spfa(){</span>
<span id="cb33-22"><a href="#cb33-22"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); inc(i,<span class="dv">1</span>,n)d[i]=INF;</span>
<span id="cb33-23"><a href="#cb33-23"></a>    inq[<span class="dv">1</span>]=<span class="dv">1</span>; q.push(<span class="dv">1</span>); d[<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb33-24"><a href="#cb33-24"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb33-25"><a href="#cb33-25"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb33-26"><a href="#cb33-26"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t]&gt;d[x]+es[i].w){</span>
<span id="cb33-27"><a href="#cb33-27"></a>            d[es[i].t]=d[x]+es[i].w; <span class="cf">if</span>(!inq[es[i].t])inq[es[i].t]=<span class="dv">1</span>,q.push(es[i].t);</span>
<span id="cb33-28"><a href="#cb33-28"></a>        }</span>
<span id="cb33-29"><a href="#cb33-29"></a>    }</span>
<span id="cb33-30"><a href="#cb33-30"></a>    <span class="cf">if</span>(d[n]&gt;k)<span class="cf">return</span> <span class="dv">0</span>;<span class="cf">else</span> <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb33-31"><a href="#cb33-31"></a>}</span>
<span id="cb33-32"><a href="#cb33-32"></a><span class="dt">bool</span> check(<span class="dt">int</span> x){</span>
<span id="cb33-33"><a href="#cb33-33"></a>    inc(i,<span class="dv">1</span>,ess)<span class="cf">if</span>(es[i].y&lt;=x)es[i].w=<span class="dv">0</span>;<span class="cf">else</span> es[i].w=<span class="dv">1</span>;</span>
<span id="cb33-34"><a href="#cb33-34"></a>    <span class="cf">return</span> spfa();</span>
<span id="cb33-35"><a href="#cb33-35"></a>}</span>
<span id="cb33-36"><a href="#cb33-36"></a><span class="dt">int</span> main(){</span>
<span id="cb33-37"><a href="#cb33-37"></a>    n=read(); m=read(); k=read(); <span class="dt">int</span> l=<span class="dv">0</span>,r=<span class="dv">0</span>; ans=-<span class="dv">1</span>;</span>
<span id="cb33-38"><a href="#cb33-38"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(),c=read(); pe(a,b,c); r=max(r,c);}</span>
<span id="cb33-39"><a href="#cb33-39"></a>    <span class="cf">while</span>(l&lt;=r){</span>
<span id="cb33-40"><a href="#cb33-40"></a>        <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(check(mid))ans=mid,r=mid-<span class="dv">1</span>;<span class="cf">else</span> l=mid+<span class="dv">1</span>;</span>
<span id="cb33-41"><a href="#cb33-41"></a>    }</span>
<span id="cb33-42"><a href="#cb33-42"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb33-43"><a href="#cb33-43"></a>}</span></code></pre></div>
<h3 id="bzoj3398usaco2009-febbullcow-牡牛和牝牛2016.8.11">bzoj3398[Usaco2009 Feb]Bullcow 牡牛和牝牛*（2016.8.11）</h3>
<h4 id="题意-33">题意</h4>
<p>n头牛，其中有牡牛和牝牛两种，要求任意两只牡牛中要有k只牝牛，问几种方案。n≤100000</p>
<h4 id="题解-33">题解</h4>
<p>dp。f[i]表示第i头牛为牡牛的方案数，f[i]=sigma(j,1,i-k-1)f[j]，这个可以用前缀和维护，最后答案为sigma(i,1,n)f[i]。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="pp">#define maxn </span><span class="dv">100100</span></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="pp">#define mod </span><span class="dv">5000011</span></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb34-8"><a href="#cb34-8"></a></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="dt">int</span> n,k,sm[maxn],f;</span>
<span id="cb34-10"><a href="#cb34-10"></a><span class="dt">int</span> main(){</span>
<span id="cb34-11"><a href="#cb34-11"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k); sm[<span class="dv">0</span>]=<span class="dv">1</span>;</span>
<span id="cb34-12"><a href="#cb34-12"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb34-13"><a href="#cb34-13"></a>        <span class="cf">if</span>(i&lt;=k)f=<span class="dv">1</span>;<span class="cf">else</span> f=sm[i-k-<span class="dv">1</span>];</span>
<span id="cb34-14"><a href="#cb34-14"></a>        sm[i]=(sm[i-<span class="dv">1</span>]+f)%mod;</span>
<span id="cb34-15"><a href="#cb34-15"></a>    }</span>
<span id="cb34-16"><a href="#cb34-16"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,sm[n]);</span>
<span id="cb34-17"><a href="#cb34-17"></a>}</span></code></pre></div>
<h3 id="bzoj2014usaco2010-febchocolate-buying2016.8.11">bzoj2014[Usaco2010 Feb]Chocolate Buying*（2016.8.11）</h3>
<h4 id="题意-34">题意</h4>
<p>n种巧克力，每种有个单价和最多能买几块，问有B块钱一共最多能买几块。n≤100000</p>
<h4 id="题解-34">题解</h4>
<p>贪心，按单价排序。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb35-8"><a href="#cb35-8"></a></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb35-10"><a href="#cb35-10"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb35-11"><a href="#cb35-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb35-12"><a href="#cb35-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb35-13"><a href="#cb35-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb35-14"><a href="#cb35-14"></a>}</span>
<span id="cb35-15"><a href="#cb35-15"></a><span class="dt">int</span> n; ll b,ans;</span>
<span id="cb35-16"><a href="#cb35-16"></a><span class="kw">struct</span> nd{ll p,c;}; nd nds[maxn];</span>
<span id="cb35-17"><a href="#cb35-17"></a><span class="kw">inline</span> <span class="dt">bool</span> cmp(<span class="at">const</span> nd &amp;a,<span class="at">const</span> nd &amp;b){<span class="cf">return</span> a.p&lt;b.p;}</span>
<span id="cb35-18"><a href="#cb35-18"></a><span class="dt">int</span> main(){</span>
<span id="cb35-19"><a href="#cb35-19"></a>    n=read(); b=read(); inc(i,<span class="dv">1</span>,n)nds[i]=(nd){read(),read()}; sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+n,cmp);</span>
<span id="cb35-20"><a href="#cb35-20"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb35-21"><a href="#cb35-21"></a>        ll use=min(nds[i].c,b/nds[i].p);</span>
<span id="cb35-22"><a href="#cb35-22"></a>        b-=use*nds[i].p; ans+=use; <span class="cf">if</span>(use!=nds[i].c)<span class="cf">break</span>;</span>
<span id="cb35-23"><a href="#cb35-23"></a>    }</span>
<span id="cb35-24"><a href="#cb35-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb35-25"><a href="#cb35-25"></a>}</span></code></pre></div>
<h3 id="bzoj2015usaco2010-febchocolate-giving2016.8.11">bzoj2015[Usaco2010 Feb]Chocolate Giving*（2016.8.11）</h3>
<h4 id="题意-35">题意</h4>
<p>n点m边无向图，有k头奶牛要送礼，它必须去农场（1号节点）拿礼物然后到目的地送。问每只奶牛的最短距离。n≤50000</p>
<h4 id="题解-35">题解</h4>
<p>以1号节点为源点spfa求一次最短路即可（反正是无向边）。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb36-10"><a href="#cb36-10"></a></span>
<span id="cb36-11"><a href="#cb36-11"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb36-12"><a href="#cb36-12"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb36-14"><a href="#cb36-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb36-15"><a href="#cb36-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb36-16"><a href="#cb36-16"></a>}</span>
<span id="cb36-17"><a href="#cb36-17"></a></span>
<span id="cb36-18"><a href="#cb36-18"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; e es[maxn*<span class="dv">4</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb36-19"><a href="#cb36-19"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess; es[++ess]=(e){f,w,g[t]}; g[t]=ess;}</span>
<span id="cb36-20"><a href="#cb36-20"></a><span class="dt">int</span> n,m,b,d[maxn]; <span class="dt">bool</span> inq[maxn]; queue&lt;<span class="dt">int</span>&gt;q;</span>
<span id="cb36-21"><a href="#cb36-21"></a><span class="dt">void</span> spfa(){</span>
<span id="cb36-22"><a href="#cb36-22"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); inc(i,<span class="dv">1</span>,n)d[i]=INF;</span>
<span id="cb36-23"><a href="#cb36-23"></a>    q.push(<span class="dv">1</span>); inq[<span class="dv">1</span>]=<span class="dv">1</span>; d[<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb36-24"><a href="#cb36-24"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb36-25"><a href="#cb36-25"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb36-26"><a href="#cb36-26"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t]&gt;d[x]+es[i].w){</span>
<span id="cb36-27"><a href="#cb36-27"></a>            d[es[i].t]=d[x]+es[i].w; <span class="cf">if</span>(!inq[es[i].t])q.push(es[i].t),inq[es[i].t]=<span class="dv">1</span>;</span>
<span id="cb36-28"><a href="#cb36-28"></a>        }</span>
<span id="cb36-29"><a href="#cb36-29"></a>    }</span>
<span id="cb36-30"><a href="#cb36-30"></a>}</span>
<span id="cb36-31"><a href="#cb36-31"></a><span class="dt">int</span> main(){</span>
<span id="cb36-32"><a href="#cb36-32"></a>    n=read(); m=read(); b=read();</span>
<span id="cb36-33"><a href="#cb36-33"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(),c=read(); pe(a,b,c);} spfa();</span>
<span id="cb36-34"><a href="#cb36-34"></a>    inc(i,<span class="dv">1</span>,b){<span class="dt">int</span> a=read(),b=read(); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,d[a]+d[b]);} <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb36-35"><a href="#cb36-35"></a>}</span></code></pre></div>
<h3 id="bzoj2016usaco2010chocolate-eating2016.8.11">bzoj2016[Usaco2010]Chocolate Eating*（2016.8.11）</h3>
<h4 id="题意-36">题意</h4>
<p>n块巧克力，每次吃可以增加ai点快乐，每天早晨睡觉起来快乐值会减半，求如何使d天睡觉前的最小快乐值最大。n，d≤50000</p>
<h4 id="题解-36">题解</h4>
<p>二分快乐值，每天不够就吃。注意如果最后一天有剩余巧克力，必须将其全部吃完。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb37-8"><a href="#cb37-8"></a></span>
<span id="cb37-9"><a href="#cb37-9"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb37-10"><a href="#cb37-10"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb37-11"><a href="#cb37-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb37-12"><a href="#cb37-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb37-13"><a href="#cb37-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb37-14"><a href="#cb37-14"></a>}</span>
<span id="cb37-15"><a href="#cb37-15"></a><span class="dt">int</span> n,d,bel[maxn]; ll h[maxn],ans1,ans2[maxn];</span>
<span id="cb37-16"><a href="#cb37-16"></a><span class="dt">bool</span> check(ll x){</span>
<span id="cb37-17"><a href="#cb37-17"></a>    ll hap=<span class="dv">0</span>; <span class="dt">int</span> p=<span class="dv">1</span>;</span>
<span id="cb37-18"><a href="#cb37-18"></a>    inc(i,<span class="dv">1</span>,d){</span>
<span id="cb37-19"><a href="#cb37-19"></a>        <span class="cf">while</span>(hap&lt;x&amp;&amp;p&lt;=n)hap+=h[p],bel[p]=i,p++; <span class="cf">if</span>(hap&lt;x)<span class="cf">return</span> <span class="dv">0</span>; hap&gt;&gt;=<span class="dv">1</span>;</span>
<span id="cb37-20"><a href="#cb37-20"></a>    }</span>
<span id="cb37-21"><a href="#cb37-21"></a>    <span class="cf">while</span>(p&lt;=n)bel[p]=d,p++; inc(i,<span class="dv">1</span>,n)ans2[i]=bel[i]; ans1=x; <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb37-22"><a href="#cb37-22"></a>}</span>
<span id="cb37-23"><a href="#cb37-23"></a><span class="dt">int</span> main(){</span>
<span id="cb37-24"><a href="#cb37-24"></a>    n=read(); d=read(); inc(i,<span class="dv">1</span>,n)h[i]=read();</span>
<span id="cb37-25"><a href="#cb37-25"></a>    ll l=<span class="dv">1</span>,r=<span class="dv">50000000000</span><span class="bu">LL</span>;</span>
<span id="cb37-26"><a href="#cb37-26"></a>    <span class="cf">while</span>(l&lt;=r){</span>
<span id="cb37-27"><a href="#cb37-27"></a>        ll mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(check(mid))l=mid+<span class="dv">1</span>;<span class="cf">else</span> r=mid-<span class="dv">1</span>;</span>
<span id="cb37-28"><a href="#cb37-28"></a>    }</span>
<span id="cb37-29"><a href="#cb37-29"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,ans1); inc(i,<span class="dv">1</span>,n)printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,ans2[i]);</span>
<span id="cb37-30"><a href="#cb37-30"></a>}</span></code></pre></div>
<h3 id="bzoj3437小p的牧场2016.8.11">bzoj3437小P的牧场（2016.8.11）</h3>
<h4 id="题意-37">题意</h4>
<p>n个牧场，在每个牧场见控制站的花费为ai，在该处建控制站能控制从此处到左边第一个控制站（或边界）之间的牧场。一个牧场被控制的花费等于它到控制它的控制站之间的牧场数目（不包括自身，但包括控制站所在牧场）乘上该牧场的放养量。求最小费用。</p>
<h4 id="题解-37">题解</h4>
<p>推公式：</p>
<p><span class="math display">\[
\begin{split}
f[i]&amp;=f[j]+\sum_{k=j+1}^i{(i-k)\times b[k]}+a[i] \\
    &amp;=f[j]+\sum_{k=j+1}^i{i\times b[k]-k\times b[k]}+a[i] \\
    &amp;=f[j]+\sum_{k=j+1}^i{i\times b[k]}-\sum_{k=j+1}^i{k\times b[k]}+a[i] \\
    &amp;=f[j]+i\times \sum_{k=j+1}^i{b[k]}-\sum_{k=j+1}^i{k\times b[k]}+a[i]
\end{split}
\]</span></p>
<p><span class="math inline">\(\sum_{k=j+1}^i{b[k]}\)</span>和<span class="math inline">\(\sum_{k=j+1}^i{k\times b[k]}\)</span>可用前缀和维护，故原式<span class="math inline">\(=f[j]+i\times(sum1[i]-sum1[j])-(sum2[i]-sum2[j])+a[i]\)</span>，然后就可以斜率优化了：</p>
<p><span class="math display">\[
\begin{split}
f[j]&amp;+i\times(sum1[i]-sum1[j])-(sum2[i]-sum2[j])+a[i]&lt; \\
&amp;f[k]+i\times(sum1[i]-sum1[k])-(sum2[i]-sum2[k])+a[i] \\
&amp;\Leftrightarrow f[j]-i\times sum1[j]+sum2[j]&lt;f[k]-i*sum1[k]+sum2[k] \\
&amp;\Leftrightarrow f[j]-f[k]+sum2[j]-sum2[k]&lt;i\times (sum1[j]-sum1[k]) \\
&amp;\Leftrightarrow \frac{f[j]-f[k]+sum2[j]-sum2[k]}{sum1[j]-sum1[k]}&gt;i,\forall j&lt;k
\end{split}
\]</span></p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb38-8"><a href="#cb38-8"></a></span>
<span id="cb38-9"><a href="#cb38-9"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb38-10"><a href="#cb38-10"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb38-11"><a href="#cb38-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb38-12"><a href="#cb38-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb38-13"><a href="#cb38-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb38-14"><a href="#cb38-14"></a>}</span>
<span id="cb38-15"><a href="#cb38-15"></a>ll f[maxn],sm1[maxn],sm2[maxn],a[maxn]; <span class="dt">int</span> n,q[maxn],l,r;</span>
<span id="cb38-16"><a href="#cb38-16"></a><span class="kw">inline</span> <span class="dt">double</span> calc(<span class="dt">int</span> j,<span class="dt">int</span> k){</span>
<span id="cb38-17"><a href="#cb38-17"></a>    <span class="cf">return</span> ((<span class="dt">double</span>)f[j]-f[k]+sm2[j]-sm2[k])/((<span class="dt">double</span>)sm1[j]-sm1[k]);</span>
<span id="cb38-18"><a href="#cb38-18"></a>}</span>
<span id="cb38-19"><a href="#cb38-19"></a><span class="dt">int</span> main(){</span>
<span id="cb38-20"><a href="#cb38-20"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read();</span>
<span id="cb38-21"><a href="#cb38-21"></a>    inc(i,<span class="dv">1</span>,n){ll b=read(); sm1[i]=sm1[i-<span class="dv">1</span>]+b; sm2[i]=sm2[i-<span class="dv">1</span>]+b*i;} l=r=<span class="dv">1</span>; q[l]=<span class="dv">0</span>;</span>
<span id="cb38-22"><a href="#cb38-22"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb38-23"><a href="#cb38-23"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[l],q[l+<span class="dv">1</span>])&lt;i)l++; f[i]=f[q[l]]+i*(sm1[i]-sm1[q[l]])-sm2[i]+sm2[q[l]]+a[i];</span>
<span id="cb38-24"><a href="#cb38-24"></a>        <span class="cf">while</span>(l&lt;r&amp;&amp;calc(q[r-<span class="dv">1</span>],q[r])&gt;calc(q[r],i))r--; q[++r]=i;</span>
<span id="cb38-25"><a href="#cb38-25"></a>    }</span>
<span id="cb38-26"><a href="#cb38-26"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f[n]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb38-27"><a href="#cb38-27"></a>}</span></code></pre></div>
<h3 id="bzoj2101usaco2010-dectreasure-chest-藏宝箱2016.8.12">bzoj2101[Usaco2010 Dec]Treasure Chest 藏宝箱*（2016.8.12）</h3>
<h4 id="题意-38">题意</h4>
<p>给个序列，A与B轮流取数，谁取的数总和大谁赢。每次只能取序列两端，问A能取的数总和最大是多少。假设两人都用最优策略。序列大小≤5000</p>
<h4 id="题解-38">题解</h4>
<p>dp。f[i][j][0]=max(f[i+1][j][1]+a[i],f[i][j-1][1]+a[j])，f[i][j][1]=min(f[i+1][j][0],f[i][j-1][0])。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb39-5"><a href="#cb39-5"></a><span class="pp">#define maxn </span><span class="dv">5010</span></span>
<span id="cb39-6"><a href="#cb39-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb39-7"><a href="#cb39-7"></a></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb39-9"><a href="#cb39-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb39-10"><a href="#cb39-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb39-11"><a href="#cb39-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb39-12"><a href="#cb39-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb39-13"><a href="#cb39-13"></a>}</span>
<span id="cb39-14"><a href="#cb39-14"></a><span class="dt">int</span> a[maxn],f[<span class="dv">2</span>][maxn][<span class="dv">2</span>],n; <span class="dt">bool</span> x,y;</span>
<span id="cb39-15"><a href="#cb39-15"></a><span class="dt">int</span> main(){</span>
<span id="cb39-16"><a href="#cb39-16"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); x=<span class="dv">0</span>; y=<span class="dv">1</span>;</span>
<span id="cb39-17"><a href="#cb39-17"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb39-18"><a href="#cb39-18"></a>        inc(j,<span class="dv">1</span>,n)f[y][j][<span class="dv">0</span>]=f[y][j][<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb39-19"><a href="#cb39-19"></a>        inc(j,i,n){</span>
<span id="cb39-20"><a href="#cb39-20"></a>            f[y][j][<span class="dv">0</span>]=max(f[x][j][<span class="dv">1</span>]+a[i],f[y][j-<span class="dv">1</span>][<span class="dv">1</span>]+a[j]);</span>
<span id="cb39-21"><a href="#cb39-21"></a>            f[y][j][<span class="dv">1</span>]=min(f[x][j][<span class="dv">0</span>],f[y][j-<span class="dv">1</span>][<span class="dv">0</span>]);</span>
<span id="cb39-22"><a href="#cb39-22"></a>        }</span>
<span id="cb39-23"><a href="#cb39-23"></a>        swap(x,y);</span>
<span id="cb39-24"><a href="#cb39-24"></a>    }</span>
<span id="cb39-25"><a href="#cb39-25"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[x][n][<span class="dv">0</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb39-26"><a href="#cb39-26"></a>}</span></code></pre></div>
<h3 id="bzoj4300绝世好题2016.8.12">bzoj4300绝世好题（2016.8.12）</h3>
<h4 id="题意-39">题意</h4>
<p>给定一个长度为n的数列ai，求ai的子序列bi的最长长度，满足bi&amp;bi-1!=0。n≤100000，ai≤10^9。</p>
<h4 id="题解-39">题解</h4>
<p>用f[i]表示当前二进制i为1的最长子序列长度。每次求所有((1&lt;&lt;i)&amp;bi)==1的f[i]最大值max，将所有((1&lt;&lt;i)&amp;bi)==1的f[i]变为max+1。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb40-7"><a href="#cb40-7"></a></span>
<span id="cb40-8"><a href="#cb40-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb40-9"><a href="#cb40-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb40-10"><a href="#cb40-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb40-11"><a href="#cb40-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb40-12"><a href="#cb40-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb40-13"><a href="#cb40-13"></a>}</span>
<span id="cb40-14"><a href="#cb40-14"></a><span class="dt">int</span> n,a,f[<span class="dv">40</span>],tot;</span>
<span id="cb40-15"><a href="#cb40-15"></a><span class="dt">int</span> main(){</span>
<span id="cb40-16"><a href="#cb40-16"></a>    n=read();</span>
<span id="cb40-17"><a href="#cb40-17"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb40-18"><a href="#cb40-18"></a>        a=read(); tot=<span class="dv">0</span>;</span>
<span id="cb40-19"><a href="#cb40-19"></a>        inc(j,<span class="dv">0</span>,<span class="dv">30</span>)<span class="cf">if</span>(a&amp;(<span class="dv">1</span>&lt;&lt;j))tot=max(tot,f[j]); inc(j,<span class="dv">0</span>,<span class="dv">30</span>)<span class="cf">if</span>(a&amp;(<span class="dv">1</span>&lt;&lt;j))f[j]=tot+<span class="dv">1</span>;</span>
<span id="cb40-20"><a href="#cb40-20"></a>    }</span>
<span id="cb40-21"><a href="#cb40-21"></a>    tot=<span class="dv">0</span>; inc(i,<span class="dv">0</span>,<span class="dv">30</span>)tot=max(tot,f[i]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,tot); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb40-22"><a href="#cb40-22"></a>}</span></code></pre></div>
<h3 id="bzoj3314usaco2013-novcrowded-cows2016.8.12">bzoj3314[Usaco2013 Nov]Crowded Cows*（2016.8.12）</h3>
<h4 id="题意-40">题意</h4>
<p>n头牛，如果某头牛左边距离D以内有高度至少是它的两倍的牛，右边也有，则此牛会感觉到不舒服。问多少牛会不舒服。n≤50000</p>
<h4 id="题解-40">题解</h4>
<p>用单调队列维护距离D以内的区间最大值，判断是否至少是当前牛的两倍，再倒回去做一遍即可。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb41-5"><a href="#cb41-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb41-6"><a href="#cb41-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb41-7"><a href="#cb41-7"></a></span>
<span id="cb41-8"><a href="#cb41-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb41-9"><a href="#cb41-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb41-10"><a href="#cb41-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb41-11"><a href="#cb41-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb41-12"><a href="#cb41-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb41-13"><a href="#cb41-13"></a>}</span>
<span id="cb41-14"><a href="#cb41-14"></a><span class="kw">struct</span> nd{<span class="dt">int</span> x,h;}; nd nds[maxn];</span>
<span id="cb41-15"><a href="#cb41-15"></a><span class="dt">bool</span> cmp(nd a,nd b){<span class="cf">return</span> a.x&lt;b.x;}</span>
<span id="cb41-16"><a href="#cb41-16"></a><span class="dt">int</span> n,d,q1[maxn],q2[maxn],l,r,ans; <span class="dt">bool</span> unc[maxn];</span>
<span id="cb41-17"><a href="#cb41-17"></a><span class="dt">int</span> main(){</span>
<span id="cb41-18"><a href="#cb41-18"></a>    n=read(); d=read(); inc(i,<span class="dv">1</span>,n)nds[i].x=read(),nds[i].h=read(); sort(nds+<span class="dv">1</span>,nds+n+<span class="dv">1</span>,cmp); r=<span class="dv">0</span>; l=<span class="dv">1</span>;</span>
<span id="cb41-19"><a href="#cb41-19"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb41-20"><a href="#cb41-20"></a>        <span class="cf">while</span>(l&lt;=r&amp;&amp;nds[i].x-q1[l]&gt;d)l++; <span class="cf">if</span>(l&lt;=r&amp;&amp;q2[l]&gt;=(nds[i].h&lt;&lt;<span class="dv">1</span>))unc[i]=<span class="dv">1</span>;</span>
<span id="cb41-21"><a href="#cb41-21"></a>        <span class="cf">while</span>(l&lt;=r&amp;&amp;q2[r]&lt;nds[i].h)r--; q1[++r]=nds[i].x; q2[r]=nds[i].h;</span>
<span id="cb41-22"><a href="#cb41-22"></a>    }</span>
<span id="cb41-23"><a href="#cb41-23"></a>    r=<span class="dv">0</span>; l=<span class="dv">1</span>;</span>
<span id="cb41-24"><a href="#cb41-24"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb41-25"><a href="#cb41-25"></a>        <span class="cf">while</span>(l&lt;=r&amp;&amp;q1[l]-nds[i].x&gt;d)l++; <span class="cf">if</span>(l&lt;=r&amp;&amp;q2[l]&gt;=(nds[i].h&lt;&lt;<span class="dv">1</span>)&amp;&amp;unc[i])ans++;</span>
<span id="cb41-26"><a href="#cb41-26"></a>        <span class="cf">while</span>(l&lt;=r&amp;&amp;q2[r]&lt;nds[i].h)r--; q1[++r]=nds[i].x; q2[r]=nds[i].h;</span>
<span id="cb41-27"><a href="#cb41-27"></a>    }</span>
<span id="cb41-28"><a href="#cb41-28"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb41-29"><a href="#cb41-29"></a>}</span></code></pre></div>
<h3 id="bzoj1709usaco2007-octsuper-paintball超级弹珠2016.8.12">bzoj1709[Usaco2007 Oct]Super Paintball超级弹珠*（2016.8.12）</h3>
<h4 id="题意-41">题意</h4>
<p>n*n的网格中有k头牛。在一个格子里发射子弹可以射中本格子，同行，同列，左斜线，右斜线（就是一个米字形）的牛，问能射中所有牛的格子有几个。n≤100。</p>
<h4 id="题解-41">题解</h4>
<p>枚举所有格子，从当前格子出发按题目里的方向走累计被射中的牛即可。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb42-4"><a href="#cb42-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb42-7"><a href="#cb42-7"></a></span>
<span id="cb42-8"><a href="#cb42-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb42-9"><a href="#cb42-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb42-10"><a href="#cb42-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb42-11"><a href="#cb42-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb42-12"><a href="#cb42-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb42-13"><a href="#cb42-13"></a>}</span>
<span id="cb42-14"><a href="#cb42-14"></a><span class="dt">int</span> a[maxn][maxn],n,k,ans;</span>
<span id="cb42-15"><a href="#cb42-15"></a><span class="dt">int</span> main(){</span>
<span id="cb42-16"><a href="#cb42-16"></a>    n=read(); k=read(); inc(i,<span class="dv">1</span>,k){<span class="dt">int</span> x=read(),y=read(); a[x][y]++;}</span>
<span id="cb42-17"><a href="#cb42-17"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n){</span>
<span id="cb42-18"><a href="#cb42-18"></a>        <span class="dt">int</span> tot=<span class="dv">0</span>; inc(l,<span class="dv">1</span>,n)tot+=a[i][l]+a[l][j];</span>
<span id="cb42-19"><a href="#cb42-19"></a>        <span class="dt">int</span> kx=i,ky=j; <span class="cf">while</span>(kx&gt;=<span class="dv">1</span>&amp;&amp;ky&gt;=<span class="dv">1</span>)tot+=a[kx][ky],kx--,ky--;</span>
<span id="cb42-20"><a href="#cb42-20"></a>        kx=i; ky=j; <span class="cf">while</span>(kx&lt;=n&amp;&amp;ky&lt;=n)tot+=a[kx][ky],kx++,ky++;</span>
<span id="cb42-21"><a href="#cb42-21"></a>        kx=i; ky=j; <span class="cf">while</span>(kx&gt;=<span class="dv">1</span>&amp;&amp;ky&lt;=n)tot+=a[kx][ky],kx--,ky++;</span>
<span id="cb42-22"><a href="#cb42-22"></a>        kx=i; ky=j; <span class="cf">while</span>(kx&lt;=n&amp;&amp;ky&gt;=<span class="dv">1</span>)tot+=a[kx][ky],kx++,ky--;</span>
<span id="cb42-23"><a href="#cb42-23"></a>        tot-=<span class="dv">5</span>*a[i][j]; <span class="cf">if</span>(tot==k)ans++;</span>
<span id="cb42-24"><a href="#cb42-24"></a>    }</span>
<span id="cb42-25"><a href="#cb42-25"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb42-26"><a href="#cb42-26"></a>}</span></code></pre></div>
<h3 id="bzoj3858number-transformation2016.8.12">bzoj3858Number Transformation*（2016.8.12）</h3>
<h4 id="题意-42">题意</h4>
<p>给一个数n，对其进行k次变换，第i次变换是将当前的n变成大于等于n的最小的i的倍数。求k次变换后n为多少。n≤10^10，k≤10^10。</p>
<h4 id="题解-42">题解</h4>
<p>对n的变换可以表示成ceil(n/i)*i。有一个结论，当i第一次大于sqrt(当前的n)后，以后的i将永远大于sqrt(那时的n)，且从这以后ceil(n/i)都相等。因此可以先暴力变换n，当i大于sqrt(当前n)后，求出ceil(n/i)，直接乘k就是最后答案。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb43-8"><a href="#cb43-8"></a></span>
<span id="cb43-9"><a href="#cb43-9"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb43-10"><a href="#cb43-10"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb43-11"><a href="#cb43-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb43-12"><a href="#cb43-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb43-13"><a href="#cb43-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb43-14"><a href="#cb43-14"></a>}</span>
<span id="cb43-15"><a href="#cb43-15"></a>ll n,k; <span class="dt">int</span> t;</span>
<span id="cb43-16"><a href="#cb43-16"></a><span class="dt">int</span> main(){</span>
<span id="cb43-17"><a href="#cb43-17"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb43-18"><a href="#cb43-18"></a>        n=read(); k=read(); <span class="cf">if</span>(n==<span class="dv">0</span>&amp;&amp;k==<span class="dv">0</span>)<span class="cf">break</span>; t++; <span class="dt">int</span> i;</span>
<span id="cb43-19"><a href="#cb43-19"></a>        <span class="cf">for</span>(i=<span class="dv">1</span>;i&lt;=k&amp;&amp;i&lt;=(<span class="dt">int</span>)sqrt(n)+<span class="dv">1</span>;i++)n=(n+i-<span class="dv">1</span>)/i*i;</span>
<span id="cb43-20"><a href="#cb43-20"></a>        <span class="cf">if</span>(i==k+<span class="dv">1</span>)printf(<span class="st">&quot;Case #</span><span class="sc">%d</span><span class="st">: </span><span class="sc">%lld\n</span><span class="st">&quot;</span>,t,n);</span>
<span id="cb43-21"><a href="#cb43-21"></a>        <span class="cf">else</span>{n/=(i-<span class="dv">1</span>); printf(<span class="st">&quot;Case #</span><span class="sc">%d</span><span class="st">: </span><span class="sc">%lld\n</span><span class="st">&quot;</span>,t,n*k);}</span>
<span id="cb43-22"><a href="#cb43-22"></a>    }</span>
<span id="cb43-23"><a href="#cb43-23"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb43-24"><a href="#cb43-24"></a>}</span></code></pre></div>
<h3 id="bzoj1755usaco2005-quabank-interest2016.8.12">bzoj1755[Usaco2005 qua]Bank Interest*（2016.8.12）</h3>
<h4 id="题意-43">题意</h4>
<p>输入R，M，Y，求出(1+R%)^Y*M。R≤20，Y≤400</p>
<h4 id="题解-43">题解</h4>
<p>恐怕是bzoj最水的题了……</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb44-6"><a href="#cb44-6"></a></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="dt">int</span> main(){</span>
<span id="cb44-8"><a href="#cb44-8"></a>    <span class="dt">double</span> n,m; <span class="dt">int</span> y; scanf(<span class="st">&quot;</span><span class="sc">%lf%lf%d</span><span class="st">&quot;</span>,&amp;n,&amp;m,&amp;y); n=n/<span class="dv">100</span>+<span class="dv">1</span>; inc(i,<span class="dv">1</span>,y)m*=n; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,<span class="dt">int</span>(m)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb44-9"><a href="#cb44-9"></a>}</span></code></pre></div>
<h3 id="bzoj4291pa2015kieszonkowe2016.8.12">bzoj4291[PA2015]Kieszonkowe*（2016.8.12）</h3>
<h4 id="题意-44">题意</h4>
<p>给定n个数，请从中选出若干个数，使得总和为偶数，请最大化这个总和。n≤1000000。</p>
<h4 id="题解-44">题解</h4>
<p>如果这n个数中有偶数个奇数，就将所有数都选出；否则放弃最小的奇数，选出剩下的数。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb45-5"><a href="#cb45-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb45-6"><a href="#cb45-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb45-7"><a href="#cb45-7"></a></span>
<span id="cb45-8"><a href="#cb45-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb45-9"><a href="#cb45-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb45-10"><a href="#cb45-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb45-11"><a href="#cb45-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb45-12"><a href="#cb45-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb45-13"><a href="#cb45-13"></a>}</span>
<span id="cb45-14"><a href="#cb45-14"></a><span class="dt">int</span> a[maxn],tot,sm,mn,n;</span>
<span id="cb45-15"><a href="#cb45-15"></a><span class="dt">int</span> main(){</span>
<span id="cb45-16"><a href="#cb45-16"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(),sm+=a[i]; <span class="cf">if</span>(n==<span class="dv">1</span>&amp;&amp;(a[<span class="dv">1</span>]&amp;<span class="dv">1</span>))puts(<span class="st">&quot;NIESTETY&quot;</span>);<span class="cf">else</span>{</span>
<span id="cb45-17"><a href="#cb45-17"></a>        inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(a[i]&amp;<span class="dv">1</span>)tot++; <span class="cf">if</span>(!(tot&amp;<span class="dv">1</span>))printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,sm);<span class="cf">else</span>{</span>
<span id="cb45-18"><a href="#cb45-18"></a>            mn=<span class="bn">0x3fffffff</span>; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(a[i]&amp;<span class="dv">1</span>&amp;&amp;mn&gt;a[i])mn=a[i]; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,sm-mn);</span>
<span id="cb45-19"><a href="#cb45-19"></a>        }</span>
<span id="cb45-20"><a href="#cb45-20"></a>    }</span>
<span id="cb45-21"><a href="#cb45-21"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb45-22"><a href="#cb45-22"></a>}</span></code></pre></div>
<h3 id="bzoj4318osu2016.8.12">bzoj4318OSU!*（2016.8.12）</h3>
<h4 id="题意-45">题意</h4>
<p>一个长度为n的序列，每个元素有一定概率是1，不是1就是0。连续x个1可以贡献x^3的分数，问期望分数。</p>
<h4 id="题解-45">题解</h4>
<p>期望dp。f1[i]表示连续到i的期望长度，f2[i]表示期望的f1[i]^2，f3[i]表示期望的f1[i]^3。</p>
<p>f1[i]=(f1[i-1]+1)*p，f2[i]=(f2[i-1]+2*f1[i-1]+1)*p，f3[i]=f3[i-1]+3*f2[i-1]+3*f1[i-1]+1。</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb46-5"><a href="#cb46-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb46-7"><a href="#cb46-7"></a></span>
<span id="cb46-8"><a href="#cb46-8"></a><span class="dt">double</span> f1[maxn],f2[maxn],f3[maxn]; <span class="dt">int</span> n;</span>
<span id="cb46-9"><a href="#cb46-9"></a><span class="dt">int</span> main(){</span>
<span id="cb46-10"><a href="#cb46-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n);</span>
<span id="cb46-11"><a href="#cb46-11"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb46-12"><a href="#cb46-12"></a>        <span class="dt">double</span> a; scanf(<span class="st">&quot;</span><span class="sc">%lf</span><span class="st">&quot;</span>,&amp;a);</span>
<span id="cb46-13"><a href="#cb46-13"></a>        f1[i]=(f1[i-<span class="dv">1</span>]+<span class="dv">1</span>)*a; f2[i]=(f2[i-<span class="dv">1</span>]+<span class="dv">2</span>*f1[i-<span class="dv">1</span>]+<span class="dv">1</span>)*a;</span>
<span id="cb46-14"><a href="#cb46-14"></a>        f3[i]=f3[i-<span class="dv">1</span>]+(f1[i-<span class="dv">1</span>]*<span class="dv">3</span>+f2[i-<span class="dv">1</span>]*<span class="dv">3</span>+<span class="dv">1</span>)*a;</span>
<span id="cb46-15"><a href="#cb46-15"></a>    }</span>
<span id="cb46-16"><a href="#cb46-16"></a>    printf(<span class="st">&quot;%.1lf&quot;</span>,f3[n]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb46-17"><a href="#cb46-17"></a>}</span></code></pre></div>
<h3 id="bzoj2697特技飞行2016.8.12">bzoj2697特技飞行*（2016.8.12）</h3>
<h4 id="题意-46">题意</h4>
<p>N个单位时间，每个单位时间可以进行一项特技动作，可选的动作有K种，每种动作有一个刺激程度Ci。每次动作的价值为(距上次该动作的时间)*Ci，若为第一次进行该动作，价值为0。求最大总价值。N≤1000，K≤300。</p>
<h4 id="题解-46">题解</h4>
<p>因为如果同个动作做3次，不如只做头尾两次更好。所以把动作按Ci降序排序，把Ci大的尽量放在两端。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb47-4"><a href="#cb47-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb47-5"><a href="#cb47-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb47-6"><a href="#cb47-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb47-7"><a href="#cb47-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb47-8"><a href="#cb47-8"></a></span>
<span id="cb47-9"><a href="#cb47-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb47-10"><a href="#cb47-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb47-11"><a href="#cb47-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb47-12"><a href="#cb47-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb47-13"><a href="#cb47-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb47-14"><a href="#cb47-14"></a>}</span>
<span id="cb47-15"><a href="#cb47-15"></a><span class="dt">int</span> n,k,a[maxn],ans;</span>
<span id="cb47-16"><a href="#cb47-16"></a><span class="dt">int</span> main(){</span>
<span id="cb47-17"><a href="#cb47-17"></a>    n=read(); k=read(); inc(i,<span class="dv">1</span>,k)a[i]=read(); sort(a+<span class="dv">1</span>,a+k+<span class="dv">1</span>); <span class="dt">int</span> l=<span class="dv">1</span>,r=n;</span>
<span id="cb47-18"><a href="#cb47-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=k;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb47-19"><a href="#cb47-19"></a>        ans+=(r-l)*a[i]; r--; l++; <span class="cf">if</span>(l&gt;=r)<span class="cf">break</span>;</span>
<span id="cb47-20"><a href="#cb47-20"></a>    }</span>
<span id="cb47-21"><a href="#cb47-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb47-22"><a href="#cb47-22"></a>}</span></code></pre></div>
<h3 id="bzoj3613heoi2014南园满地堆轻絮2016.8.12">bzoj3613[Heoi2014]南园满地堆轻絮（2016.8.12）</h3>
<h4 id="题意-47">题意</h4>
<p>给一个序列，将其修改为不下降序列，要求修改幅度最大的幅度尽量小。序列大小≤5000000</p>
<h4 id="题解-47">题解</h4>
<p>最优策略是将其全部修改为同个值，且这个值是序列中两个相差最大的元素的差值/2。故输出这个值即可。</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="pp">#define maxn </span><span class="dv">5000010</span></span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb48-8"><a href="#cb48-8"></a></span>
<span id="cb48-9"><a href="#cb48-9"></a><span class="dt">int</span> n; ll sa,sb,sc,sd,a[maxn],mod,mx[maxn],ans;</span>
<span id="cb48-10"><a href="#cb48-10"></a>ll f(ll a){<span class="cf">return</span> (a*a%mod*a%mod*sa%mod+a*a%mod*sb%mod+a*sc%mod+sd)%mod;}</span>
<span id="cb48-11"><a href="#cb48-11"></a><span class="dt">int</span> main(){</span>
<span id="cb48-12"><a href="#cb48-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%lld%lld%lld%lld%lld%lld</span><span class="st">&quot;</span>,&amp;n,&amp;sa,&amp;sb,&amp;sc,&amp;sd,&amp;a[<span class="dv">1</span>],&amp;mod);</span>
<span id="cb48-13"><a href="#cb48-13"></a>    inc(i,<span class="dv">2</span>,n)a[i]=(f(a[i-<span class="dv">1</span>])+f(a[i-<span class="dv">2</span>]))%mod; inc(i,<span class="dv">1</span>,n)mx[i]=max(mx[i-<span class="dv">1</span>],a[i]);</span>
<span id="cb48-14"><a href="#cb48-14"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(mx[i-<span class="dv">1</span>]&gt;a[i])ans=max(ans,(mx[i-<span class="dv">1</span>]-a[i]+<span class="dv">1</span>)&gt;&gt;<span class="dv">1</span>); printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb48-15"><a href="#cb48-15"></a>}</span></code></pre></div>
<h3 id="bzoj1901-zju2112-dynamic-rankings2016.8.13">bzoj1901 Zju2112 Dynamic Rankings*（2016.8.13）</h3>
<h4 id="题意-48">题意</h4>
<p>维护数据结构，支持区间第k大和单点修改。序列大小，操作数≤10000</p>
<h4 id="题解-48">题解</h4>
<p>构造一个树状数组，树状数组中的节点用主席树维护。一开始先插入序列中的节点，然后对于修改，就是将经过的树状数组上的主席树删除旧值，再插入新值；对于查询，还是和普通主席树一样二分，但此时的前缀和是由树状数组中数棵主席树查询节点的和得到的。反思：空间复杂度粗略计算是O(nlog^2n)，常数大概是乘个7，8，在bzoj上内存达到了80M，幸好bzoj上空间给的是128M，听说原题空间是31M，规模是30000，我要是做原题早挂了！不知道怎么办QAQ</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb49-7"><a href="#cb49-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb49-8"><a href="#cb49-8"></a></span>
<span id="cb49-9"><a href="#cb49-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb49-10"><a href="#cb49-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb49-11"><a href="#cb49-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb49-12"><a href="#cb49-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb49-13"><a href="#cb49-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb49-14"><a href="#cb49-14"></a>}</span>
<span id="cb49-15"><a href="#cb49-15"></a><span class="dt">int</span> n,m,a[maxn],v[maxn*<span class="dv">2</span>],tot,root[maxn],sz[<span class="dv">3</span>*maxn*<span class="dv">15</span>*<span class="dv">15</span>],ch[<span class="dv">3</span>*maxn*<span class="dv">15</span>*<span class="dv">15</span>][<span class="dv">2</span>],cnt;</span>
<span id="cb49-16"><a href="#cb49-16"></a><span class="kw">struct</span> ask{<span class="dt">char</span> opt[<span class="dv">3</span>]; <span class="dt">int</span> l,r,k;}; ask asks[maxn];</span>
<span id="cb49-17"><a href="#cb49-17"></a><span class="kw">struct</span> ls{<span class="dt">int</span> id,v;}; ls lss[maxn*<span class="dv">2</span>]; <span class="dt">int</span> lsss;</span>
<span id="cb49-18"><a href="#cb49-18"></a><span class="dt">bool</span> cmp(ls a,ls b){<span class="cf">return</span> a.v&lt;b.v;}</span>
<span id="cb49-19"><a href="#cb49-19"></a><span class="dt">void</span> lisan(){</span>
<span id="cb49-20"><a href="#cb49-20"></a>    inc(i,<span class="dv">1</span>,n)lss[++lsss]=(ls){i,a[i]};</span>
<span id="cb49-21"><a href="#cb49-21"></a>    inc(i,<span class="dv">1</span>,m)<span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>)lss[++lsss]=(ls){n+i,asks[i].k};</span>
<span id="cb49-22"><a href="#cb49-22"></a>    sort(lss+<span class="dv">1</span>,lss+<span class="dv">1</span>+lsss,cmp);</span>
<span id="cb49-23"><a href="#cb49-23"></a>    inc(i,<span class="dv">1</span>,lsss){</span>
<span id="cb49-24"><a href="#cb49-24"></a>        <span class="cf">if</span>(i==<span class="dv">1</span>||lss[i].v!=lss[i-<span class="dv">1</span>].v)tot++,v[tot]=lss[i].v;</span>
<span id="cb49-25"><a href="#cb49-25"></a>        <span class="cf">if</span>(lss[i].id&lt;=n)a[lss[i].id]=tot;<span class="cf">else</span> asks[lss[i].id-n].k=tot;</span>
<span id="cb49-26"><a href="#cb49-26"></a>    }</span>
<span id="cb49-27"><a href="#cb49-27"></a>}</span>
<span id="cb49-28"><a href="#cb49-28"></a><span class="dt">int</span> build(<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb49-29"><a href="#cb49-29"></a>    <span class="dt">int</span> x=++cnt; sz[x]=<span class="dv">0</span>; <span class="cf">if</span>(l==r)<span class="cf">return</span> x;</span>
<span id="cb49-30"><a href="#cb49-30"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; ch[x][<span class="dv">0</span>]=build(l,mid); ch[x][<span class="dv">1</span>]=build(mid+<span class="dv">1</span>,r); <span class="cf">return</span> x;</span>
<span id="cb49-31"><a href="#cb49-31"></a>}</span>
<span id="cb49-32"><a href="#cb49-32"></a><span class="dt">void</span> updseg(<span class="dt">int</span> &amp;x,<span class="dt">int</span> y,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> a){</span>
<span id="cb49-33"><a href="#cb49-33"></a>    cnt++; ch[cnt][<span class="dv">0</span>]=ch[x][<span class="dv">0</span>]; ch[cnt][<span class="dv">1</span>]=ch[x][<span class="dv">1</span>]; sz[cnt]=sz[x]+a; x=cnt; <span class="cf">if</span>(l==r)<span class="cf">return</span>;</span>
<span id="cb49-34"><a href="#cb49-34"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(y&lt;=mid)updseg(ch[x][<span class="dv">0</span>],y,l,mid,a); <span class="cf">if</span>(y&gt;mid)updseg(ch[x][<span class="dv">1</span>],y,mid+<span class="dv">1</span>,r,a);</span>
<span id="cb49-35"><a href="#cb49-35"></a>}</span>
<span id="cb49-36"><a href="#cb49-36"></a><span class="dt">int</span> queryseg(<span class="dt">int</span> x,<span class="dt">int</span> ql,<span class="dt">int</span> qr,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb49-37"><a href="#cb49-37"></a>    <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="cf">return</span> sz[x]; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>,q=<span class="dv">0</span>;</span>
<span id="cb49-38"><a href="#cb49-38"></a>    <span class="cf">if</span>(ql&lt;=mid)q+=queryseg(ch[x][<span class="dv">0</span>],ql,qr,l,mid); <span class="cf">if</span>(mid&lt;qr)q+=queryseg(ch[x][<span class="dv">1</span>],ql,qr,mid+<span class="dv">1</span>,r);</span>
<span id="cb49-39"><a href="#cb49-39"></a>    <span class="cf">return</span> q;</span>
<span id="cb49-40"><a href="#cb49-40"></a>}</span>
<span id="cb49-41"><a href="#cb49-41"></a><span class="dt">void</span> updbit(<span class="dt">int</span> x,<span class="dt">int</span> y,<span class="dt">int</span> a){</span>
<span id="cb49-42"><a href="#cb49-42"></a>    <span class="cf">while</span>(x&lt;=n)updseg(root[x],y,<span class="dv">1</span>,tot,a),x+=lb(x);</span>
<span id="cb49-43"><a href="#cb49-43"></a>}</span>
<span id="cb49-44"><a href="#cb49-44"></a><span class="dt">int</span> querybit(<span class="dt">int</span> x,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb49-45"><a href="#cb49-45"></a>    <span class="dt">int</span> q=<span class="dv">0</span>; <span class="cf">while</span>(x&gt;=<span class="dv">1</span>)q+=queryseg(root[x],ql,qr,<span class="dv">1</span>,tot),x-=lb(x); <span class="cf">return</span> q;</span>
<span id="cb49-46"><a href="#cb49-46"></a>}</span>
<span id="cb49-47"><a href="#cb49-47"></a><span class="dt">void</span> init(){</span>
<span id="cb49-48"><a href="#cb49-48"></a>    <span class="dt">int</span> x=build(<span class="dv">1</span>,tot); inc(i,<span class="dv">1</span>,n)root[i]=x; inc(i,<span class="dv">1</span>,n)updbit(i,a[i],<span class="dv">1</span>);</span>
<span id="cb49-49"><a href="#cb49-49"></a>}</span>
<span id="cb49-50"><a href="#cb49-50"></a><span class="dt">int</span> query(<span class="dt">int</span> ql,<span class="dt">int</span> qr,<span class="dt">int</span> k){</span>
<span id="cb49-51"><a href="#cb49-51"></a>    <span class="dt">int</span> l=<span class="dv">1</span>,r=tot;</span>
<span id="cb49-52"><a href="#cb49-52"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb49-53"><a href="#cb49-53"></a>        <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="dt">int</span> x=querybit(qr,l,mid)-querybit(ql-<span class="dv">1</span>,l,mid);</span>
<span id="cb49-54"><a href="#cb49-54"></a>        <span class="cf">if</span>(x&gt;=k)r=mid;<span class="cf">else</span> l=mid+<span class="dv">1</span>,k-=x; <span class="cf">if</span>(l==r)<span class="cf">return</span> l;</span>
<span id="cb49-55"><a href="#cb49-55"></a>    }</span>
<span id="cb49-56"><a href="#cb49-56"></a>}</span>
<span id="cb49-57"><a href="#cb49-57"></a><span class="dt">void</span> modify(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb49-58"><a href="#cb49-58"></a>    updbit(x,a[x],-<span class="dv">1</span>); updbit(x,y,<span class="dv">1</span>); a[x]=y;</span>
<span id="cb49-59"><a href="#cb49-59"></a>}</span>
<span id="cb49-60"><a href="#cb49-60"></a><span class="dt">int</span> main(){</span>
<span id="cb49-61"><a href="#cb49-61"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)a[i]=read();</span>
<span id="cb49-62"><a href="#cb49-62"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb49-63"><a href="#cb49-63"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,asks[i].opt);</span>
<span id="cb49-64"><a href="#cb49-64"></a>        <span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>)asks[i].l=read(),asks[i].r=read(),asks[i].k=read();</span>
<span id="cb49-65"><a href="#cb49-65"></a>        <span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>)asks[i].l=read(),asks[i].k=read();</span>
<span id="cb49-66"><a href="#cb49-66"></a>    }</span>
<span id="cb49-67"><a href="#cb49-67"></a>    lisan(); init();</span>
<span id="cb49-68"><a href="#cb49-68"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb49-69"><a href="#cb49-69"></a>        <span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;Q&#39;</span>)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,v[query(asks[i].l,asks[i].r,asks[i].k)]);</span>
<span id="cb49-70"><a href="#cb49-70"></a>        <span class="cf">if</span>(asks[i].opt[<span class="dv">0</span>]==<span class="ch">&#39;C&#39;</span>)modify(asks[i].l,asks[i].k);</span>
<span id="cb49-71"><a href="#cb49-71"></a>    }</span>
<span id="cb49-72"><a href="#cb49-72"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb49-73"><a href="#cb49-73"></a>}</span></code></pre></div>
<h3 id="bzoj3713pa2014iloczyn2016.8.13">bzoj3713[PA2014]Iloczyn*（2016.8.13）</h3>
<h4 id="题意-49">题意</h4>
<p>判断给定的数字能否被表示成两个斐波那契数的乘积。n≤10^9</p>
<h4 id="题解-49">题解</h4>
<p>开始在想有没有什么根号级算法，后来想知道斐波那契数列10000位有多大，结果爆long long了……实际上斐波那契数列到45位就大于10^9了。所以直接枚举即可。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb50-4"><a href="#cb50-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb50-5"><a href="#cb50-5"></a><span class="pp">#define maxn </span><span class="dv">45</span></span>
<span id="cb50-6"><a href="#cb50-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb50-7"><a href="#cb50-7"></a></span>
<span id="cb50-8"><a href="#cb50-8"></a><span class="dt">int</span> a[maxn+<span class="dv">5</span>]; <span class="dt">int</span> t;</span>
<span id="cb50-9"><a href="#cb50-9"></a><span class="dt">int</span> main(){</span>
<span id="cb50-10"><a href="#cb50-10"></a>    a[<span class="dv">1</span>]=<span class="dv">1</span>; a[<span class="dv">2</span>]=<span class="dv">1</span>; inc(i,<span class="dv">3</span>,maxn)a[i]=a[i-<span class="dv">1</span>]+a[i-<span class="dv">2</span>]; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;t);</span>
<span id="cb50-11"><a href="#cb50-11"></a>    <span class="cf">while</span>(t--){</span>
<span id="cb50-12"><a href="#cb50-12"></a>        <span class="dt">int</span> b; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;b); <span class="cf">if</span>(b==<span class="dv">0</span>){puts(<span class="st">&quot;TAK&quot;</span>); <span class="cf">continue</span>;} <span class="dt">bool</span> f=<span class="dv">0</span>;</span>
<span id="cb50-13"><a href="#cb50-13"></a>        inc(i,<span class="dv">1</span>,maxn){</span>
<span id="cb50-14"><a href="#cb50-14"></a>            inc(j,<span class="dv">1</span>,maxn)<span class="cf">if</span>((<span class="dt">long</span> <span class="dt">long</span>)a[i]*a[j]==b){puts(<span class="st">&quot;TAK&quot;</span>); f=<span class="dv">1</span>; <span class="cf">break</span>;}</span>
<span id="cb50-15"><a href="#cb50-15"></a>            <span class="cf">if</span>(f)<span class="cf">break</span>;</span>
<span id="cb50-16"><a href="#cb50-16"></a>        }</span>
<span id="cb50-17"><a href="#cb50-17"></a>        <span class="cf">if</span>(!f)puts(<span class="st">&quot;NIE&quot;</span>);</span>
<span id="cb50-18"><a href="#cb50-18"></a>    }</span>
<span id="cb50-19"><a href="#cb50-19"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb50-20"><a href="#cb50-20"></a>}</span></code></pre></div>
<h3 id="bzoj22512010beijing-wc外星联络2016.8.13">bzoj2251[2010Beijing Wc]外星联络*（2016.8.13）</h3>
<h4 id="题意-50">题意</h4>
<p>找一个01串中出现次数大于1的字串。01串长度≤3000</p>
<h4 id="题解-50">题解</h4>
<p>有个结论：一个串的所有后缀的所有前缀对应了这个串的字串。所以将这个串的所有后缀插入trie，累计经过trie上每个节点的经过次数，找到大于1的输出即可。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb51-4"><a href="#cb51-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb51-5"><a href="#cb51-5"></a><span class="pp">#define maxn </span><span class="dv">3010</span></span>
<span id="cb51-6"><a href="#cb51-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb51-7"><a href="#cb51-7"></a></span>
<span id="cb51-8"><a href="#cb51-8"></a><span class="dt">int</span> n,ch[maxn*maxn][<span class="dv">2</span>],sm[maxn*maxn],tot; <span class="dt">char</span> s[maxn];</span>
<span id="cb51-9"><a href="#cb51-9"></a><span class="dt">void</span> insert(<span class="dt">int</span> x){</span>
<span id="cb51-10"><a href="#cb51-10"></a>    <span class="dt">int</span> y=<span class="dv">0</span>;</span>
<span id="cb51-11"><a href="#cb51-11"></a>    inc(j,x,n){</span>
<span id="cb51-12"><a href="#cb51-12"></a>        <span class="cf">if</span>(!ch[y][s[j]-<span class="ch">&#39;0&#39;</span>])tot++,ch[y][s[j]-<span class="ch">&#39;0&#39;</span>]=tot,y=tot;<span class="cf">else</span> y=ch[y][s[j]-<span class="ch">&#39;0&#39;</span>]; sm[y]++;</span>
<span id="cb51-13"><a href="#cb51-13"></a>    }</span>
<span id="cb51-14"><a href="#cb51-14"></a>}</span>
<span id="cb51-15"><a href="#cb51-15"></a><span class="dt">void</span> print(<span class="dt">int</span> x){</span>
<span id="cb51-16"><a href="#cb51-16"></a>    <span class="cf">if</span>(sm[x]&gt;<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,sm[x]);</span>
<span id="cb51-17"><a href="#cb51-17"></a>    <span class="cf">if</span>(ch[x][<span class="dv">0</span>])print(ch[x][<span class="dv">0</span>]); <span class="cf">if</span>(ch[x][<span class="dv">1</span>])print(ch[x][<span class="dv">1</span>]);</span>
<span id="cb51-18"><a href="#cb51-18"></a>}</span>
<span id="cb51-19"><a href="#cb51-19"></a><span class="dt">int</span> main(){</span>
<span id="cb51-20"><a href="#cb51-20"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>); inc(i,<span class="dv">1</span>,n)insert(i);</span>
<span id="cb51-21"><a href="#cb51-21"></a>    <span class="cf">if</span>(ch[<span class="dv">0</span>][<span class="dv">0</span>])print(ch[<span class="dv">0</span>][<span class="dv">0</span>]); <span class="cf">if</span>(ch[<span class="dv">0</span>][<span class="dv">1</span>])print(ch[<span class="dv">0</span>][<span class="dv">1</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb51-22"><a href="#cb51-22"></a>}</span></code></pre></div>
<h3 id="bzoj4563haoi2016放棋子2016.8.14">bzoj4563[Haoi2016]放棋子（2016.8.14）</h3>
<h4 id="题意-51">题意</h4>
<p>给你一个N*N的矩阵，每行有一个障碍，数据保证任意两个障碍不在同一行，任意两个障碍不在同一列。要求你放N枚棋子（障碍的位置不能放棋子），也满足每行只有一枚棋子，每列只有一枚棋子的限制，求有多少种方案。N≤200。</p>
<h4 id="题解-51">题解</h4>
<p>发现在障碍在什么位置和答案无关。因此可以把棋子摆成左上-右下对角线，然后就是错排问题（一个长度为n的排列，要求每个元素不能放在与自己编号相同的位置上，问有多少种方案满足条件）了。错排公式：f[i]=(f[i-1]+f[i-2])*(i-1)，特别的，f[0]=1，f[1]=0。本弱太懒了，不想写高精度，写了个python，结果因为不会写wa了好几发QAQ</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1"></a>n<span class="op">=</span><span class="bu">int</span>(<span class="bu">raw_input</span>())</span>
<span id="cb52-2"><a href="#cb52-2"></a>a<span class="op">=</span><span class="dv">1</span></span>
<span id="cb52-3"><a href="#cb52-3"></a>b<span class="op">=</span><span class="dv">0</span></span>
<span id="cb52-4"><a href="#cb52-4"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb52-5"><a href="#cb52-5"></a>    c<span class="op">=</span>(a<span class="op">+</span>b)<span class="op">*</span>(i<span class="dv">-1</span>)</span>
<span id="cb52-6"><a href="#cb52-6"></a>    a<span class="op">=</span>b</span>
<span id="cb52-7"><a href="#cb52-7"></a>    b<span class="op">=</span>c</span>
<span id="cb52-8"><a href="#cb52-8"></a><span class="bu">print</span> b</span></code></pre></div>
<p>//python的高亮好丑啊！</p>
<h3 id="bzoj1002fjoi2007轮状病毒2016.8.14">bzoj1002[FJOI2007]轮状病毒（2016.8.14）</h3>
<h4 id="题意-52">题意</h4>
<p>N轮状病毒的产生规律是在一个N轮状基中删去若干条边，使得各原子之间有唯一的信息通道，例如共有16个不 同的3轮状病毒，如下图所示</p>
<p><img src="/img/bzoj1002轮状病毒.png" /></p>
<p>现给定n，计算有多少个不同的n轮状病毒。N&lt;=100</p>
<h4 id="题解-52">题解</h4>
<p>公式：f[i]=f[i-1]*3-f[i-2]+2,i≥3,f[1]=1,f[2]=5。（我承认我是抄的QAQ因为我根本不懂什么矩阵树定理~</p>
<p>又是高精度，又被我用python水掉了……</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1"></a>n<span class="op">=</span><span class="bu">int</span>(<span class="bu">raw_input</span>())</span>
<span id="cb53-2"><a href="#cb53-2"></a>a<span class="op">=</span><span class="dv">1</span></span>
<span id="cb53-3"><a href="#cb53-3"></a>b<span class="op">=</span><span class="dv">5</span></span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb53-5"><a href="#cb53-5"></a>    c<span class="op">=</span>b<span class="op">*</span><span class="dv">3</span><span class="op">-</span>a<span class="op">+</span><span class="dv">2</span></span>
<span id="cb53-6"><a href="#cb53-6"></a>    a<span class="op">=</span>b</span>
<span id="cb53-7"><a href="#cb53-7"></a>    b<span class="op">=</span>c</span>
<span id="cb53-8"><a href="#cb53-8"></a><span class="cf">if</span> n<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb53-9"><a href="#cb53-9"></a>    <span class="bu">print</span> a</span>
<span id="cb53-10"><a href="#cb53-10"></a><span class="cf">else</span>:</span>
<span id="cb53-11"><a href="#cb53-11"></a>    <span class="bu">print</span> b</span></code></pre></div>
<h3 id="bzoj4236joioji2016.8.14">bzoj4236JOIOJI（2016.8.14）</h3>
<h4 id="题意-53">题意</h4>
<p>给一个只由JOI三个字母组成的串，求最长的一个子串使其中JOI三个字母出现次数相等。串长度≤200000</p>
<h4 id="题解-53">题解</h4>
<p>有点像bzoj4384，因此推算的过程是差不多的，但还是有不同因为本题要求的是出现次数相等，而那题要求的是不等：</p>
<p>cnt[1][i]-cnt[1][j]==cnt[2][i]-cnt[2][j]，cnt[2][i]-cnt[2][j]==cnt[3][i]-cnt[3][j]，cnt[1][i]-cnt[1][j]==cnt[3][i]-cnt[3][j]</p>
<p>化简得到cnt[1][i]-cnt[2][i]==cnt[1][j]-cnt[2][j]，cnt[2][i]-cnt[3][i]==cnt[2][j]-cnt[3][j]，cnt[1][i]-cnt[3][i]==cnt[1][j]-cnt[3][j]（本式实际上是冗余的因为可由前两式相加得到）</p>
<p>故可以用一个map维护二元组&lt;cnt[1][i]-cnt[2][i],cnt[2][i]-cnt[3][i]&gt;的最早出现次数i，每次在map中查找键值中有没有和当前元素的&lt;cnt[1]-cnt[2],cnt[2]-cnt[3]&gt;相等的元素，有的话和答案比较，否则插入map。</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="pp">#include </span><span class="im">&lt;map&gt;</span></span>
<span id="cb54-5"><a href="#cb54-5"></a><span class="pp">#define maxn </span><span class="dv">200100</span></span>
<span id="cb54-6"><a href="#cb54-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb54-7"><a href="#cb54-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb54-8"><a href="#cb54-8"></a></span>
<span id="cb54-9"><a href="#cb54-9"></a><span class="dt">int</span> a,b,c,d,e,n,ans; <span class="dt">char</span> s[maxn];</span>
<span id="cb54-10"><a href="#cb54-10"></a>map&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;,<span class="dt">int</span>&gt;m;</span>
<span id="cb54-11"><a href="#cb54-11"></a><span class="dt">int</span> main(){</span>
<span id="cb54-12"><a href="#cb54-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%s</span><span class="st">&quot;</span>,&amp;n,s+<span class="dv">1</span>); m[make_pair(<span class="dv">0</span>,<span class="dv">0</span>)]=<span class="dv">0</span>;</span>
<span id="cb54-13"><a href="#cb54-13"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb54-14"><a href="#cb54-14"></a>        <span class="cf">if</span>(s[i]==<span class="ch">&#39;J&#39;</span>)a++; <span class="cf">if</span>(s[i]==<span class="ch">&#39;O&#39;</span>)b++; <span class="cf">if</span>(s[i]==<span class="ch">&#39;I&#39;</span>)c++; d=a-b; e=b-c;</span>
<span id="cb54-15"><a href="#cb54-15"></a>        <span class="cf">if</span>(m.find(make_pair(d,e))==m.end())m[make_pair(d,e)]=i;</span>
<span id="cb54-16"><a href="#cb54-16"></a>        <span class="cf">else</span> ans=max(ans,i-m[make_pair(d,e)]);</span>
<span id="cb54-17"><a href="#cb54-17"></a>    }</span>
<span id="cb54-18"><a href="#cb54-18"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb54-19"><a href="#cb54-19"></a>}</span></code></pre></div>
<h3 id="bzoj4517sdoi2016排列计数2016.8.14">bzoj4517[Sdoi2016]排列计数（2016.8.14）</h3>
<h4 id="题意-54">题意</h4>
<p>求有多少种长度为n的序列 A，满足1~n在序列中各出现了一次，且序列恰好有m个数是稳定的（若第i个数A[i]的值为i，则称i是稳定的）。共T组数据，方案数模10^9+7。T=500000，n≤1000000，m≤1000000。</p>
<h4 id="题解-54">题解</h4>
<p>显然结果为C(n,m)*f[n-m]，f[n-m]为错排数满足f[i]=(f[i-1]+f[i-2])*(i-1),f[1]=0,f[0]=1。因为n,m过大，求组合数的递推法行不通，因此只能用公式:C(n,m)=n!/(m!*(n-m)!)，n!先递推出来，因为最后有除法，故还须求个逆元，刚好模数是质数，所以利用费马小定理，写个快速幂就好了。</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb55-4"><a href="#cb55-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb55-5"><a href="#cb55-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb55-6"><a href="#cb55-6"></a><span class="pp">#define mod </span><span class="dv">1000000007</span></span>
<span id="cb55-7"><a href="#cb55-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb55-8"><a href="#cb55-8"></a></span>
<span id="cb55-9"><a href="#cb55-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb55-10"><a href="#cb55-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb55-11"><a href="#cb55-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb55-12"><a href="#cb55-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb55-13"><a href="#cb55-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb55-14"><a href="#cb55-14"></a>}</span>
<span id="cb55-15"><a href="#cb55-15"></a><span class="dt">long</span> <span class="dt">long</span> power(<span class="dt">int</span> a,<span class="dt">int</span> b){</span>
<span id="cb55-16"><a href="#cb55-16"></a>    <span class="cf">if</span>(b==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">1</span>; <span class="cf">if</span>(b==<span class="dv">1</span>)<span class="cf">return</span> a;</span>
<span id="cb55-17"><a href="#cb55-17"></a>    <span class="dt">long</span> <span class="dt">long</span> c=power(a,b&gt;&gt;<span class="dv">1</span>);</span>
<span id="cb55-18"><a href="#cb55-18"></a>    <span class="cf">if</span>(b&amp;<span class="dv">1</span>)<span class="cf">return</span> c*c%mod*a%mod;<span class="cf">else</span> <span class="cf">return</span> c*c%mod;</span>
<span id="cb55-19"><a href="#cb55-19"></a>}</span>
<span id="cb55-20"><a href="#cb55-20"></a><span class="dt">long</span> <span class="dt">long</span> a[maxn],b[maxn]; <span class="dt">int</span> t,n,m;</span>
<span id="cb55-21"><a href="#cb55-21"></a><span class="dt">long</span> <span class="dt">long</span> c(<span class="dt">int</span> n,<span class="dt">int</span> m){</span>
<span id="cb55-22"><a href="#cb55-22"></a>    <span class="cf">return</span> a[n]*power(a[n-m]*a[m]%mod,mod-<span class="dv">2</span>)%mod;</span>
<span id="cb55-23"><a href="#cb55-23"></a>}</span>
<span id="cb55-24"><a href="#cb55-24"></a><span class="dt">int</span> main(){</span>
<span id="cb55-25"><a href="#cb55-25"></a>    a[<span class="dv">0</span>]=<span class="dv">1</span>; inc(i,<span class="dv">1</span>,maxn-<span class="dv">10</span>)a[i]=a[i-<span class="dv">1</span>]*i%mod; b[<span class="dv">0</span>]=<span class="dv">1</span>; b[<span class="dv">1</span>]=<span class="dv">0</span>; inc(i,<span class="dv">2</span>,maxn-<span class="dv">10</span>)b[i]=(b[i-<span class="dv">1</span>]+b[i-<span class="dv">2</span>])%mod*(i-<span class="dv">1</span>)%mod;</span>
<span id="cb55-26"><a href="#cb55-26"></a>    t=read();</span>
<span id="cb55-27"><a href="#cb55-27"></a>    <span class="cf">while</span>(t--){n=read(); m=read(); printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,c(n,m)*b[n-m]%mod);}</span>
<span id="cb55-28"><a href="#cb55-28"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb55-29"><a href="#cb55-29"></a>}</span></code></pre></div>
<h3 id="bzoj1112poi2008砖块klo2016.8.14">bzoj1112[POI2008]砖块Klo*（2016.8.14）</h3>
<h4 id="题意-55">题意</h4>
<p>N柱砖,希望有连续K柱的高度是一样的. 你可以选择以下两个动作 1:丢掉某柱砖的一块砖。给某柱加上一块砖，现在希望用最小次数的动作完成任务。N≤100000</p>
<h4 id="题解-55">题解</h4>
<p>设一个区间长度为k，其中位数为a，比a小的元素个数为b，和为c；比a大的元素个数为d，和为e。则题目要求维护一个长度为k的滑动窗口，能求出它的b*a-c+e-d*a。故用一个维护sum，size两个值的treap来维护。然而似乎我想复杂了？比所有人代码都大1k！注意要开long long。</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb56-4"><a href="#cb56-4"></a><span class="pp">#include </span><span class="im">&lt;cstdlib&gt;</span></span>
<span id="cb56-5"><a href="#cb56-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb56-6"><a href="#cb56-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb56-7"><a href="#cb56-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb56-8"><a href="#cb56-8"></a><span class="pp">#define qs</span>(x,y)<span class="pp"> </span>qs(x,y)</span>
<span id="cb56-9"><a href="#cb56-9"></a><span class="pp">#define qb</span>(x,y)<span class="pp"> </span>qb(x,y)</span>
<span id="cb56-10"><a href="#cb56-10"></a><span class="pp">#define qss</span>(x,y)<span class="pp"> </span>qss(x,y)</span>
<span id="cb56-11"><a href="#cb56-11"></a><span class="pp">#define qbs</span>(x,y)<span class="pp"> </span>qbs(x,y)</span>
<span id="cb56-12"><a href="#cb56-12"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb56-13"><a href="#cb56-13"></a></span>
<span id="cb56-14"><a href="#cb56-14"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb56-15"><a href="#cb56-15"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb56-16"><a href="#cb56-16"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb56-17"><a href="#cb56-17"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb56-18"><a href="#cb56-18"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb56-19"><a href="#cb56-19"></a>}</span>
<span id="cb56-20"><a href="#cb56-20"></a><span class="dt">int</span> ch[maxn][<span class="dv">2</span>],sz[maxn],cnt[maxn],rnd[maxn],n,k,tot,root; ll a[maxn],sm[maxn],v[maxn],ans;</span>
<span id="cb56-21"><a href="#cb56-21"></a><span class="dt">void</span> update(<span class="dt">int</span> x){sz[x]=sz[ch[x][<span class="dv">0</span>]]+sz[ch[x][<span class="dv">1</span>]]+cnt[x],sm[x]=sm[ch[x][<span class="dv">0</span>]]+sm[ch[x][<span class="dv">1</span>]]+v[x]*cnt[x];}</span>
<span id="cb56-22"><a href="#cb56-22"></a><span class="dt">void</span> rotate(<span class="dt">int</span> &amp;x,<span class="dt">bool</span> a){<span class="dt">int</span> y=ch[x][a]; ch[x][a]=ch[y][!a]; ch[y][!a]=x; update(x); update(y); x=y;}</span>
<span id="cb56-23"><a href="#cb56-23"></a><span class="dt">void</span> ins(<span class="dt">int</span> &amp;x,ll val){</span>
<span id="cb56-24"><a href="#cb56-24"></a>    <span class="cf">if</span>(!x){x=++tot; v[x]=sm[x]=val; rnd[x]=rand(); ch[x][<span class="dv">0</span>]=ch[x][<span class="dv">1</span>]=<span class="dv">0</span>; sz[x]=cnt[x]=<span class="dv">1</span>; <span class="cf">return</span>;}</span>
<span id="cb56-25"><a href="#cb56-25"></a>    <span class="cf">if</span>(v[x]==val){cnt[x]++; sz[x]++; sm[x]+=val; <span class="cf">return</span>;}</span>
<span id="cb56-26"><a href="#cb56-26"></a>    <span class="cf">if</span>(val&lt;v[x]){ins(ch[x][<span class="dv">0</span>],val); update(x); <span class="cf">if</span>(rnd[ch[x][<span class="dv">0</span>]]&lt;rnd[x])rotate(x,<span class="dv">0</span>); <span class="cf">return</span>;}</span>
<span id="cb56-27"><a href="#cb56-27"></a>    <span class="cf">if</span>(val&gt;v[x]){ins(ch[x][<span class="dv">1</span>],val); update(x); <span class="cf">if</span>(rnd[ch[x][<span class="dv">1</span>]]&lt;rnd[x])rotate(x,<span class="dv">1</span>); <span class="cf">return</span>;}</span>
<span id="cb56-28"><a href="#cb56-28"></a>}</span>
<span id="cb56-29"><a href="#cb56-29"></a><span class="dt">void</span> del(<span class="dt">int</span> &amp;x,ll val){</span>
<span id="cb56-30"><a href="#cb56-30"></a>    <span class="cf">if</span>(v[x]==val){</span>
<span id="cb56-31"><a href="#cb56-31"></a>        <span class="cf">if</span>(cnt[x]&gt;<span class="dv">1</span>){cnt[x]--; sz[x]--; sm[x]-=val; <span class="cf">return</span>;}</span>
<span id="cb56-32"><a href="#cb56-32"></a>        <span class="cf">else</span>{</span>
<span id="cb56-33"><a href="#cb56-33"></a>            <span class="cf">if</span>(!ch[x][<span class="dv">0</span>]||!ch[x][<span class="dv">1</span>])x=ch[x][<span class="dv">0</span>]+ch[x][<span class="dv">1</span>];</span>
<span id="cb56-34"><a href="#cb56-34"></a>            <span class="cf">else</span>{</span>
<span id="cb56-35"><a href="#cb56-35"></a>                <span class="cf">if</span>(rnd[ch[x][<span class="dv">0</span>]]&lt;rnd[ch[x][<span class="dv">1</span>]])rotate(x,<span class="dv">0</span>),del(ch[x][<span class="dv">1</span>],val),update(x);</span>
<span id="cb56-36"><a href="#cb56-36"></a>                <span class="cf">else</span> rotate(x,<span class="dv">1</span>),del(ch[x][<span class="dv">0</span>],val),update(x);</span>
<span id="cb56-37"><a href="#cb56-37"></a>            }</span>
<span id="cb56-38"><a href="#cb56-38"></a>            <span class="cf">return</span>;</span>
<span id="cb56-39"><a href="#cb56-39"></a>        }</span>
<span id="cb56-40"><a href="#cb56-40"></a>    }</span>
<span id="cb56-41"><a href="#cb56-41"></a>    <span class="cf">if</span>(val&lt;v[x]){del(ch[x][<span class="dv">0</span>],val); update(x); <span class="cf">return</span>;}</span>
<span id="cb56-42"><a href="#cb56-42"></a>    <span class="cf">if</span>(val&gt;v[x]){del(ch[x][<span class="dv">1</span>],val); update(x); <span class="cf">return</span>;}</span>
<span id="cb56-43"><a href="#cb56-43"></a>}</span>
<span id="cb56-44"><a href="#cb56-44"></a><span class="dt">int</span> find(<span class="dt">int</span> x,<span class="dt">int</span> k){</span>
<span id="cb56-45"><a href="#cb56-45"></a>    <span class="cf">if</span>(k&gt;sz[ch[x][<span class="dv">0</span>]]&amp;&amp;k&lt;=sz[ch[x][<span class="dv">0</span>]]+cnt[x])<span class="cf">return</span> x;</span>
<span id="cb56-46"><a href="#cb56-46"></a>    <span class="cf">if</span>(k&lt;=sz[ch[x][<span class="dv">0</span>]])<span class="cf">return</span> find(ch[x][<span class="dv">0</span>],k);</span>
<span id="cb56-47"><a href="#cb56-47"></a>    <span class="cf">if</span>(k&gt;sz[ch[x][<span class="dv">0</span>]]+cnt[x])<span class="cf">return</span> find(ch[x][<span class="dv">1</span>],k-sz[ch[x][<span class="dv">0</span>]]-cnt[x]);</span>
<span id="cb56-48"><a href="#cb56-48"></a>}</span>
<span id="cb56-49"><a href="#cb56-49"></a>ll qs(<span class="dt">int</span> x,ll val){</span>
<span id="cb56-50"><a href="#cb56-50"></a>    <span class="cf">if</span>(val&lt;v[x])<span class="cf">return</span> qs(ch[x][<span class="dv">0</span>],val);</span>
<span id="cb56-51"><a href="#cb56-51"></a>    <span class="cf">if</span>(val==v[x])<span class="cf">return</span> sm[ch[x][<span class="dv">0</span>]];</span>
<span id="cb56-52"><a href="#cb56-52"></a>    <span class="cf">if</span>(val&gt;v[x])<span class="cf">return</span> sm[x]-sm[ch[x][<span class="dv">1</span>]]+qs(ch[x][<span class="dv">1</span>],val);</span>
<span id="cb56-53"><a href="#cb56-53"></a>}</span>
<span id="cb56-54"><a href="#cb56-54"></a>ll qb(<span class="dt">int</span> x,ll val){</span>
<span id="cb56-55"><a href="#cb56-55"></a>    <span class="cf">if</span>(val&gt;v[x])<span class="cf">return</span> qb(ch[x][<span class="dv">1</span>],val);</span>
<span id="cb56-56"><a href="#cb56-56"></a>    <span class="cf">if</span>(val==v[x])<span class="cf">return</span> sm[ch[x][<span class="dv">1</span>]];</span>
<span id="cb56-57"><a href="#cb56-57"></a>    <span class="cf">if</span>(val&lt;v[x])<span class="cf">return</span> sm[x]-sm[ch[x][<span class="dv">0</span>]]+qb(ch[x][<span class="dv">0</span>],val);</span>
<span id="cb56-58"><a href="#cb56-58"></a>}</span>
<span id="cb56-59"><a href="#cb56-59"></a><span class="dt">int</span> qss(<span class="dt">int</span> x,ll val){</span>
<span id="cb56-60"><a href="#cb56-60"></a>    <span class="cf">if</span>(val&lt;v[x])<span class="cf">return</span> qss(ch[x][<span class="dv">0</span>],val);</span>
<span id="cb56-61"><a href="#cb56-61"></a>    <span class="cf">if</span>(val==v[x])<span class="cf">return</span> sz[ch[x][<span class="dv">0</span>]];</span>
<span id="cb56-62"><a href="#cb56-62"></a>    <span class="cf">if</span>(val&gt;v[x])<span class="cf">return</span> sz[x]-sz[ch[x][<span class="dv">1</span>]]+qss(ch[x][<span class="dv">1</span>],val);</span>
<span id="cb56-63"><a href="#cb56-63"></a>}</span>
<span id="cb56-64"><a href="#cb56-64"></a><span class="dt">int</span> qbs(<span class="dt">int</span> x,ll val){</span>
<span id="cb56-65"><a href="#cb56-65"></a>    <span class="cf">if</span>(val&gt;v[x])<span class="cf">return</span> qbs(ch[x][<span class="dv">1</span>],val);</span>
<span id="cb56-66"><a href="#cb56-66"></a>    <span class="cf">if</span>(val==v[x])<span class="cf">return</span> sz[ch[x][<span class="dv">1</span>]];</span>
<span id="cb56-67"><a href="#cb56-67"></a>    <span class="cf">if</span>(val&lt;v[x])<span class="cf">return</span> sz[x]-sz[ch[x][<span class="dv">0</span>]]+qbs(ch[x][<span class="dv">0</span>],val);</span>
<span id="cb56-68"><a href="#cb56-68"></a>}</span>
<span id="cb56-69"><a href="#cb56-69"></a><span class="dt">int</span> main(){</span>
<span id="cb56-70"><a href="#cb56-70"></a>    n=read(); k=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); inc(i,<span class="dv">1</span>,k)ins(root,a[i]); <span class="dt">int</span> l=<span class="dv">1</span>,r=k;</span>
<span id="cb56-71"><a href="#cb56-71"></a>    ans=<span class="dv">1</span><span class="bu">LL</span>*<span class="dv">100000000000</span>;</span>
<span id="cb56-72"><a href="#cb56-72"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb56-73"><a href="#cb56-73"></a>        ll x=v[find(root,(k&gt;&gt;<span class="dv">1</span>)+<span class="dv">1</span>)];</span>
<span id="cb56-74"><a href="#cb56-74"></a>        ans=min(ans,x*qss(root,x)-qs(root,x)+qb(root,x)-qbs(root,x)*x);</span>
<span id="cb56-75"><a href="#cb56-75"></a>        del(root,a[l]); l++; r++; <span class="cf">if</span>(r&gt;n)<span class="cf">break</span>; ins(root,a[r]);</span>
<span id="cb56-76"><a href="#cb56-76"></a>    }</span>
<span id="cb56-77"><a href="#cb56-77"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb56-78"><a href="#cb56-78"></a>}</span></code></pre></div>
<h3 id="bzoj3048usaco2013-jancow-lineup2016.8.14">bzoj3048[Usaco2013 Jan]Cow Lineup*（2016.8.14）</h3>
<h4 id="题意-56">题意</h4>
<p>给你一个序列，你最多可以删去k类数（数列中相同的数字被称为一类数）。求通过删数得到的该序列中的最长完美序列（满足所有的数字相等的连续子序列被叫做完美序列）。序列大小≤100000</p>
<h4 id="题解-56">题解</h4>
<p>先离散化，然后维护一个单调队列，如果当前类数小于等于k+1就比较答案，否则左端点++。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb57-2"><a href="#cb57-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb57-3"><a href="#cb57-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb57-4"><a href="#cb57-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb57-5"><a href="#cb57-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb57-6"><a href="#cb57-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb57-7"><a href="#cb57-7"></a></span>
<span id="cb57-8"><a href="#cb57-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb57-9"><a href="#cb57-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb57-10"><a href="#cb57-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb57-11"><a href="#cb57-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb57-12"><a href="#cb57-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb57-13"><a href="#cb57-13"></a>}</span>
<span id="cb57-14"><a href="#cb57-14"></a><span class="kw">struct</span> ls{<span class="dt">int</span> id,v;}; ls lss[maxn]; <span class="dt">int</span> tot,v[maxn],n,k,l,r,cnt[maxn],mx,kinds;</span>
<span id="cb57-15"><a href="#cb57-15"></a><span class="dt">bool</span> cmp(ls a,ls b){<span class="cf">return</span> a.v&lt;b.v;}</span>
<span id="cb57-16"><a href="#cb57-16"></a><span class="dt">int</span> main(){</span>
<span id="cb57-17"><a href="#cb57-17"></a>    n=read(); k=read(); inc(i,<span class="dv">1</span>,n)lss[i]=(ls){i,read()}; sort(lss+<span class="dv">1</span>,lss+n+<span class="dv">1</span>,cmp);</span>
<span id="cb57-18"><a href="#cb57-18"></a>    inc(i,<span class="dv">1</span>,n){<span class="cf">if</span>(i==<span class="dv">1</span>||lss[i].v!=lss[i-<span class="dv">1</span>].v)tot++; v[lss[i].id]=tot;}</span>
<span id="cb57-19"><a href="#cb57-19"></a>    l=<span class="dv">1</span>; r=<span class="dv">1</span>; kinds=<span class="dv">0</span>;</span>
<span id="cb57-20"><a href="#cb57-20"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb57-21"><a href="#cb57-21"></a>        <span class="cf">while</span>(r&lt;=n&amp;&amp;kinds&lt;=k+<span class="dv">1</span>){</span>
<span id="cb57-22"><a href="#cb57-22"></a>            cnt[v[r]]++; <span class="cf">if</span>(cnt[v[r]]==<span class="dv">1</span>)kinds++; mx=max(mx,cnt[v[r]]); r++;</span>
<span id="cb57-23"><a href="#cb57-23"></a>        }</span>
<span id="cb57-24"><a href="#cb57-24"></a>        <span class="cf">if</span>(r==n+<span class="dv">1</span>)<span class="cf">break</span>;</span>
<span id="cb57-25"><a href="#cb57-25"></a>        <span class="cf">while</span>(kinds&gt;k+<span class="dv">1</span>){</span>
<span id="cb57-26"><a href="#cb57-26"></a>            cnt[v[l]]--; <span class="cf">if</span>(!cnt[v[l]])kinds--; l++;</span>
<span id="cb57-27"><a href="#cb57-27"></a>        }</span>
<span id="cb57-28"><a href="#cb57-28"></a>    }</span>
<span id="cb57-29"><a href="#cb57-29"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,mx); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb57-30"><a href="#cb57-30"></a>}</span></code></pre></div>
<h3 id="bzoj1688usaco2005-opendisease-manangement-疾病管理2016.8.16">bzoj1688[Usaco2005 Open]Disease Manangement 疾病管理*（2016.8.16）</h3>
<h4 id="题意-57">题意</h4>
<p>n头牛，d种疾病，每头牛都患一些疾病，现在要求选出最多的牛，使这些牛患病的种类数不超过k。n≤1000，d≤15</p>
<h4 id="题解-57">题解</h4>
<p>状压dp。f[i][S]表示当前考虑i头牛，患病集合为S，</p>
<p>则f[i][S]=max(f[i+1][S|si]+1,f[i+1][S]),S|si为1的位不超过k且S为1的位不超过k</p>
<p>=f[i+1][S],S|si为1的位超过k且S为1的位不超过k</p>
<p>可以先对每个状态预处理以下判断它为1的位数是否超过了k。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb58-2"><a href="#cb58-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb58-4"><a href="#cb58-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="pp">#define maxn </span><span class="dv">40000</span></span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb58-7"><a href="#cb58-7"></a></span>
<span id="cb58-8"><a href="#cb58-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb58-9"><a href="#cb58-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb58-10"><a href="#cb58-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb58-11"><a href="#cb58-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb58-12"><a href="#cb58-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb58-13"><a href="#cb58-13"></a>}</span>
<span id="cb58-14"><a href="#cb58-14"></a><span class="dt">int</span> f[<span class="dv">2</span>][maxn],n,d,k,a[maxn/<span class="dv">20</span>],x,y; <span class="dt">bool</span> no[maxn];</span>
<span id="cb58-15"><a href="#cb58-15"></a><span class="dt">void</span> init(){</span>
<span id="cb58-16"><a href="#cb58-16"></a>    inc(i,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;d)-<span class="dv">1</span>){</span>
<span id="cb58-17"><a href="#cb58-17"></a>        no[i]=<span class="dv">0</span>; <span class="dt">int</span> tot=<span class="dv">0</span>;</span>
<span id="cb58-18"><a href="#cb58-18"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=<span class="dv">0</span>;(<span class="dv">1</span>&lt;&lt;j)&lt;=i;j++)<span class="cf">if</span>(i&amp;(<span class="dv">1</span>&lt;&lt;j)){</span>
<span id="cb58-19"><a href="#cb58-19"></a>            tot++; <span class="cf">if</span>(tot&gt;k){no[i]=<span class="dv">1</span>; <span class="cf">break</span>;}</span>
<span id="cb58-20"><a href="#cb58-20"></a>        }</span>
<span id="cb58-21"><a href="#cb58-21"></a>    }</span>
<span id="cb58-22"><a href="#cb58-22"></a>}</span>
<span id="cb58-23"><a href="#cb58-23"></a><span class="dt">int</span> main(){</span>
<span id="cb58-24"><a href="#cb58-24"></a>    n=read(); d=read(); k=read(); init();</span>
<span id="cb58-25"><a href="#cb58-25"></a>    inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(); inc(j,<span class="dv">1</span>,x){<span class="dt">int</span> y=read(); a[i]|=(<span class="dv">1</span>&lt;&lt;(y-<span class="dv">1</span>));}}</span>
<span id="cb58-26"><a href="#cb58-26"></a>    x=<span class="dv">0</span>; y=<span class="dv">1</span>;</span>
<span id="cb58-27"><a href="#cb58-27"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb58-28"><a href="#cb58-28"></a>        inc(j,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;d)-<span class="dv">1</span>)<span class="cf">if</span>(!no[j]){</span>
<span id="cb58-29"><a href="#cb58-29"></a>            <span class="dt">int</span> z=j|a[i]; <span class="cf">if</span>(no[z])f[y][j]=f[x][j];<span class="cf">else</span> f[y][j]=max(f[x][z]+<span class="dv">1</span>,f[x][j]);</span>
<span id="cb58-30"><a href="#cb58-30"></a>        }</span>
<span id="cb58-31"><a href="#cb58-31"></a>        swap(x,y);</span>
<span id="cb58-32"><a href="#cb58-32"></a>    }</span>
<span id="cb58-33"><a href="#cb58-33"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[x][<span class="dv">0</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb58-34"><a href="#cb58-34"></a>}</span></code></pre></div>
<h3 id="bzoj2160拉拉队排练2016.8.17">bzoj2160拉拉队排练（2016.8.17）</h3>
<h4 id="题意-58">题意</h4>
<p>给一个字符串，求最长的k个回文子串（此处回文子串长度必须为奇数）长度的乘积。字符串长度≤1000000</p>
<h4 id="题解-58">题解</h4>
<p>先用manacher预处理出第i个字符为中心的最长回文子串一端长度p[i]，然后cnt[1]++,cnt[2*p[i]+1]–，最后cnt[i]+=cnt[i-2]求出所有长度的回文子串个数。然后用快速幂求出相同长度的回文子串的长度乘积即可。注意k要开long long！</p>
<p>反思：manacher是一种用来O(n)求每个字符为中心的最长回文子串一端长度的算法（如果要求的回文子串长度可以是偶数，就在原串两端和每两个字符之间插入一个特殊字符，最后答案/2即可）。主要思想是当前求的p[i]和它的某个对称点j是等价的，可以借助p[j]来求。具体看<a href="https://www.felix021.com/blog/read.php?2040">这个</a>。</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb59-3"><a href="#cb59-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb59-4"><a href="#cb59-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb59-5"><a href="#cb59-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb59-6"><a href="#cb59-6"></a><span class="pp">#define mod </span><span class="dv">19930726</span></span>
<span id="cb59-7"><a href="#cb59-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb59-8"><a href="#cb59-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb59-9"><a href="#cb59-9"></a></span>
<span id="cb59-10"><a href="#cb59-10"></a><span class="dt">int</span> n,mx,id,p[maxn],cnt[maxn]; <span class="dt">char</span> s[maxn]; ll ans,k;</span>
<span id="cb59-11"><a href="#cb59-11"></a>ll power(ll a,<span class="dt">int</span> b){</span>
<span id="cb59-12"><a href="#cb59-12"></a>    <span class="cf">if</span>(b==<span class="dv">0</span>)<span class="cf">return</span> <span class="dv">1</span>; <span class="cf">if</span>(b==<span class="dv">1</span>)<span class="cf">return</span> a;</span>
<span id="cb59-13"><a href="#cb59-13"></a>    ll c=power(a,b&gt;&gt;<span class="dv">1</span>);</span>
<span id="cb59-14"><a href="#cb59-14"></a>    <span class="cf">if</span>(b&amp;<span class="dv">1</span>)<span class="cf">return</span> c*c%mod*a%mod;<span class="cf">else</span> <span class="cf">return</span> c*c%mod;</span>
<span id="cb59-15"><a href="#cb59-15"></a>}</span>
<span id="cb59-16"><a href="#cb59-16"></a><span class="dt">int</span> main(){</span>
<span id="cb59-17"><a href="#cb59-17"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%lld</span><span class="st">&quot;</span>,&amp;n,&amp;k); scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,s+<span class="dv">1</span>); mx=<span class="dv">0</span>; id=<span class="dv">0</span>;</span>
<span id="cb59-18"><a href="#cb59-18"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb59-19"><a href="#cb59-19"></a>        <span class="cf">if</span>(mx&gt;i)p[i]=min(p[<span class="dv">2</span>*id-i],mx-i);<span class="cf">else</span> p[i]=<span class="dv">1</span>;</span>
<span id="cb59-20"><a href="#cb59-20"></a>        <span class="cf">while</span>(i-p[i]&gt;=<span class="dv">1</span>&amp;&amp;i+p[i]&lt;=n&amp;&amp;s[i-p[i]]==s[i+p[i]])p[i]++; cnt[<span class="dv">1</span>]++; cnt[<span class="dv">2</span>*p[i]+<span class="dv">1</span>]--;</span>
<span id="cb59-21"><a href="#cb59-21"></a>        <span class="cf">if</span>(mx&lt;i+p[i]-<span class="dv">1</span>)mx=i+p[i]-<span class="dv">1</span>,id=i;</span>
<span id="cb59-22"><a href="#cb59-22"></a>    }</span>
<span id="cb59-23"><a href="#cb59-23"></a>    inc(i,<span class="dv">3</span>,n)<span class="cf">if</span>(i&amp;<span class="dv">1</span>)cnt[i]+=cnt[i-<span class="dv">2</span>]; ans=<span class="dv">1</span>;</span>
<span id="cb59-24"><a href="#cb59-24"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb59-25"><a href="#cb59-25"></a>        <span class="cf">if</span>(cnt[i]){</span>
<span id="cb59-26"><a href="#cb59-26"></a>            <span class="cf">if</span>(k&gt;=cnt[i]){ans=(ans*power(i,cnt[i]))%mod; k-=cnt[i];}<span class="cf">else</span>{ans=(ans*power(i,k))%mod; k=<span class="dv">0</span>;}</span>
<span id="cb59-27"><a href="#cb59-27"></a>            <span class="cf">if</span>(!k)<span class="cf">break</span>;</span>
<span id="cb59-28"><a href="#cb59-28"></a>        }</span>
<span id="cb59-29"><a href="#cb59-29"></a>    }</span>
<span id="cb59-30"><a href="#cb59-30"></a>    <span class="cf">if</span>(k)printf(<span class="st">&quot;-1&quot;</span>);<span class="cf">else</span> printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb59-31"><a href="#cb59-31"></a>}</span></code></pre></div>
<h3 id="bzoj4459jsoi2013丢番图2016.8.17">bzoj4459[Jsoi2013]丢番图（2016.8.17）</h3>
<h4 id="题意-59">题意</h4>
<p>丢番图方程：1/x+1/y=1/n(x,y,n∈N+) ，给定n，求出关于n的丢番图方程有多少组解。n≤10^14。</p>
<h4 id="题解-59">题解</h4>
<p>通分得yn+xn=xy，即xy-xn-yn+n^2=n^2，即(x-n)(y-n)=n^2，故x-n是n^2的因数，所有答案为n^2的因数个数/2，向上取整。一个数的因数个数为该数每种质因数的个数+1的乘积。所以先将n分解质因数，然后ans乘上个数*2+1（因为要求n^2的因数个数）。如果最后n&gt;1，说明有一个质因数大于sqrt(n)，则ans还要乘3。最后输出(ans+1)/2即可。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb60-2"><a href="#cb60-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb60-3"><a href="#cb60-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb60-4"><a href="#cb60-4"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb60-5"><a href="#cb60-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb60-6"><a href="#cb60-6"></a></span>
<span id="cb60-7"><a href="#cb60-7"></a><span class="dt">long</span> <span class="dt">long</span> n,ans;</span>
<span id="cb60-8"><a href="#cb60-8"></a><span class="dt">int</span> main(){</span>
<span id="cb60-9"><a href="#cb60-9"></a>    scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;n); ans=<span class="dv">1</span>;</span>
<span id="cb60-10"><a href="#cb60-10"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">2</span>;(ll)i*i&lt;=n;i++)<span class="cf">if</span>(n%i==<span class="dv">0</span>){</span>
<span id="cb60-11"><a href="#cb60-11"></a>        <span class="dt">int</span> j=<span class="dv">0</span>; <span class="cf">while</span>(n%i==<span class="dv">0</span>)n/=i,j++; ans*=(j&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>); <span class="cf">if</span>(n==<span class="dv">1</span>)<span class="cf">break</span>;</span>
<span id="cb60-12"><a href="#cb60-12"></a>    }</span>
<span id="cb60-13"><a href="#cb60-13"></a>    <span class="cf">if</span>(n&gt;<span class="dv">1</span>)ans*=<span class="dv">3</span>;</span>
<span id="cb60-14"><a href="#cb60-14"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,(ans+<span class="dv">1</span>)&gt;&gt;<span class="dv">1</span>); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb60-15"><a href="#cb60-15"></a>}</span></code></pre></div>
<h3 id="bzoj4627beijing2016回转寿司2016.8.18">bzoj4627[BeiJing2016]回转寿司（2016.8.18）</h3>
<h4 id="题意-60">题意</h4>
<p>求在一个序列中和在区间[l,r]中的连续子序列的个数。序列大小≤100000，序列元素可以为负数。</p>
<h4 id="题解-60">题解</h4>
<p>题目要求这个：l&lt;=sum[i]-sum[j-1]&lt;=r，移项得sum[i]-l&gt;=sum[j-1]&gt;=sum[i]-r，故题目转化为求一个集合中值在某个区间的元素个数。神犇们的题解里用的都是权值线段树，然而我不知道怎么离散化，所以写了一个treap，不过由于写得不熟，又WA了好几发。注意检查有没有需要用long long的地方却没用。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb61-3"><a href="#cb61-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb61-4"><a href="#cb61-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb61-5"><a href="#cb61-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb61-6"><a href="#cb61-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb61-7"><a href="#cb61-7"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb61-8"><a href="#cb61-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb61-9"><a href="#cb61-9"></a></span>
<span id="cb61-10"><a href="#cb61-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb61-11"><a href="#cb61-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb61-12"><a href="#cb61-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb61-13"><a href="#cb61-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb61-14"><a href="#cb61-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb61-15"><a href="#cb61-15"></a>}</span>
<span id="cb61-16"><a href="#cb61-16"></a>ll v[maxn]; <span class="dt">int</span> ch[maxn][<span class="dv">2</span>],sz[maxn],cnt[maxn],tot,root,rnd[maxn];</span>
<span id="cb61-17"><a href="#cb61-17"></a><span class="dt">void</span> update(<span class="dt">int</span> x){sz[x]=sz[ch[x][<span class="dv">0</span>]]+sz[ch[x][<span class="dv">1</span>]]+cnt[x];}</span>
<span id="cb61-18"><a href="#cb61-18"></a><span class="dt">void</span> rotate(<span class="dt">int</span> &amp;x,<span class="dt">bool</span> c){</span>
<span id="cb61-19"><a href="#cb61-19"></a>    <span class="dt">int</span> y=ch[x][c]; ch[x][c]=ch[y][!c]; ch[y][!c]=x; update(x); update(y); x=y;</span>
<span id="cb61-20"><a href="#cb61-20"></a>}</span>
<span id="cb61-21"><a href="#cb61-21"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;x,ll val){</span>
<span id="cb61-22"><a href="#cb61-22"></a>    <span class="cf">if</span>(!x){x=++tot; sz[x]=cnt[x]=<span class="dv">1</span>; v[x]=val; rnd[x]=rand(); <span class="cf">return</span>;}</span>
<span id="cb61-23"><a href="#cb61-23"></a>    <span class="cf">if</span>(val==v[x]){cnt[x]++; sz[x]++; <span class="cf">return</span>;}</span>
<span id="cb61-24"><a href="#cb61-24"></a>    <span class="cf">if</span>(val&lt;v[x]){insert(ch[x][<span class="dv">0</span>],val); update(x); <span class="cf">if</span>(rnd[ch[x][<span class="dv">0</span>]]&lt;rnd[x])rotate(x,<span class="dv">0</span>); <span class="cf">return</span>;}</span>
<span id="cb61-25"><a href="#cb61-25"></a>    <span class="cf">if</span>(val&gt;v[x]){insert(ch[x][<span class="dv">1</span>],val); update(x); <span class="cf">if</span>(rnd[ch[x][<span class="dv">1</span>]]&lt;rnd[x])rotate(x,<span class="dv">1</span>); <span class="cf">return</span>;}</span>
<span id="cb61-26"><a href="#cb61-26"></a>}</span>
<span id="cb61-27"><a href="#cb61-27"></a><span class="dt">int</span> query1(<span class="dt">int</span> x,ll val){</span>
<span id="cb61-28"><a href="#cb61-28"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb61-29"><a href="#cb61-29"></a>    <span class="cf">if</span>(val&lt;v[x])<span class="cf">return</span> sz[ch[x][<span class="dv">1</span>]]+cnt[x]+query1(ch[x][<span class="dv">0</span>],val);</span>
<span id="cb61-30"><a href="#cb61-30"></a>    <span class="cf">if</span>(val==v[x])<span class="cf">return</span> sz[ch[x][<span class="dv">1</span>]]+cnt[x];</span>
<span id="cb61-31"><a href="#cb61-31"></a>    <span class="cf">if</span>(val&gt;v[x])<span class="cf">return</span> query1(ch[x][<span class="dv">1</span>],val);</span>
<span id="cb61-32"><a href="#cb61-32"></a>}</span>
<span id="cb61-33"><a href="#cb61-33"></a><span class="dt">int</span> query2(<span class="dt">int</span> x,ll val){</span>
<span id="cb61-34"><a href="#cb61-34"></a>    <span class="cf">if</span>(!x)<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb61-35"><a href="#cb61-35"></a>    <span class="cf">if</span>(val&lt;v[x])<span class="cf">return</span> sz[ch[x][<span class="dv">1</span>]]+cnt[x]+query2(ch[x][<span class="dv">0</span>],val);</span>
<span id="cb61-36"><a href="#cb61-36"></a>    <span class="cf">if</span>(val==v[x])<span class="cf">return</span> sz[ch[x][<span class="dv">1</span>]];</span>
<span id="cb61-37"><a href="#cb61-37"></a>    <span class="cf">if</span>(val&gt;v[x])<span class="cf">return</span> query2(ch[x][<span class="dv">1</span>],val);</span>
<span id="cb61-38"><a href="#cb61-38"></a>}</span>
<span id="cb61-39"><a href="#cb61-39"></a><span class="dt">int</span> n; ll sm,ans,l,r;</span>
<span id="cb61-40"><a href="#cb61-40"></a><span class="dt">int</span> main(){</span>
<span id="cb61-41"><a href="#cb61-41"></a>    n=read(); l=read(); r=read(); insert(root,<span class="dv">0</span>);</span>
<span id="cb61-42"><a href="#cb61-42"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb61-43"><a href="#cb61-43"></a>        ll a=read(); sm+=a; <span class="dt">int</span> x=query1(root,sm-r),y=query2(root,sm-l); ans+=(ll)x-y; insert(root,sm);</span>
<span id="cb61-44"><a href="#cb61-44"></a>    }</span>
<span id="cb61-45"><a href="#cb61-45"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb61-46"><a href="#cb61-46"></a>}</span></code></pre></div>
<h3 id="bzoj3555ctsc2014企鹅qq2016.8.20">bzoj3555[Ctsc2014]企鹅QQ（2016.8.20）</h3>
<h4 id="题意-61">题意</h4>
<p>判定有多少对字符串只有一个字母不同。字符串个数≤30000，长度≤300。</p>
<h4 id="题解-61">题解</h4>
<p>求出第i个字符串前j个字符的哈希值hs[i][j]，然后枚举去掉所有字符串的第几位，将去掉后的字符串的哈希值用hs数组直接算出，排序后检查有没有相同的计入答案。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="pp">#define maxn </span><span class="dv">30010</span></span>
<span id="cb62-6"><a href="#cb62-6"></a><span class="pp">#define hash </span><span class="dv">2333</span></span>
<span id="cb62-7"><a href="#cb62-7"></a><span class="pp">#define ll </span><span class="dt">unsigned</span><span class="pp"> </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb62-8"><a href="#cb62-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb62-9"><a href="#cb62-9"></a></span>
<span id="cb62-10"><a href="#cb62-10"></a>ll hs[maxn][<span class="dv">210</span>],tmp[maxn],power[maxn],ans; <span class="dt">int</span> n,k,s; <span class="dt">char</span> str[<span class="dv">210</span>];</span>
<span id="cb62-11"><a href="#cb62-11"></a><span class="dt">int</span> main(){</span>
<span id="cb62-12"><a href="#cb62-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k,&amp;s); power[<span class="dv">0</span>]=<span class="dv">1</span>; inc(i,<span class="dv">1</span>,k)power[i]=power[i-<span class="dv">1</span>]*hash;</span>
<span id="cb62-13"><a href="#cb62-13"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb62-14"><a href="#cb62-14"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,str+<span class="dv">1</span>); inc(j,<span class="dv">1</span>,k)hs[i][j]=hs[i][j-<span class="dv">1</span>]*hash+str[j];</span>
<span id="cb62-15"><a href="#cb62-15"></a>    }</span>
<span id="cb62-16"><a href="#cb62-16"></a>    inc(i,<span class="dv">1</span>,k){</span>
<span id="cb62-17"><a href="#cb62-17"></a>        inc(j,<span class="dv">1</span>,n)tmp[j]=hs[j][k]-hs[j][i]*power[k-i]+hs[j][i-<span class="dv">1</span>]*power[k-i+<span class="dv">1</span>];</span>
<span id="cb62-18"><a href="#cb62-18"></a>        sort(tmp+<span class="dv">1</span>,tmp+<span class="dv">1</span>+n); <span class="dt">int</span> cnt=<span class="dv">1</span>;</span>
<span id="cb62-19"><a href="#cb62-19"></a>        inc(j,<span class="dv">2</span>,n)<span class="cf">if</span>(tmp[j]==tmp[j-<span class="dv">1</span>])ans+=cnt,cnt++;<span class="cf">else</span> cnt=<span class="dv">1</span>;</span>
<span id="cb62-20"><a href="#cb62-20"></a>    }</span>
<span id="cb62-21"><a href="#cb62-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%llu</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb62-22"><a href="#cb62-22"></a>}</span></code></pre></div>
<h3 id="bzoj4385poi2015wilcze-doły2016.8.23">bzoj4385[POI2015]Wilcze doły（2016.8.23）</h3>
<h4 id="题意-62">题意</h4>
<p>给出一个序列，你能将一个长度不超过d的连续子序列全部变为0，要求和不超过p的最长连续子序列。序列大小≤2000000。</p>
<h4 id="题解-62">题解</h4>
<p>用两个指针，每次右指针右移时就将新加入元素所能消掉的区间加入单调队列，如果当前区间和减单调队列中最大的元素不超过p，则累计答案，否则左指针左移并在单调队列中删掉这个元素（如果存在的话）。反思：本弱wa了4发，对拍查不出错误，后来和标程一点一点对比，才发现问题。原因是ans没有初始化为d（见我的烂代码），这样的话如果遇到这个数据就会挂：</p>
<p>2 0 1</p>
<p>1 2</p>
<p>结果会输出0。不过根本原因是我程序写得不好，容易出bug。</p>
<p>我的烂代码：</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb63-3"><a href="#cb63-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb63-4"><a href="#cb63-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb63-5"><a href="#cb63-5"></a><span class="pp">#define maxn </span><span class="dv">2000010</span></span>
<span id="cb63-6"><a href="#cb63-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb63-7"><a href="#cb63-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb63-8"><a href="#cb63-8"></a></span>
<span id="cb63-9"><a href="#cb63-9"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb63-10"><a href="#cb63-10"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb63-11"><a href="#cb63-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb63-12"><a href="#cb63-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb63-13"><a href="#cb63-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb63-14"><a href="#cb63-14"></a>}</span>
<span id="cb63-15"><a href="#cb63-15"></a>ll a[maxn],sum[maxn],q1[maxn],now,p; <span class="dt">int</span> q2[maxn],l,r,ql,qr,ans,n,d;</span>
<span id="cb63-16"><a href="#cb63-16"></a><span class="dt">int</span> main(){</span>
<span id="cb63-17"><a href="#cb63-17"></a>    n=read(); p=read(); d=read();</span>
<span id="cb63-18"><a href="#cb63-18"></a>    <span class="cf">if</span>(d&gt;=n){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,n); <span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb63-19"><a href="#cb63-19"></a>    inc(i,<span class="dv">1</span>,n)a[i]=read(),sum[i]=sum[i-<span class="dv">1</span>]+a[i];</span>
<span id="cb63-20"><a href="#cb63-20"></a>    l=<span class="dv">1</span>; r=d; ql=qr=<span class="dv">1</span>; q1[<span class="dv">1</span>]=now=sum[r]-sum[l-<span class="dv">1</span>]; q2[<span class="dv">1</span>]=<span class="dv">1</span>; ans=d;</span>
<span id="cb63-21"><a href="#cb63-21"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb63-22"><a href="#cb63-22"></a>        <span class="cf">while</span>(r&lt;n&amp;&amp;(r-l+<span class="dv">1</span>&lt;d||now&lt;=p+q1[ql])){</span>
<span id="cb63-23"><a href="#cb63-23"></a>            r++; now+=a[r];</span>
<span id="cb63-24"><a href="#cb63-24"></a>            <span class="cf">while</span>(ql&lt;=qr&amp;&amp;sum[r]-sum[r-d]&gt;=q1[qr])qr--;</span>
<span id="cb63-25"><a href="#cb63-25"></a>            q1[++qr]=sum[r]-sum[r-d]; q2[qr]=r-d+<span class="dv">1</span>;</span>
<span id="cb63-26"><a href="#cb63-26"></a>            <span class="cf">if</span>(now&lt;=p+q1[ql])ans=max(ans,r-l+<span class="dv">1</span>);</span>
<span id="cb63-27"><a href="#cb63-27"></a>        }</span>
<span id="cb63-28"><a href="#cb63-28"></a>        <span class="cf">if</span>(r==n)<span class="cf">break</span>; now-=a[l]; <span class="cf">if</span>(ql&lt;=qr&amp;&amp;q2[ql]&lt;=l)ql++; l++;</span>
<span id="cb63-29"><a href="#cb63-29"></a>    }</span>
<span id="cb63-30"><a href="#cb63-30"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb63-31"><a href="#cb63-31"></a>}</span></code></pre></div>
<p>照标程写的代码：</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb64-3"><a href="#cb64-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb64-4"><a href="#cb64-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb64-5"><a href="#cb64-5"></a><span class="pp">#define maxn </span><span class="dv">2000010</span></span>
<span id="cb64-6"><a href="#cb64-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb64-7"><a href="#cb64-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb64-8"><a href="#cb64-8"></a></span>
<span id="cb64-9"><a href="#cb64-9"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb64-10"><a href="#cb64-10"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb64-11"><a href="#cb64-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb64-12"><a href="#cb64-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb64-13"><a href="#cb64-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb64-14"><a href="#cb64-14"></a>}</span>
<span id="cb64-15"><a href="#cb64-15"></a>ll a[maxn],sum[maxn],q1[maxn],now,p; <span class="dt">int</span> q2[maxn],l,r,ql,qr,ans,n,d;</span>
<span id="cb64-16"><a href="#cb64-16"></a><span class="dt">int</span> main(){</span>
<span id="cb64-17"><a href="#cb64-17"></a>    n=read(); p=read(); d=read();</span>
<span id="cb64-18"><a href="#cb64-18"></a>    <span class="cf">if</span>(d&gt;=n){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,n); <span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb64-19"><a href="#cb64-19"></a>    inc(i,<span class="dv">1</span>,n)a[i]=read(),sum[i]=sum[i-<span class="dv">1</span>]+a[i];</span>
<span id="cb64-20"><a href="#cb64-20"></a>    l=<span class="dv">1</span>; r=d; ql=qr=<span class="dv">1</span>; q1[<span class="dv">1</span>]=now=sum[r]-sum[l-<span class="dv">1</span>]; q2[<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb64-21"><a href="#cb64-21"></a>    <span class="cf">while</span>(r&lt;n){</span>
<span id="cb64-22"><a href="#cb64-22"></a>        r++; now+=a[r]; <span class="cf">while</span>(ql&lt;=qr&amp;&amp;sum[r]-sum[r-d]&gt;=q1[qr])qr--;</span>
<span id="cb64-23"><a href="#cb64-23"></a>        q1[++qr]=sum[r]-sum[r-d]; q2[qr]=r-d+<span class="dv">1</span>;</span>
<span id="cb64-24"><a href="#cb64-24"></a>        <span class="cf">while</span>(now&gt;p+q1[ql]){now-=a[l]; <span class="cf">if</span>(q2[ql]&lt;=l)ql++; l++;}</span>
<span id="cb64-25"><a href="#cb64-25"></a>        ans=max(ans,r-l+<span class="dv">1</span>);</span>
<span id="cb64-26"><a href="#cb64-26"></a>    }</span>
<span id="cb64-27"><a href="#cb64-27"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb64-28"><a href="#cb64-28"></a>}</span></code></pre></div>
<h3 id="bzoj2100usaco2010-decapple-delivery2016.8.24">bzoj2100[Usaco2010 Dec]Apple Delivery*（2016.8.24）</h3>
<h4 id="题意-63">题意</h4>
<p>无向图，从源点出发，去两个地方，问最短路径是多少。两个地方去的先后没有要求，且从一个地方到另一个地方不用经过源点。点数≤100000。</p>
<h4 id="题解-63">题解</h4>
<p>求源点对所有点的最短路和一个地方到所有点的最短路，比较一下即可。听说本题需要用队列优化的spfa或dijkstra才能过，本弱写了dijkstra（反正STL优先队列不要钱）。</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb65-3"><a href="#cb65-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb65-4"><a href="#cb65-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb65-5"><a href="#cb65-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb65-6"><a href="#cb65-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb65-7"><a href="#cb65-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb65-8"><a href="#cb65-8"></a></span>
<span id="cb65-9"><a href="#cb65-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb65-10"><a href="#cb65-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb65-11"><a href="#cb65-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb65-12"><a href="#cb65-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb65-13"><a href="#cb65-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb65-14"><a href="#cb65-14"></a>}</span>
<span id="cb65-15"><a href="#cb65-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; e es[maxn*<span class="dv">4</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb65-16"><a href="#cb65-16"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){</span>
<span id="cb65-17"><a href="#cb65-17"></a>    es[++ess]=(e){t,w,g[f]}; g[f]=ess;</span>
<span id="cb65-18"><a href="#cb65-18"></a>    es[++ess]=(e){f,w,g[t]}; g[t]=ess;</span>
<span id="cb65-19"><a href="#cb65-19"></a>}</span>
<span id="cb65-20"><a href="#cb65-20"></a><span class="kw">struct</span> nd{</span>
<span id="cb65-21"><a href="#cb65-21"></a>    <span class="dt">int</span> d,u;</span>
<span id="cb65-22"><a href="#cb65-22"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd &amp;a)<span class="at">const</span>{<span class="cf">return</span> d&gt;a.d;}</span>
<span id="cb65-23"><a href="#cb65-23"></a>};</span>
<span id="cb65-24"><a href="#cb65-24"></a>priority_queue &lt;nd&gt; q; <span class="dt">int</span> d[maxn]; <span class="dt">bool</span> vis[maxn];</span>
<span id="cb65-25"><a href="#cb65-25"></a><span class="dt">void</span> dijkstra(<span class="dt">int</span> s){</span>
<span id="cb65-26"><a href="#cb65-26"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(d,-<span class="dv">1</span>,<span class="kw">sizeof</span>(d));</span>
<span id="cb65-27"><a href="#cb65-27"></a>    memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); d[s]=<span class="dv">0</span>; q.push((nd){<span class="dv">0</span>,s});</span>
<span id="cb65-28"><a href="#cb65-28"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb65-29"><a href="#cb65-29"></a>        <span class="dt">int</span> x=q.top().u; <span class="cf">while</span>(!q.empty()&amp;&amp;vis[x])q.pop(),x=q.top().u;</span>
<span id="cb65-30"><a href="#cb65-30"></a>        <span class="cf">if</span>(q.empty()&amp;&amp;vis[x])<span class="cf">break</span>; vis[x]=<span class="dv">1</span>;</span>
<span id="cb65-31"><a href="#cb65-31"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)</span>
<span id="cb65-32"><a href="#cb65-32"></a>            <span class="cf">if</span>(d[es[i].t]==-<span class="dv">1</span>||d[es[i].t]&gt;d[x]+es[i].w){</span>
<span id="cb65-33"><a href="#cb65-33"></a>                d[es[i].t]=d[x]+es[i].w;</span>
<span id="cb65-34"><a href="#cb65-34"></a>                q.push((nd){d[es[i].t],es[i].t});</span>
<span id="cb65-35"><a href="#cb65-35"></a>            }</span>
<span id="cb65-36"><a href="#cb65-36"></a>    }</span>
<span id="cb65-37"><a href="#cb65-37"></a>}</span>
<span id="cb65-38"><a href="#cb65-38"></a><span class="dt">int</span> p,c,pb,pa1,pa2,dis1,dis2,dis3;</span>
<span id="cb65-39"><a href="#cb65-39"></a><span class="dt">int</span> main(){</span>
<span id="cb65-40"><a href="#cb65-40"></a>    c=read(); p=read(); pb=read(); pa1=read(); pa2=read();</span>
<span id="cb65-41"><a href="#cb65-41"></a>    inc(i,<span class="dv">1</span>,c){<span class="dt">int</span> a=read(),b=read(),c=read(); pe(a,b,c);}</span>
<span id="cb65-42"><a href="#cb65-42"></a>    dijkstra(pb); dis1=d[pa1]; dis2=d[pa2]; dijkstra(pa1); dis3=d[pa2];</span>
<span id="cb65-43"><a href="#cb65-43"></a>    <span class="cf">if</span>(dis1&lt;dis2)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dis1+dis3);<span class="cf">else</span> printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dis2+dis3);</span>
<span id="cb65-44"><a href="#cb65-44"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb65-45"><a href="#cb65-45"></a>}</span></code></pre></div>
<h3 id="bzoj2102usaco2010-decthe-trough-game2016.8.24">bzoj2102[Usaco2010 Dec]The Trough Game*（2016.8.24）</h3>
<h4 id="题意-64">题意</h4>
<p>m个要求，每个要求由一个长度为n的01串和一个数组成，表示只有与给出的01串按位与后1的个数为给出数的01串满足要求。求满足所有要求的01串。m≤100，n≤20。</p>
<h4 id="题解-64">题解</h4>
<p>暴力枚举01串，我以为会超时，但没有。</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="pp">#define maxn </span><span class="dv">30</span></span>
<span id="cb66-5"><a href="#cb66-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb66-6"><a href="#cb66-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb66-7"><a href="#cb66-7"></a></span>
<span id="cb66-8"><a href="#cb66-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb66-9"><a href="#cb66-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb66-10"><a href="#cb66-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb66-11"><a href="#cb66-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb66-12"><a href="#cb66-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb66-13"><a href="#cb66-13"></a>}</span>
<span id="cb66-14"><a href="#cb66-14"></a><span class="dt">int</span> a[maxn*<span class="dv">10</span>][maxn]; <span class="dt">int</span> n,m,b[maxn*<span class="dv">10</span>],ans;</span>
<span id="cb66-15"><a href="#cb66-15"></a><span class="dt">bool</span> check(<span class="dt">int</span> x){</span>
<span id="cb66-16"><a href="#cb66-16"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb66-17"><a href="#cb66-17"></a>        <span class="dt">int</span> k=<span class="dv">0</span>; inc(j,<span class="dv">0</span>,n-<span class="dv">1</span>)<span class="cf">if</span>(x&amp;(a[i][j+<span class="dv">1</span>]&lt;&lt;j))k++;</span>
<span id="cb66-18"><a href="#cb66-18"></a>        <span class="cf">if</span>(k!=b[i])<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb66-19"><a href="#cb66-19"></a>    }</span>
<span id="cb66-20"><a href="#cb66-20"></a>    <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb66-21"><a href="#cb66-21"></a>}</span>
<span id="cb66-22"><a href="#cb66-22"></a><span class="dt">int</span> main(){</span>
<span id="cb66-23"><a href="#cb66-23"></a>    n=read(); m=read();</span>
<span id="cb66-24"><a href="#cb66-24"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb66-25"><a href="#cb66-25"></a>        <span class="dt">char</span> ch=getchar(); <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>)ch=getchar(); <span class="dt">int</span> j=<span class="dv">0</span>;</span>
<span id="cb66-26"><a href="#cb66-26"></a>        <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)a[i][++j]=ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb66-27"><a href="#cb66-27"></a>        b[i]=read();</span>
<span id="cb66-28"><a href="#cb66-28"></a>    }</span>
<span id="cb66-29"><a href="#cb66-29"></a>    ans=-<span class="dv">1</span>;</span>
<span id="cb66-30"><a href="#cb66-30"></a>    inc(i,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;n)-<span class="dv">1</span>){</span>
<span id="cb66-31"><a href="#cb66-31"></a>        <span class="cf">if</span>(check(i)){</span>
<span id="cb66-32"><a href="#cb66-32"></a>            <span class="cf">if</span>(ans!=-<span class="dv">1</span>){printf(<span class="st">&quot;NOT UNIQUE&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;}<span class="cf">else</span> ans=i;</span>
<span id="cb66-33"><a href="#cb66-33"></a>        }</span>
<span id="cb66-34"><a href="#cb66-34"></a>    }</span>
<span id="cb66-35"><a href="#cb66-35"></a>    <span class="cf">if</span>(ans==-<span class="dv">1</span>)printf(<span class="st">&quot;IMPOSSIBLE&quot;</span>);<span class="cf">else</span>{</span>
<span id="cb66-36"><a href="#cb66-36"></a>        inc(i,<span class="dv">0</span>,n-<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans&amp;(<span class="dv">1</span>&lt;&lt;i)?<span class="dv">1</span>:<span class="dv">0</span>);</span>
<span id="cb66-37"><a href="#cb66-37"></a>    }</span>
<span id="cb66-38"><a href="#cb66-38"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb66-39"><a href="#cb66-39"></a>}</span></code></pre></div>
<h3 id="bzoj3448usaco2014-febauto-complete2016.8.24">bzoj3448[Usaco2014 Feb]Auto-complete*（2016.8.24）</h3>
<h4 id="题意-65">题意</h4>
<p>给个字符串集，询问字符串集中以字符串s为前缀的第k小字符串编号多少。字符串集总长度≤3000000，询问数≤1000，询问字符串长度≤1000。</p>
<h4 id="题解-65">题解</h4>
<p>先吐槽一下bzoj：自己加强了数据也不说一声，明明字符串集总长度不只1000000，不过我也不知道是不是3000000，反正2000000会RE。</p>
<p>一看到字符串集，以为是trie，结果又MLE又TLE，改左兄弟右儿子表示法又写炸。看题解trie求DFS序然后用主席树维护……天啊怎么银组题也这么劲QAQ。后来受神犇ccz教，原来只要先给字符串集排序，然后二分找区间就行了，usaco题解也是这样写的。写完了结果re无数次，本机测usaco数据什么事也没有，最后一怒之下数组开到3000000，过了~注意因为只给出字符串集总长度不知道字符串个数，所以字符串要用一个链表维护。（然而正常人都是用STLstring不会RE不说代码还比我少一半，我太弱了QAQ）</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb67-4"><a href="#cb67-4"></a><span class="pp">#define maxn </span><span class="dv">3000010</span></span>
<span id="cb67-5"><a href="#cb67-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb67-6"><a href="#cb67-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb67-7"><a href="#cb67-7"></a></span>
<span id="cb67-8"><a href="#cb67-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb67-9"><a href="#cb67-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb67-10"><a href="#cb67-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb67-11"><a href="#cb67-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb67-12"><a href="#cb67-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb67-13"><a href="#cb67-13"></a>}</span>
<span id="cb67-14"><a href="#cb67-14"></a><span class="kw">struct</span> hd{<span class="dt">int</span> nx,id;}; hd hds[maxn];</span>
<span id="cb67-15"><a href="#cb67-15"></a><span class="kw">struct</span> nd{<span class="dt">char</span> ch; <span class="dt">int</span> nx;}; nd nds[maxn]; <span class="dt">int</span> ndss;</span>
<span id="cb67-16"><a href="#cb67-16"></a><span class="dt">bool</span> cmp(hd a,hd b){</span>
<span id="cb67-17"><a href="#cb67-17"></a>    <span class="dt">int</span> j=a.nx,k=b.nx;</span>
<span id="cb67-18"><a href="#cb67-18"></a>    <span class="cf">while</span>(j&amp;&amp;k){</span>
<span id="cb67-19"><a href="#cb67-19"></a>        <span class="cf">if</span>(nds[j].ch&lt;nds[k].ch)<span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb67-20"><a href="#cb67-20"></a>        <span class="cf">if</span>(nds[j].ch&gt;nds[k].ch)<span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb67-21"><a href="#cb67-21"></a>        j=nds[j].nx; k=nds[k].nx;</span>
<span id="cb67-22"><a href="#cb67-22"></a>    }</span>
<span id="cb67-23"><a href="#cb67-23"></a>    <span class="cf">if</span>(!j&amp;&amp;!k)<span class="cf">return</span> a.id&lt;b.id;</span>
<span id="cb67-24"><a href="#cb67-24"></a>    <span class="cf">if</span>(!j)<span class="cf">return</span> <span class="dv">1</span>;<span class="cf">else</span> <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb67-25"><a href="#cb67-25"></a>}</span>
<span id="cb67-26"><a href="#cb67-26"></a><span class="dt">int</span> w,n; <span class="dt">char</span> str[maxn];</span>
<span id="cb67-27"><a href="#cb67-27"></a><span class="dt">int</span> check(<span class="dt">int</span> x){</span>
<span id="cb67-28"><a href="#cb67-28"></a>    x=hds[x].nx; <span class="dt">int</span> len=strlen(str+<span class="dv">1</span>);</span>
<span id="cb67-29"><a href="#cb67-29"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;i&lt;=len;i++,x=nds[x].nx){</span>
<span id="cb67-30"><a href="#cb67-30"></a>        <span class="cf">if</span>(!x||str[i]&gt;nds[x].ch)<span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb67-31"><a href="#cb67-31"></a>        <span class="cf">if</span>(str[i]&lt;nds[x].ch)<span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb67-32"><a href="#cb67-32"></a>    }</span>
<span id="cb67-33"><a href="#cb67-33"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb67-34"><a href="#cb67-34"></a>}</span>
<span id="cb67-35"><a href="#cb67-35"></a><span class="dt">int</span> main(){</span>
<span id="cb67-36"><a href="#cb67-36"></a>    w=read(); n=read();</span>
<span id="cb67-37"><a href="#cb67-37"></a>    inc(i,<span class="dv">1</span>,w){</span>
<span id="cb67-38"><a href="#cb67-38"></a>        <span class="dt">char</span> ch=getchar(); <span class="cf">while</span>(ch&lt;<span class="ch">&#39;a&#39;</span>||ch&gt;<span class="ch">&#39;z&#39;</span>)ch=getchar();</span>
<span id="cb67-39"><a href="#cb67-39"></a>        hds[i]=(hd){++ndss,i};</span>
<span id="cb67-40"><a href="#cb67-40"></a>        <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;a&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;z&#39;</span>)</span>
<span id="cb67-41"><a href="#cb67-41"></a>            nds[ndss]=(nd){ch,ndss+<span class="dv">1</span>},ndss++,ch=getchar();</span>
<span id="cb67-42"><a href="#cb67-42"></a>        nds[--ndss].nx=<span class="dv">0</span>;</span>
<span id="cb67-43"><a href="#cb67-43"></a>    }</span>
<span id="cb67-44"><a href="#cb67-44"></a>    sort(hds+<span class="dv">1</span>,hds+<span class="dv">1</span>+w,cmp);</span>
<span id="cb67-45"><a href="#cb67-45"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb67-46"><a href="#cb67-46"></a>        <span class="dt">int</span> k=read(); scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,str+<span class="dv">1</span>);</span>
<span id="cb67-47"><a href="#cb67-47"></a>        <span class="dt">int</span> q=-<span class="dv">1</span>,l=<span class="dv">1</span>,r=w;</span>
<span id="cb67-48"><a href="#cb67-48"></a>        <span class="cf">while</span>(l&lt;=r){</span>
<span id="cb67-49"><a href="#cb67-49"></a>            <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="dt">int</span> c=check(mid);</span>
<span id="cb67-50"><a href="#cb67-50"></a>            <span class="cf">if</span>(c==<span class="dv">0</span>)q=mid,r=mid-<span class="dv">1</span>;</span>
<span id="cb67-51"><a href="#cb67-51"></a>            <span class="cf">else</span> <span class="cf">if</span>(c==-<span class="dv">1</span>)r=mid-<span class="dv">1</span>;<span class="cf">else</span> l=mid+<span class="dv">1</span>;</span>
<span id="cb67-52"><a href="#cb67-52"></a>        }</span>
<span id="cb67-53"><a href="#cb67-53"></a>        <span class="cf">if</span>(q==-<span class="dv">1</span>||q+k-<span class="dv">1</span>&gt;w||check(q+k-<span class="dv">1</span>)!=<span class="dv">0</span>)printf(<span class="st">&quot;-1</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
<span id="cb67-54"><a href="#cb67-54"></a>        <span class="cf">else</span> printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,hds[q+k-<span class="dv">1</span>].id);</span>
<span id="cb67-55"><a href="#cb67-55"></a>    }</span>
<span id="cb67-56"><a href="#cb67-56"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb67-57"><a href="#cb67-57"></a>}</span></code></pre></div>
<h3 id="bzoj3943usaco2015-febsuperbull2016.8.25">bzoj3943[Usaco2015 Feb]SuperBull*（2016.8.25）</h3>
<h4 id="题意-66">题意</h4>
<p>n头牛进行锦标赛，每场比赛的好看程度是两头牛的编号异或和，并总有一方被淘汰。求安排比赛（可以决定比赛胜负）可以得到的最大总好看程度是多少。n≤2000</p>
<h4 id="题解-66">题解</h4>
<p>先求出牛两两之间的异或和，然后发现可以把比赛看做连边，且共有n-1场比赛，所以求最大生成树就行了。神犇们用的都是Prim，蒟蒻不会，用Kruscal结果时间排倒数。</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="pp">#define maxn </span><span class="dv">2010</span></span>
<span id="cb68-5"><a href="#cb68-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb68-6"><a href="#cb68-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb68-7"><a href="#cb68-7"></a></span>
<span id="cb68-8"><a href="#cb68-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb68-9"><a href="#cb68-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb68-10"><a href="#cb68-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb68-11"><a href="#cb68-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb68-12"><a href="#cb68-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb68-13"><a href="#cb68-13"></a>}</span>
<span id="cb68-14"><a href="#cb68-14"></a><span class="dt">int</span> a[maxn],fa[maxn],n,cnt; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb68-15"><a href="#cb68-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,w;}; e es[maxn*maxn]; <span class="dt">int</span> ess;</span>
<span id="cb68-16"><a href="#cb68-16"></a><span class="dt">bool</span> cmp(e a,e b){<span class="cf">return</span> a.w&gt;b.w;}</span>
<span id="cb68-17"><a href="#cb68-17"></a><span class="dt">int</span> find(<span class="dt">int</span> x){</span>
<span id="cb68-18"><a href="#cb68-18"></a>    <span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);</span>
<span id="cb68-19"><a href="#cb68-19"></a>}</span>
<span id="cb68-20"><a href="#cb68-20"></a><span class="dt">int</span> main(){</span>
<span id="cb68-21"><a href="#cb68-21"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(),fa[i]=i;</span>
<span id="cb68-22"><a href="#cb68-22"></a>    inc(i,<span class="dv">1</span>,n)inc(j,i+<span class="dv">1</span>,n)es[++ess]=(e){i,j,a[i]^a[j]};</span>
<span id="cb68-23"><a href="#cb68-23"></a>    sort(es+<span class="dv">1</span>,es+<span class="dv">1</span>+ess,cmp);</span>
<span id="cb68-24"><a href="#cb68-24"></a>    inc(i,<span class="dv">1</span>,ess){</span>
<span id="cb68-25"><a href="#cb68-25"></a>        <span class="dt">int</span> x=find(es[i].f),y=find(es[i].t);</span>
<span id="cb68-26"><a href="#cb68-26"></a>        <span class="cf">if</span>(x!=y)fa[x]=y,ans+=es[i].w,cnt++; <span class="cf">if</span>(cnt==n-<span class="dv">1</span>)<span class="cf">break</span>;</span>
<span id="cb68-27"><a href="#cb68-27"></a>    }</span>
<span id="cb68-28"><a href="#cb68-28"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb68-29"><a href="#cb68-29"></a>}</span></code></pre></div>
<h3 id="bzoj1629usaco2007-democow-acrobats2016.8.25">bzoj1629[Usaco2007 Demo]Cow Acrobats*（2016.8.25）</h3>
<h4 id="题意-67">题意</h4>
<p>n头牛，每天牛都有体重与力量值。它们玩叠罗汉的游戏，每个牛的危险值等于它上面的牛的体重总和减去它的力量值，求所有方案中危险值最大的最小。</p>
<h4 id="题解-67">题解</h4>
<p>贪心。第i头牛比第j头牛高当且仅当i的重量-j的力量&lt;j的重量-i的力量。</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb69-2"><a href="#cb69-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb69-3"><a href="#cb69-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb69-4"><a href="#cb69-4"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb69-5"><a href="#cb69-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb69-6"><a href="#cb69-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb69-7"><a href="#cb69-7"></a></span>
<span id="cb69-8"><a href="#cb69-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb69-9"><a href="#cb69-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb69-10"><a href="#cb69-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb69-11"><a href="#cb69-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb69-12"><a href="#cb69-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb69-13"><a href="#cb69-13"></a>}</span>
<span id="cb69-14"><a href="#cb69-14"></a><span class="kw">struct</span> nd{<span class="dt">int</span> a,b;}; nd nds[maxn]; <span class="dt">int</span> n,sm,mx;</span>
<span id="cb69-15"><a href="#cb69-15"></a><span class="dt">bool</span> cmp(nd a,nd b){<span class="cf">return</span> a.a-b.b&lt;b.a-a.b;}</span>
<span id="cb69-16"><a href="#cb69-16"></a><span class="dt">int</span> main(){</span>
<span id="cb69-17"><a href="#cb69-17"></a>    n=read(); inc(i,<span class="dv">1</span>,n)nds[i]=(nd){read(),read()}; sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+n,cmp); mx=-<span class="bn">0x3fffffff</span>;</span>
<span id="cb69-18"><a href="#cb69-18"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb69-19"><a href="#cb69-19"></a>        mx=max(mx,sm-nds[i].b); sm+=nds[i].a;</span>
<span id="cb69-20"><a href="#cb69-20"></a>    }</span>
<span id="cb69-21"><a href="#cb69-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,mx); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb69-22"><a href="#cb69-22"></a>}</span></code></pre></div>
<h3 id="bzoj1625usaco2007-dec宝石手镯2016.8.25">bzoj1625[Usaco2007 Dec]宝石手镯*（2016.8.25）</h3>
<h4 id="题意-68">题意</h4>
<p>n个宝石，每个有重量和价值，要挂一些在手镯上，求满足总质量不超过m的最大总价值。n≤3402，m≤12880</p>
<h4 id="题解-68">题解</h4>
<p>01背包。</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb70-2"><a href="#cb70-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb70-3"><a href="#cb70-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb70-5"><a href="#cb70-5"></a><span class="pp">#define dec</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&gt;=k;i--)</span>
<span id="cb70-6"><a href="#cb70-6"></a><span class="pp">#define maxn </span><span class="dv">50100</span></span>
<span id="cb70-7"><a href="#cb70-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb70-8"><a href="#cb70-8"></a></span>
<span id="cb70-9"><a href="#cb70-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb70-10"><a href="#cb70-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb70-11"><a href="#cb70-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb70-12"><a href="#cb70-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb70-13"><a href="#cb70-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb70-14"><a href="#cb70-14"></a>}</span>
<span id="cb70-15"><a href="#cb70-15"></a><span class="dt">int</span> n,m,f[maxn];</span>
<span id="cb70-16"><a href="#cb70-16"></a><span class="dt">int</span> main(){</span>
<span id="cb70-17"><a href="#cb70-17"></a>    n=read(); m=read();</span>
<span id="cb70-18"><a href="#cb70-18"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb70-19"><a href="#cb70-19"></a>        <span class="dt">int</span> a=read(),b=read(); dec(j,m,a)f[j]=max(f[j],f[j-a]+b);</span>
<span id="cb70-20"><a href="#cb70-20"></a>    }</span>
<span id="cb70-21"><a href="#cb70-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[m]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb70-22"><a href="#cb70-22"></a>}</span></code></pre></div>
<h3 id="bzoj3942usaco2015-febcensoring2016.8.25">bzoj3942[Usaco2015 Feb]Censoring*（2016.8.25）</h3>
<h4 id="题意-69">题意</h4>
<p>有一个S串和一个T串，不断地在S串里匹配T串，然后将其删除。S串、T串长度≤1000000。</p>
<h4 id="题解-69">题解</h4>
<p>用1、2两个栈，每次将S串的当前字符压入1栈，当前匹配到T串的位置压入2栈，如果匹配出一个T串，则让1、2栈中匹配T串的子串出栈，然后令当前匹配到T串的位置变为2栈顶的数，匹配过程可以用KMP加速。</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb71-2"><a href="#cb71-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb71-3"><a href="#cb71-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb71-4"><a href="#cb71-4"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb71-5"><a href="#cb71-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb71-6"><a href="#cb71-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb71-7"><a href="#cb71-7"></a></span>
<span id="cb71-8"><a href="#cb71-8"></a><span class="dt">char</span> s[maxn],t[maxn],st1[maxn]; <span class="dt">int</span> lens,lent,st2[maxn],top,fail[maxn];</span>
<span id="cb71-9"><a href="#cb71-9"></a><span class="dt">void</span> getfail(){</span>
<span id="cb71-10"><a href="#cb71-10"></a>    <span class="dt">int</span> j=<span class="dv">0</span>;</span>
<span id="cb71-11"><a href="#cb71-11"></a>    inc(i,<span class="dv">2</span>,lent){</span>
<span id="cb71-12"><a href="#cb71-12"></a>        <span class="cf">while</span>(j&amp;&amp;t[i]!=t[j+<span class="dv">1</span>])j=fail[j];</span>
<span id="cb71-13"><a href="#cb71-13"></a>        <span class="cf">if</span>(t[i]==t[j+<span class="dv">1</span>])j++; fail[i]=j;</span>
<span id="cb71-14"><a href="#cb71-14"></a>    }</span>
<span id="cb71-15"><a href="#cb71-15"></a>}</span>
<span id="cb71-16"><a href="#cb71-16"></a><span class="dt">int</span> main(){</span>
<span id="cb71-17"><a href="#cb71-17"></a>    <span class="dt">char</span> ch=getchar(); <span class="cf">while</span>(ch&lt;<span class="ch">&#39;a&#39;</span>||ch&gt;<span class="ch">&#39;z&#39;</span>)ch=getchar();</span>
<span id="cb71-18"><a href="#cb71-18"></a>    lens=<span class="dv">0</span>; <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;a&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;z&#39;</span>)s[++lens]=ch,ch=getchar();</span>
<span id="cb71-19"><a href="#cb71-19"></a>    ch=getchar(); <span class="cf">while</span>(ch&lt;<span class="ch">&#39;a&#39;</span>||ch&gt;<span class="ch">&#39;z&#39;</span>)ch=getchar();</span>
<span id="cb71-20"><a href="#cb71-20"></a>    lent=<span class="dv">0</span>; <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;a&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;z&#39;</span>)t[++lent]=ch,ch=getchar();</span>
<span id="cb71-21"><a href="#cb71-21"></a>    getfail(); <span class="dt">int</span> j=<span class="dv">0</span>,top=<span class="dv">0</span>;</span>
<span id="cb71-22"><a href="#cb71-22"></a>    inc(i,<span class="dv">1</span>,lens){</span>
<span id="cb71-23"><a href="#cb71-23"></a>        <span class="cf">while</span>(j&amp;&amp;s[i]!=t[j+<span class="dv">1</span>])j=fail[j]; <span class="cf">if</span>(s[i]==t[j+<span class="dv">1</span>])j++;</span>
<span id="cb71-24"><a href="#cb71-24"></a>        st1[++top]=s[i],st2[top]=j;</span>
<span id="cb71-25"><a href="#cb71-25"></a>        <span class="cf">if</span>(j==lent){<span class="cf">while</span>(j)top--,j--; j=st2[top];}</span>
<span id="cb71-26"><a href="#cb71-26"></a>    }</span>
<span id="cb71-27"><a href="#cb71-27"></a>    inc(i,<span class="dv">1</span>,top)printf(<span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span>,st1[i]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb71-28"><a href="#cb71-28"></a>}</span></code></pre></div>
<h3 id="bzoj2021usaco2010-jancheese-towers2016.8.28">bzoj2021[Usaco2010 Jan]Cheese Towers*（2016.8.28）</h3>
<h4 id="题意-70">题意</h4>
<p>John要建一个奶酪塔，高度最大为T。他有N种奶酪，每种无限个，第i种高度为Hi（一定是5的倍数），价值为Vi。一块高度&gt;=K的奶酪被称为大奶酪，一个奶酪如果在它上方有大奶酪（多块只算一次），它的高度就会变成原来的4/5。求最大价值。n≤100，t≤1000</p>
<h4 id="题解-70">题解</h4>
<p>可以枚举放哪个≥k的奶酪放在顶，其它奶酪高度变为4/5，做个完全背包。最后再算一个没有≥k的奶酪放在顶的最大价值，比较一下。注意被放在顶的奶酪可以再选，因为是每种奶酪无限个。</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb72-2"><a href="#cb72-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb72-3"><a href="#cb72-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb72-4"><a href="#cb72-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb72-5"><a href="#cb72-5"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb72-6"><a href="#cb72-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb72-7"><a href="#cb72-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb72-8"><a href="#cb72-8"></a></span>
<span id="cb72-9"><a href="#cb72-9"></a><span class="kw">struct</span> nd{<span class="dt">int</span> h,v;}nds[maxn];</span>
<span id="cb72-10"><a href="#cb72-10"></a><span class="dt">int</span> f[<span class="dv">2</span>][maxn*<span class="dv">10</span>],n,t,k,x,y,ans;</span>
<span id="cb72-11"><a href="#cb72-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb72-12"><a href="#cb72-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb72-13"><a href="#cb72-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb72-14"><a href="#cb72-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb72-15"><a href="#cb72-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb72-16"><a href="#cb72-16"></a>}</span>
<span id="cb72-17"><a href="#cb72-17"></a><span class="dt">int</span> main(){</span>
<span id="cb72-18"><a href="#cb72-18"></a>    n=read(); t=read(); k=read(); inc(i,<span class="dv">1</span>,n)nds[i].v=read(),nds[i].h=read();</span>
<span id="cb72-19"><a href="#cb72-19"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(nds[i].h&gt;=k&amp;&amp;t&gt;=nds[i].h){</span>
<span id="cb72-20"><a href="#cb72-20"></a>        x=<span class="dv">0</span>; y=<span class="dv">1</span>; memset(f,<span class="dv">0</span>,<span class="kw">sizeof</span>(f)); t-=nds[i].h;</span>
<span id="cb72-21"><a href="#cb72-21"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=n;j&gt;=<span class="dv">1</span>;j--){</span>
<span id="cb72-22"><a href="#cb72-22"></a>            <span class="cf">for</span>(<span class="dt">int</span> l=t;l&gt;=<span class="dv">0</span>;l--){</span>
<span id="cb72-23"><a href="#cb72-23"></a>                <span class="cf">if</span>(l+nds[j].h/<span class="dv">5</span>*<span class="dv">4</span>&gt;t)f[y][l]=f[x][l];<span class="cf">else</span> f[y][l]=max(f[y][l+nds[j].h/<span class="dv">5</span>*<span class="dv">4</span>]+nds[j].v,f[x][l]);</span>
<span id="cb72-24"><a href="#cb72-24"></a>            }</span>
<span id="cb72-25"><a href="#cb72-25"></a>            swap(x,y);</span>
<span id="cb72-26"><a href="#cb72-26"></a>        }</span>
<span id="cb72-27"><a href="#cb72-27"></a>        ans=max(ans,f[x][<span class="dv">0</span>]+nds[i].v); t+=nds[i].h;</span>
<span id="cb72-28"><a href="#cb72-28"></a>    }</span>
<span id="cb72-29"><a href="#cb72-29"></a>    x=<span class="dv">0</span>; y=<span class="dv">1</span>; memset(f,<span class="dv">0</span>,<span class="kw">sizeof</span>(f));</span>
<span id="cb72-30"><a href="#cb72-30"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--)<span class="cf">if</span>(nds[i].h&lt;k){</span>
<span id="cb72-31"><a href="#cb72-31"></a>        f[y][t]=<span class="dv">0</span>;</span>
<span id="cb72-32"><a href="#cb72-32"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=t;j&gt;=<span class="dv">0</span>;j--){</span>
<span id="cb72-33"><a href="#cb72-33"></a>            <span class="cf">if</span>(j+nds[i].h&gt;t)f[y][j]=f[x][j];<span class="cf">else</span> f[y][j]=max(f[y][j+nds[i].h]+nds[i].v,f[x][j]);</span>
<span id="cb72-34"><a href="#cb72-34"></a>        }</span>
<span id="cb72-35"><a href="#cb72-35"></a>        swap(x,y);</span>
<span id="cb72-36"><a href="#cb72-36"></a>    }</span>
<span id="cb72-37"><a href="#cb72-37"></a>    ans=max(ans,f[x][<span class="dv">0</span>]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb72-38"><a href="#cb72-38"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb72-39"><a href="#cb72-39"></a>}</span></code></pre></div>
<h3 id="bzoj3401usaco2009-marlook-up-仰望2016.8.29">bzoj3401[Usaco2009 Mar]Look Up 仰望*（2016.8.29）</h3>
<h4 id="题意-71">题意</h4>
<p>约翰的N头奶牛站成一排，奶牛i的身高是Hi。对于奶牛i，如果奶牛j满足i&lt;j且Hi&lt;Hj，我们可以说奶牛i可以仰望奶牛j。求出每只奶牛离她最近的仰望对象。n≤100000.</p>
<h4 id="题解-71">题解</h4>
<p>用一个单调栈维护即可。</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb73-2"><a href="#cb73-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb73-3"><a href="#cb73-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb73-4"><a href="#cb73-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb73-5"><a href="#cb73-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb73-6"><a href="#cb73-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb73-7"><a href="#cb73-7"></a></span>
<span id="cb73-8"><a href="#cb73-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb73-9"><a href="#cb73-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb73-10"><a href="#cb73-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb73-11"><a href="#cb73-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb73-12"><a href="#cb73-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb73-13"><a href="#cb73-13"></a>}</span>
<span id="cb73-14"><a href="#cb73-14"></a><span class="dt">int</span> n,a[maxn],top,s1[maxn],s2[maxn],ans[maxn];</span>
<span id="cb73-15"><a href="#cb73-15"></a><span class="dt">int</span> main(){</span>
<span id="cb73-16"><a href="#cb73-16"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); top=<span class="dv">1</span>; s1[<span class="dv">1</span>]=<span class="bn">0x3fffffff</span>; s2[<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb73-17"><a href="#cb73-17"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb73-18"><a href="#cb73-18"></a>        <span class="cf">while</span>(top&amp;&amp;a[i]&gt;=s1[top])top--; ans[i]=s2[top]; s1[++top]=a[i]; s2[top]=i;</span>
<span id="cb73-19"><a href="#cb73-19"></a>    }</span>
<span id="cb73-20"><a href="#cb73-20"></a>    inc(i,<span class="dv">1</span>,n)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans[i]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb73-21"><a href="#cb73-21"></a>}</span></code></pre></div>
<h3 id="bzoj2348baltic-2011plagiarism2016.8.29">bzoj2348[Baltic 2011]Plagiarism*（2016.8.29）</h3>
<h4 id="题意-72">题意</h4>
<p>n个数，如果其中两个数fi≤fj且fi≥0.9*fj，则它们要被比较。求多少对数要被比较。n≤100000。</p>
<h4 id="题解-72">题解</h4>
<p>排序然后双指针法。</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb74-3"><a href="#cb74-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb74-4"><a href="#cb74-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb74-5"><a href="#cb74-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb74-6"><a href="#cb74-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb74-7"><a href="#cb74-7"></a></span>
<span id="cb74-8"><a href="#cb74-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb74-9"><a href="#cb74-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb74-10"><a href="#cb74-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb74-11"><a href="#cb74-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb74-12"><a href="#cb74-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb74-13"><a href="#cb74-13"></a>}</span>
<span id="cb74-14"><a href="#cb74-14"></a><span class="dt">int</span> n,a[maxn],l,r; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb74-15"><a href="#cb74-15"></a><span class="dt">int</span> main(){</span>
<span id="cb74-16"><a href="#cb74-16"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); sort(a+<span class="dv">1</span>,a+n+<span class="dv">1</span>);</span>
<span id="cb74-17"><a href="#cb74-17"></a>    l=<span class="dv">1</span>; r=<span class="dv">1</span>;</span>
<span id="cb74-18"><a href="#cb74-18"></a>    <span class="cf">while</span>(r&lt;n){</span>
<span id="cb74-19"><a href="#cb74-19"></a>        r++; <span class="cf">while</span>(l&lt;r&amp;&amp;a[l]+<span class="fl">1e-8</span>&lt;a[r]*<span class="fl">0.9</span>)l++; ans+=r-l;</span>
<span id="cb74-20"><a href="#cb74-20"></a>    }</span>
<span id="cb74-21"><a href="#cb74-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb74-22"><a href="#cb74-22"></a>}</span></code></pre></div>
<h3 id="bzoj2096poi2010pilots2016.8.29">bzoj2096[Poi2010]Pilots*（2016.8.29）</h3>
<h4 id="题意-73">题意</h4>
<p>给一个序列和一个最大值，要求找一个最长连续子串，使里面任意两个数相差不超过这个最大值。序列大小≤3000000</p>
<h4 id="题解-73">题解</h4>
<p>用两个单调队列，分别维护当前区间的最大值和最小值，然后用双指针法。</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb75-2"><a href="#cb75-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb75-3"><a href="#cb75-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb75-4"><a href="#cb75-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb75-5"><a href="#cb75-5"></a><span class="pp">#define maxn </span><span class="dv">3000010</span></span>
<span id="cb75-6"><a href="#cb75-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb75-7"><a href="#cb75-7"></a></span>
<span id="cb75-8"><a href="#cb75-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb75-9"><a href="#cb75-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb75-10"><a href="#cb75-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb75-11"><a href="#cb75-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb75-12"><a href="#cb75-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb75-13"><a href="#cb75-13"></a>}</span>
<span id="cb75-14"><a href="#cb75-14"></a><span class="kw">struct</span> nd{<span class="dt">int</span> v,pos;};</span>
<span id="cb75-15"><a href="#cb75-15"></a><span class="dt">int</span> n,a[maxn],k,l,r,ans,ql1,qr1,ql2,qr2; nd q1[maxn],q2[maxn];</span>
<span id="cb75-16"><a href="#cb75-16"></a><span class="dt">int</span> main(){</span>
<span id="cb75-17"><a href="#cb75-17"></a>    k=read(); n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read();</span>
<span id="cb75-18"><a href="#cb75-18"></a>    l=<span class="dv">1</span>; r=<span class="dv">1</span>; ans=<span class="dv">1</span>; ql1=qr1=ql2=qr2=<span class="dv">1</span>; q1[<span class="dv">1</span>]=q2[<span class="dv">1</span>]=(nd){a[<span class="dv">1</span>],<span class="dv">1</span>};</span>
<span id="cb75-19"><a href="#cb75-19"></a>    <span class="cf">while</span>(r&lt;n){</span>
<span id="cb75-20"><a href="#cb75-20"></a>        r++;</span>
<span id="cb75-21"><a href="#cb75-21"></a>        <span class="cf">while</span>(ql1&lt;=qr1&amp;&amp;ql2&lt;=qr2&amp;&amp;a[r]-q1[ql1].v&gt;k){l++; <span class="cf">if</span>(l&gt;q1[ql1].pos)ql1++; <span class="cf">if</span>(l&gt;q2[ql2].pos)ql2++;}</span>
<span id="cb75-22"><a href="#cb75-22"></a>        <span class="cf">while</span>(ql1&lt;=qr1&amp;&amp;ql2&lt;=qr2&amp;&amp;q2[ql2].v-a[r]&gt;k){l++; <span class="cf">if</span>(l&gt;q1[ql1].pos)ql1++; <span class="cf">if</span>(l&gt;q2[ql2].pos)ql2++;}</span>
<span id="cb75-23"><a href="#cb75-23"></a>        ans=max(ans,r-l+<span class="dv">1</span>);</span>
<span id="cb75-24"><a href="#cb75-24"></a>        <span class="cf">while</span>(ql1&lt;=qr1&amp;&amp;a[r]&lt;=q1[qr1].v)qr1--; q1[++qr1]=(nd){a[r],r};</span>
<span id="cb75-25"><a href="#cb75-25"></a>        <span class="cf">while</span>(ql2&lt;=qr2&amp;&amp;a[r]&gt;=q2[qr2].v)qr2--; q2[++qr2]=(nd){a[r],r};</span>
<span id="cb75-26"><a href="#cb75-26"></a>    }</span>
<span id="cb75-27"><a href="#cb75-27"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb75-28"><a href="#cb75-28"></a>}</span></code></pre></div>
<h3 id="bzoj3714pa2014kuglarz2016.8.30">bzoj3714[PA2014]Kuglarz*（2016.8.30）</h3>
<h4 id="题意-74">题意</h4>
<p>n个杯子排成一行，花费c_ij元，可以知道杯子i,i+1,…,j底下藏有球的总数的奇偶性。求问至少需要花费多少元才能保证猜出哪些杯子底下藏着球。</p>
<h4 id="题解-74">题解</h4>
<p>令杯子1..i的和为sum[i]，那么当知道sum[i]和sum[i-1]即可推算出i下是否有球。故可以连边(i-1,j,c_ij)，然后求最小生成树即可。注意点数会变为n+1，因为0也是点。</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb76-2"><a href="#cb76-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb76-3"><a href="#cb76-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb76-4"><a href="#cb76-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb76-5"><a href="#cb76-5"></a><span class="pp">#define maxn </span><span class="dv">2010</span></span>
<span id="cb76-6"><a href="#cb76-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb76-7"><a href="#cb76-7"></a></span>
<span id="cb76-8"><a href="#cb76-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb76-9"><a href="#cb76-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb76-10"><a href="#cb76-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb76-11"><a href="#cb76-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb76-12"><a href="#cb76-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb76-13"><a href="#cb76-13"></a>}</span>
<span id="cb76-14"><a href="#cb76-14"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,w;}; e es[maxn*maxn]; <span class="dt">int</span> ess;</span>
<span id="cb76-15"><a href="#cb76-15"></a><span class="dt">bool</span> cmp(e a,e b){<span class="cf">return</span> a.w&lt;b.w;}</span>
<span id="cb76-16"><a href="#cb76-16"></a><span class="dt">int</span> n,fa[maxn],cnt; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb76-17"><a href="#cb76-17"></a><span class="dt">int</span> find(<span class="dt">int</span> x){</span>
<span id="cb76-18"><a href="#cb76-18"></a>    <span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);</span>
<span id="cb76-19"><a href="#cb76-19"></a>}</span>
<span id="cb76-20"><a href="#cb76-20"></a><span class="dt">int</span> main(){</span>
<span id="cb76-21"><a href="#cb76-21"></a>    n=read(); inc(i,<span class="dv">1</span>,n)inc(j,i,n){es[++ess]=(e){i-<span class="dv">1</span>,j,read()};}</span>
<span id="cb76-22"><a href="#cb76-22"></a>    sort(es+<span class="dv">1</span>,es+ess+<span class="dv">1</span>,cmp); inc(i,<span class="dv">1</span>,n)fa[i]=i;</span>
<span id="cb76-23"><a href="#cb76-23"></a>    inc(i,<span class="dv">1</span>,ess){</span>
<span id="cb76-24"><a href="#cb76-24"></a>        <span class="dt">int</span> x=find(es[i].f),y=find(es[i].t); <span class="cf">if</span>(x!=y)fa[x]=y,cnt++,ans+=es[i].w;</span>
<span id="cb76-25"><a href="#cb76-25"></a>        <span class="cf">if</span>(cnt==n)<span class="cf">break</span>;</span>
<span id="cb76-26"><a href="#cb76-26"></a>    }</span>
<span id="cb76-27"><a href="#cb76-27"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb76-28"><a href="#cb76-28"></a>}</span></code></pre></div>
<h3 id="bzoj2017usaco2009-nov硬币游戏2016.8.30">bzoj2017[Usaco2009 Nov]硬币游戏*（2016.8.30）</h3>
<h4 id="题意-75">题意</h4>
<p>初始时，一个有N枚硬币的堆栈放在地上，每枚硬币都有一个价值。开始玩游戏时，第一个玩家可以从堆顶拿走一枚或两枚硬币。之后每一轮中，当前的玩家至少拿走一枚硬币，至多拿走对手上一次所拿硬币数量的两倍。当没有硬币可拿时，游戏结束。 两个玩家都希望拿到最多钱数的硬币。求第一个玩家最多能拿多少钱。n≤2000。</p>
<h4 id="题解-75">题解</h4>
<p>首先有dp方程：f[i][j][0]=max(f[i][k][1]+sum(i-k,i)),1≤k≤min(j*2,i)，f[i][j][1]=min(f[i][k][0]),1≤k≤min(j*2,i)。</p>
<p>然而这样会超时。发现所以f[i][k][1]的最大值实际上是f[i][j*2][1]、f[i][j*2-1][1]、f[i][j-1][0]的最大值，f[i][k][0]的最小值也是f[i][j*2][0]、f[i][j*2-1][0]、f[i][j-1][1]的最小值。故可以把dp优化到O(n^2)可过。</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb77-3"><a href="#cb77-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb77-4"><a href="#cb77-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb77-5"><a href="#cb77-5"></a><span class="pp">#define maxn </span><span class="dv">2010</span></span>
<span id="cb77-6"><a href="#cb77-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb77-7"><a href="#cb77-7"></a></span>
<span id="cb77-8"><a href="#cb77-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb77-9"><a href="#cb77-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb77-10"><a href="#cb77-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb77-11"><a href="#cb77-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb77-12"><a href="#cb77-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb77-13"><a href="#cb77-13"></a>}</span>
<span id="cb77-14"><a href="#cb77-14"></a><span class="dt">int</span> a[maxn],sm[maxn],f[maxn][maxn][<span class="dv">2</span>],n;</span>
<span id="cb77-15"><a href="#cb77-15"></a><span class="dt">int</span> main(){</span>
<span id="cb77-16"><a href="#cb77-16"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--)sm[n-i+<span class="dv">1</span>]=sm[n-i]+a[i];</span>
<span id="cb77-17"><a href="#cb77-17"></a>    inc(i,<span class="dv">1</span>,n)</span>
<span id="cb77-18"><a href="#cb77-18"></a>        inc(j,<span class="dv">1</span>,n){</span>
<span id="cb77-19"><a href="#cb77-19"></a>            f[i][j][<span class="dv">0</span>]=j&gt;<span class="dv">1</span>?f[i][j-<span class="dv">1</span>][<span class="dv">0</span>]:<span class="dv">0</span>; <span class="dt">int</span> k;</span>
<span id="cb77-20"><a href="#cb77-20"></a>            k=<span class="dv">2</span>*j-<span class="dv">1</span>; <span class="cf">if</span>(k&lt;=i)f[i][j][<span class="dv">0</span>]=max(f[i][j][<span class="dv">0</span>],f[i-k][k][<span class="dv">1</span>]+sm[i]-sm[i-k]);</span>
<span id="cb77-21"><a href="#cb77-21"></a>            k=<span class="dv">2</span>*j;  <span class="cf">if</span>(k&lt;=i)f[i][j][<span class="dv">0</span>]=max(f[i][j][<span class="dv">0</span>],f[i-k][k][<span class="dv">1</span>]+sm[i]-sm[i-k]);</span>
<span id="cb77-22"><a href="#cb77-22"></a>            f[i][j][<span class="dv">1</span>]=j&gt;<span class="dv">1</span>?f[i][j-<span class="dv">1</span>][<span class="dv">1</span>]:<span class="bn">0x3fffffff</span>;</span>
<span id="cb77-23"><a href="#cb77-23"></a>            k=<span class="dv">2</span>*j-<span class="dv">1</span>; <span class="cf">if</span>(k&lt;=i)f[i][j][<span class="dv">1</span>]=min(f[i][j][<span class="dv">1</span>],f[i-k][k][<span class="dv">0</span>]);</span>
<span id="cb77-24"><a href="#cb77-24"></a>            k=<span class="dv">2</span>*j; <span class="cf">if</span>(k&lt;=i)f[i][j][<span class="dv">1</span>]=min(f[i][j][<span class="dv">1</span>],f[i-k][k][<span class="dv">0</span>]);</span>
<span id="cb77-25"><a href="#cb77-25"></a>        }</span>
<span id="cb77-26"><a href="#cb77-26"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[n][<span class="dv">1</span>][<span class="dv">0</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb77-27"><a href="#cb77-27"></a>}</span></code></pre></div>
<h3 id="bzoj3791作业2016.8.31">bzoj3791作业*（2016.8.31）</h3>
<h4 id="题意-76">题意</h4>
<p>对一个01序列进行染色，每次能将一个区间染上色（可覆盖之前染的），共能染k次，求最大正确染色个数。n≤100000，m≤50。</p>
<h4 id="题解-76">题解</h4>
<p>结论：染k次最多能把序列分成2*k-1段。故dp即可：</p>
<p>f[i][j][0]=max(f[i+1][j+1][1]+a[i]==1,f[i+1][j][0]+a[i]==0)</p>
<p>f[i][j][1]=max(f[i+1][j][1]+a[i]==1,f[i+1][j+1][0]+a[i]==0)</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb78-4"><a href="#cb78-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb78-5"><a href="#cb78-5"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb78-6"><a href="#cb78-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb78-7"><a href="#cb78-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb78-8"><a href="#cb78-8"></a></span>
<span id="cb78-9"><a href="#cb78-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb78-10"><a href="#cb78-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb78-11"><a href="#cb78-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb78-12"><a href="#cb78-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb78-13"><a href="#cb78-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb78-14"><a href="#cb78-14"></a>}</span>
<span id="cb78-15"><a href="#cb78-15"></a><span class="dt">int</span> n,f[<span class="dv">2</span>][maxn][<span class="dv">3</span>],k,x,y; <span class="dt">bool</span> a[maxn*<span class="dv">1000</span>];</span>
<span id="cb78-16"><a href="#cb78-16"></a><span class="dt">int</span> main(){</span>
<span id="cb78-17"><a href="#cb78-17"></a>    n=read(); k=<span class="dv">2</span>*read()-<span class="dv">1</span>; inc(i,<span class="dv">1</span>,n)a[i]=read(); x=<span class="dv">0</span>; y=<span class="dv">1</span>;</span>
<span id="cb78-18"><a href="#cb78-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb78-19"><a href="#cb78-19"></a>        f[x][k+<span class="dv">1</span>][<span class="dv">0</span>]=f[x][k+<span class="dv">1</span>][<span class="dv">1</span>]=-INF;</span>
<span id="cb78-20"><a href="#cb78-20"></a>        inc(j,<span class="dv">1</span>,k){</span>
<span id="cb78-21"><a href="#cb78-21"></a>            f[y][j][<span class="dv">0</span>]=max(f[x][j][<span class="dv">0</span>]+(a[i]==<span class="dv">0</span>),f[x][j+<span class="dv">1</span>][<span class="dv">1</span>]+(a[i]==<span class="dv">1</span>));</span>
<span id="cb78-22"><a href="#cb78-22"></a>            f[y][j][<span class="dv">1</span>]=max(f[x][j+<span class="dv">1</span>][<span class="dv">0</span>]+(a[i]==<span class="dv">0</span>),f[x][j][<span class="dv">1</span>]+(a[i]==<span class="dv">1</span>));</span>
<span id="cb78-23"><a href="#cb78-23"></a>        }</span>
<span id="cb78-24"><a href="#cb78-24"></a>        swap(x,y);</span>
<span id="cb78-25"><a href="#cb78-25"></a>    }</span>
<span id="cb78-26"><a href="#cb78-26"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,max(f[x][<span class="dv">1</span>][<span class="dv">0</span>],f[x][<span class="dv">1</span>][<span class="dv">1</span>])); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb78-27"><a href="#cb78-27"></a>}</span></code></pre></div>
<h3 id="bzoj1370baltic2003gang团伙2016.8.31">bzoj1370[Baltic2003]Gang团伙*（2016.8.31）</h3>
<h4 id="题意-77">题意</h4>
<p>n个人，任何两个认识的人不是朋友就是敌人，而且满足： 1、 我朋友的朋友是我的朋友； 2、 我敌人的敌人是我的朋友； 所有是朋友的人组成一个团伙。告诉你关于这n个人的m条信息，即某两个人是朋友，或者某两个人是敌人，求这个城市最多可能有多少个团伙。n≤1000，m≤5000。</p>
<h4 id="题解-77">题解</h4>
<p>每个点拆成两个。如果a和b是朋友，那么将a和b放入一个集合；如果是敌人，那么将a和b’放入一个集合以及a’和b放入一个集合，这样可以保证条件2。集合用并查集维护。</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb79-2"><a href="#cb79-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb79-3"><a href="#cb79-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb79-4"><a href="#cb79-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb79-5"><a href="#cb79-5"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb79-6"><a href="#cb79-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb79-7"><a href="#cb79-7"></a></span>
<span id="cb79-8"><a href="#cb79-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb79-9"><a href="#cb79-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb79-10"><a href="#cb79-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb79-11"><a href="#cb79-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb79-12"><a href="#cb79-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb79-13"><a href="#cb79-13"></a>}</span>
<span id="cb79-14"><a href="#cb79-14"></a><span class="dt">int</span> n,m,fa[maxn*<span class="dv">2</span>],vis[maxn*<span class="dv">2</span>],ans; <span class="dt">char</span> opt[<span class="dv">3</span>];</span>
<span id="cb79-15"><a href="#cb79-15"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb79-16"><a href="#cb79-16"></a><span class="dt">int</span> main(){</span>
<span id="cb79-17"><a href="#cb79-17"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,<span class="dv">2</span>*n)fa[i]=i;</span>
<span id="cb79-18"><a href="#cb79-18"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb79-19"><a href="#cb79-19"></a>        scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,opt); <span class="dt">int</span> xx=read(),yy=read();</span>
<span id="cb79-20"><a href="#cb79-20"></a>        <span class="cf">if</span>(opt[<span class="dv">0</span>]==<span class="ch">&#39;F&#39;</span>){</span>
<span id="cb79-21"><a href="#cb79-21"></a>            <span class="dt">int</span> x=find(xx),y=find(yy); fa[x]=y;</span>
<span id="cb79-22"><a href="#cb79-22"></a>        }<span class="cf">else</span>{</span>
<span id="cb79-23"><a href="#cb79-23"></a>            <span class="dt">int</span> x=find(xx),y=find(yy+n); fa[x]=y;</span>
<span id="cb79-24"><a href="#cb79-24"></a>            x=find(xx+n),y=find(yy); fa[x]=y;</span>
<span id="cb79-25"><a href="#cb79-25"></a>        }</span>
<span id="cb79-26"><a href="#cb79-26"></a>    }</span>
<span id="cb79-27"><a href="#cb79-27"></a>    inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=find(i); <span class="cf">if</span>(!vis[x])ans++,vis[x]=<span class="dv">1</span>;}</span>
<span id="cb79-28"><a href="#cb79-28"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb79-29"><a href="#cb79-29"></a>}</span></code></pre></div>
<h3 id="bzoj1116poi2008clo2016.8.31">bzoj1116[POI2008]CLO*（2016.8.31）</h3>
<h4 id="题意-78">题意</h4>
<p>n点m边双向图，问能否将一些边变成单向使得每个点只有一个入度。n≤100000，m≤200000。</p>
<h4 id="题解-78">题解</h4>
<p>结论：当图中每个点都与至少一个环相连时满足条件。故用并查集不断加边，如果两个顶点已在一个集合中，则将该集合根节点打标记，如果不在，若其中一个顶点所在集合被打了标记，则合并后的集合根节点也打标记。最后如果有集合没被打标记说明无法满足条件，否则可以满足。</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb80-2"><a href="#cb80-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb80-3"><a href="#cb80-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb80-4"><a href="#cb80-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb80-5"><a href="#cb80-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb80-6"><a href="#cb80-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb80-7"><a href="#cb80-7"></a></span>
<span id="cb80-8"><a href="#cb80-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb80-9"><a href="#cb80-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb80-10"><a href="#cb80-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb80-11"><a href="#cb80-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb80-12"><a href="#cb80-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb80-13"><a href="#cb80-13"></a>}</span>
<span id="cb80-14"><a href="#cb80-14"></a><span class="dt">int</span> n,m,fa[maxn],vis[maxn];</span>
<span id="cb80-15"><a href="#cb80-15"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb80-16"><a href="#cb80-16"></a><span class="dt">int</span> main(){</span>
<span id="cb80-17"><a href="#cb80-17"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)fa[i]=i;</span>
<span id="cb80-18"><a href="#cb80-18"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb80-19"><a href="#cb80-19"></a>        <span class="dt">int</span> x=find(read()),y=find(read());</span>
<span id="cb80-20"><a href="#cb80-20"></a>        <span class="cf">if</span>(x==y)vis[x]=<span class="dv">1</span>;<span class="cf">else</span>{</span>
<span id="cb80-21"><a href="#cb80-21"></a>            fa[x]=y; vis[y]|=vis[x];</span>
<span id="cb80-22"><a href="#cb80-22"></a>        }</span>
<span id="cb80-23"><a href="#cb80-23"></a>    }</span>
<span id="cb80-24"><a href="#cb80-24"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!vis[find(i)]){puts(<span class="st">&quot;NIE&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb80-25"><a href="#cb80-25"></a>    puts(<span class="st">&quot;TAK&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb80-26"><a href="#cb80-26"></a>}</span></code></pre></div>
<h3 id="bzoj1015jsoi2008星球大战starwar2016.8.31">bzoj1015[JSOI2008]星球大战starwar（2016.8.31）</h3>
<h4 id="题意-79">题意</h4>
<p>给个无向图和一个删点序列。求每次删完一个点后（将该点所连所有边也删掉）剩余联通块个数。点数≤400000。</p>
<h4 id="题解-79">题解</h4>
<p>离线，先将所有点删掉，然后将剩余的边两端点合并入一个联通块，接着按删点序列倒序加点，将删掉的边加下去，把加入的边两端点合并入一个联通块。注意每次加点总点数要加一。</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb81-3"><a href="#cb81-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb81-4"><a href="#cb81-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb81-5"><a href="#cb81-5"></a><span class="pp">#define maxn </span><span class="dv">400010</span></span>
<span id="cb81-6"><a href="#cb81-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb81-7"><a href="#cb81-7"></a></span>
<span id="cb81-8"><a href="#cb81-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb81-9"><a href="#cb81-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb81-10"><a href="#cb81-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb81-11"><a href="#cb81-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb81-12"><a href="#cb81-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb81-13"><a href="#cb81-13"></a>}</span>
<span id="cb81-14"><a href="#cb81-14"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,n;}es[maxn]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb81-15"><a href="#cb81-15"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){</span>
<span id="cb81-16"><a href="#cb81-16"></a>    es[++ess]=(e){f,t,g[f]}; g[f]=ess; es[++ess]=(e){t,f,g[t]}; g[t]=ess;</span>
<span id="cb81-17"><a href="#cb81-17"></a>}</span>
<span id="cb81-18"><a href="#cb81-18"></a><span class="dt">int</span> n,m,fa[maxn],cnt,k,a[maxn],ans[maxn],del[maxn];</span>
<span id="cb81-19"><a href="#cb81-19"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb81-20"><a href="#cb81-20"></a><span class="dt">void</span> merge(<span class="dt">int</span> xx,<span class="dt">int</span> yy){<span class="dt">int</span> x=find(xx),y=find(yy); <span class="cf">if</span>(x!=y)fa[x]=y,cnt--;}</span>
<span id="cb81-21"><a href="#cb81-21"></a><span class="dt">int</span> main(){</span>
<span id="cb81-22"><a href="#cb81-22"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m)pe(read()+<span class="dv">1</span>,read()+<span class="dv">1</span>); k=read(); inc(i,<span class="dv">1</span>,k)del[a[i]=read()+<span class="dv">1</span>]=i;</span>
<span id="cb81-23"><a href="#cb81-23"></a>    inc(i,<span class="dv">1</span>,n)fa[i]=i; cnt=n-k;</span>
<span id="cb81-24"><a href="#cb81-24"></a>    inc(i,<span class="dv">1</span>,ess)<span class="cf">if</span>(!del[es[i].f]&amp;&amp;!del[es[i].t])merge(es[i].f,es[i].t); ans[k+<span class="dv">1</span>]=cnt;</span>
<span id="cb81-25"><a href="#cb81-25"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=k;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb81-26"><a href="#cb81-26"></a>        cnt++; <span class="cf">for</span>(<span class="dt">int</span> j=g[a[i]];j;j=es[j].n)<span class="cf">if</span>(del[es[j].t]&gt;i||!del[es[j].t])merge(a[i],es[j].t);</span>
<span id="cb81-27"><a href="#cb81-27"></a>        ans[i]=cnt;</span>
<span id="cb81-28"><a href="#cb81-28"></a>    }</span>
<span id="cb81-29"><a href="#cb81-29"></a>    inc(i,<span class="dv">1</span>,k+<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans[i]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb81-30"><a href="#cb81-30"></a>}</span></code></pre></div>
<h3 id="bzoj1754usaco2005-quabull-math2016.8.31">bzoj1754[Usaco2005 qua]Bull Math*（2016.8.31）</h3>
<h4 id="题意-80">题意</h4>
<p>求两个正整数的积，每个数≤40位。</p>
<h4 id="题解-80">题解</h4>
<p>为什么C++不能支持高精度呢……</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1"></a>a<span class="op">=</span><span class="bu">int</span>(<span class="bu">raw_input</span>())</span>
<span id="cb82-2"><a href="#cb82-2"></a>b<span class="op">=</span><span class="bu">int</span>(<span class="bu">raw_input</span>())</span>
<span id="cb82-3"><a href="#cb82-3"></a><span class="bu">print</span> a<span class="op">*</span>b</span></code></pre></div>
<footer>
    <hr>
    <center>
        Powered by <a href="https://github.com/ZimingYuan/Yblogs" target="_blank">Yblogs</a><br>
        字体：<a href="https://github.com/lxgw/LxgwWenKai" target="_blank">霞鹜文楷</a><br>
        转载请注明出处<br>
        © 2025 VnYzm的博客
    </center>
</footer>
</body>
</html>
