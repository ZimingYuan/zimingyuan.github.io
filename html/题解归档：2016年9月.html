<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="题解归档：2016年9月" />
  <meta name="keywords" content="" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 "LXGW Bright", Georgia, serif;
    --font-h: 1.4rem/1.5 "LXGW Bright", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" type="text/css" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkaibright/dist/LXGWBright-Regular/result.css"/>
  <title>题解归档：2016年9月</title>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">所有文章</a></li>
            <li><a href="/technique.html">技术</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li><a href="/friends.html">友链</a></li>
            <li><a href="/html/关于.html">关于</a></li>
            <li><a href="https://www.travellings.cn/go.html" target="_blank">开往</a></li>
            <li class="float-right sticky"><button style="margin: 0" onclick="search()">
              <svg width="1em" height="1em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M15.7955 15.8111L21 21M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>
            </button></li>
            <li class="float-right sticky"><input type="search" placeholder="搜索标题" style="margin: 0"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">题解归档：2016年9月</h1>
<hr>
</header>
<h3 id="bzoj3940usaco2015-febcensoring2016.9.1">bzoj3940[Usaco2015 Feb]Censoring*（2016.9.1）</h3>
<h4 id="题意">题意</h4>
<p>有一个S串和一大堆T串，不断地在S串里找最早出现的T串，然后将其删除。S串≤100000，T串总长度≤100000。</p>
<h4 id="题解">题解</h4>
<p>对所有T串建AC自动机，然后同bzoj3942。注意，本题的AC自动机必须利用所有fail函数建成一个大的状态图，否则会超时。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="dt">char</span> str[maxn],word[maxn],st1[maxn]; <span class="dt">int</span> ch[maxn][<span class="dv">26</span>],val[maxn],n,fail[maxn],top,pos,len,st2[maxn],tot;</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">inline</span> <span class="dt">void</span> insert(<span class="dt">char</span> *str){</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="dt">int</span> j=<span class="dv">0</span>,len=strlen(str+<span class="dv">1</span>);</span>
<span id="cb1-12"><a href="#cb1-12"></a>    inc(i,<span class="dv">1</span>,len){<span class="cf">if</span>(!ch[j][str[i]-<span class="ch">&#39;a&#39;</span>])ch[j][str[i]-<span class="ch">&#39;a&#39;</span>]=++tot; j=ch[j][str[i]-<span class="ch">&#39;a&#39;</span>];} val[j]=len;</span>
<span id="cb1-13"><a href="#cb1-13"></a>}</span>
<span id="cb1-14"><a href="#cb1-14"></a>queue &lt;<span class="dt">int</span>&gt; q;</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="dt">void</span> getfail(){</span>
<span id="cb1-16"><a href="#cb1-16"></a>    inc(i,<span class="dv">0</span>,<span class="dv">25</span>)<span class="cf">if</span>(ch[<span class="dv">0</span>][i])q.push(ch[<span class="dv">0</span>][i]);</span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb1-18"><a href="#cb1-18"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb1-19"><a href="#cb1-19"></a>        inc(i,<span class="dv">0</span>,<span class="dv">25</span>){</span>
<span id="cb1-20"><a href="#cb1-20"></a>            <span class="dt">int</span> j=ch[fail[x]][i];</span>
<span id="cb1-21"><a href="#cb1-21"></a>            <span class="cf">if</span>(ch[x][i]){fail[ch[x][i]]=j; q.push(ch[x][i]);}<span class="cf">else</span>{ch[x][i]=j;}</span>
<span id="cb1-22"><a href="#cb1-22"></a>        }</span>
<span id="cb1-23"><a href="#cb1-23"></a>    }</span>
<span id="cb1-24"><a href="#cb1-24"></a>}</span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="dt">int</span> main(){</span>
<span id="cb1-26"><a href="#cb1-26"></a>    scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,str+<span class="dv">1</span>); len=strlen(str+<span class="dv">1</span>); scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n);</span>
<span id="cb1-27"><a href="#cb1-27"></a>    inc(i,<span class="dv">1</span>,n){scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,word+<span class="dv">1</span>); insert(word);} getfail(); top=<span class="dv">0</span>; pos=<span class="dv">0</span>;</span>
<span id="cb1-28"><a href="#cb1-28"></a>    inc(i,<span class="dv">1</span>,len){</span>
<span id="cb1-29"><a href="#cb1-29"></a>        st1[++top]=str[i]; pos=ch[pos][str[i]-<span class="ch">&#39;a&#39;</span>]; st2[top]=pos; <span class="cf">if</span>(val[pos])top-=val[pos],pos=st2[top];</span>
<span id="cb1-30"><a href="#cb1-30"></a>    }</span>
<span id="cb1-31"><a href="#cb1-31"></a>    inc(i,<span class="dv">1</span>,top)printf(<span class="st">&quot;</span><span class="sc">%c</span><span class="st">&quot;</span>,st1[i]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb1-32"><a href="#cb1-32"></a>}</span></code></pre></div>
<h3 id="bzoj2789poi2012letters2016.9.1">bzoj2789[Poi2012]Letters*（2016.9.1）</h3>
<h4 id="题意-1">题意</h4>
<h4 id="给出">给出</h4>
<h4 id="题解-1">题解</h4>
<p>把A串中所有字母替换成该字母在B串中的位置，如果有相同字母，则按从左到右的顺序一一对应，之后求逆序对个数即可。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="dt">char</span> a[maxn],b[maxn]; <span class="dt">int</span> n,p[maxn],id[maxn],sm[maxn]; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb2-11"><a href="#cb2-11"></a>queue &lt;<span class="dt">int</span>&gt; q[<span class="dv">26</span>];</span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="dt">int</span> query(<span class="dt">int</span> x){<span class="dt">int</span> q=<span class="dv">0</span>; <span class="cf">while</span>(x){q+=sm[x],x-=lb(x);} <span class="cf">return</span> q;}</span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="dt">void</span> add(<span class="dt">int</span> x,<span class="dt">int</span> v){<span class="cf">while</span>(x&lt;=n)sm[x]+=v,x+=lb(x);}</span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="dt">int</span> main(){</span>
<span id="cb2-15"><a href="#cb2-15"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,a+<span class="dv">1</span>); scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,b+<span class="dv">1</span>); inc(i,<span class="dv">1</span>,n)q[b[i]-<span class="ch">&#39;A&#39;</span>].push(i);</span>
<span id="cb2-16"><a href="#cb2-16"></a>    inc(i,<span class="dv">1</span>,n)p[i]=q[a[i]-<span class="ch">&#39;A&#39;</span>].front(),q[a[i]-<span class="ch">&#39;A&#39;</span>].pop(); inc(i,<span class="dv">1</span>,n)id[p[i]]=i;</span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--)ans+=query(id[i]-<span class="dv">1</span>),add(id[i],<span class="dv">1</span>); printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb2-18"><a href="#cb2-18"></a>}</span></code></pre></div>
<h3 id="bzoj1782usaco2010-febslowdown-慢慢游2016.9.2">bzoj1782[Usaco2010 Feb]slowdown 慢慢游*（2016.9.2）</h3>
<h4 id="题意-2">题意</h4>
<p>n只奶牛各有一个目的地。它们按顺序从根节点到达自己的目的地，如果当前奶牛经过了其它已经到达的奶牛的目的地，就要放慢一次脚步。求每只奶牛要放慢多少次脚步。n≤100000。</p>
<h4 id="题解-2">题解</h4>
<p>对树dfs，求每个节点的进栈时间和出栈时间，然后当每只奶牛到目的地时，将目的地的进栈时间对应数组元素+1，出栈时间对应数组元素-1。每只奶牛的放慢脚步次数就是它出发前它的目的地进栈时间对应数组元素的前缀和。这一过程用树状数组维护。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="pp">#define lb</span>(x)<span class="pp"> </span>x&amp;-x</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb3-13"><a href="#cb3-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb3-14"><a href="#cb3-14"></a>}</span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="dt">int</span> l[maxn],r[maxn],ho[maxn],sm[maxn*<span class="dv">2</span>],n,tot;</span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}; e es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;}</span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> fa){l[x]=++tot; <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa)dfs(es[i].t,x); r[x]=++tot;}</span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="dt">int</span> query(<span class="dt">int</span> x){<span class="dt">int</span> q=<span class="dv">0</span>; <span class="cf">while</span>(x)q+=sm[x],x-=lb(x); <span class="cf">return</span> q;}</span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="dt">void</span> add(<span class="dt">int</span> x,<span class="dt">int</span> v){<span class="cf">while</span>(x&lt;=tot)sm[x]+=v,x+=lb(x);}</span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="dt">int</span> main(){</span>
<span id="cb3-22"><a href="#cb3-22"></a>    n=read(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>)pe(read(),read()); inc(i,<span class="dv">1</span>,n)ho[i]=read(); dfs(<span class="dv">1</span>,<span class="dv">0</span>);</span>
<span id="cb3-23"><a href="#cb3-23"></a>    inc(i,<span class="dv">1</span>,n){printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query(l[ho[i]])); add(l[ho[i]],<span class="dv">1</span>); add(r[ho[i]],-<span class="dv">1</span>);} <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb3-24"><a href="#cb3-24"></a>}</span></code></pre></div>
<h3 id="bzoj3687简单题2016.9.2">bzoj3687简单题*（2016.9.2）</h3>
<h4 id="题意-3">题意</h4>
<p>给个集合，求所有子集的元素和的异或和。集合元素个数≤1000，整个集合的元素和≤2000000</p>
<h4 id="题解-3">题解</h4>
<p>用bitset维护每个子集元素和的个数是奇数还是偶数。每次读入一个元素，则bs^=bs&lt;&lt;a[i]，意思是将之前所有的子集和加上这个新的元素，然后与已有的子集和异或判断奇偶。最后ans为所有存在个数为奇数的子集和的异或和。注意本题数据有误，不能快速读入，必须用scanf否则会RE……</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="pp">#include </span><span class="im">&lt;bitset&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a>bitset&lt;<span class="dv">2000010</span>&gt;bs; <span class="dt">int</span> sm,ans,n;</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="dt">int</span> main(){</span>
<span id="cb4-10"><a href="#cb4-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); bs[<span class="dv">0</span>]=<span class="dv">1</span>; inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x); sm+=x; bs^=(bs&lt;&lt;x);}</span>
<span id="cb4-11"><a href="#cb4-11"></a>    inc(i,<span class="dv">1</span>,sm)<span class="cf">if</span>(bs[i])ans^=i; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb4-12"><a href="#cb4-12"></a>}</span></code></pre></div>
<h3 id="bzoj1150ctsc2007数据备份backup2016.9.2">bzoj1150[CTSC2007]数据备份Backup（2016.9.2）</h3>
<h4 id="题意-4">题意</h4>
<p>n个地方，在其中找k对地方，每个地方只属于一对。定义一对的费用为两个地方的距离，求最小费用总和。</p>
<h4 id="题解-4">题解</h4>
<p>把所有相邻地方距离放入一个集合中，每次取出最小的那个距离x，然后将相邻两边的距离l，r合并成l+r-x。如果这个x缺一边相邻，则将剩下那一边的距离去掉，如果缺两边相邻，则不用去掉。这个找相邻的过程用链表维护，同时找最小距离以及删距离的操作用set维护（好像也可以用手写堆，然而我不会）。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb5-14"><a href="#cb5-14"></a>}</span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="dt">int</span> n,k,a[maxn]; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="kw">struct</span> sn{</span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="dt">int</span> pos,v;</span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> sn &amp;x)<span class="at">const</span>{<span class="cf">return</span> v!=x.v?v&lt;x.v:pos&lt;x.pos;}</span>
<span id="cb5-19"><a href="#cb5-19"></a>};</span>
<span id="cb5-20"><a href="#cb5-20"></a>set&lt;sn&gt;s;</span>
<span id="cb5-21"><a href="#cb5-21"></a><span class="kw">struct</span> nd{<span class="dt">int</span> v,l,r;}; nd nds[maxn];</span>
<span id="cb5-22"><a href="#cb5-22"></a><span class="dt">int</span> main(){</span>
<span id="cb5-23"><a href="#cb5-23"></a>    n=read(); k=read(); <span class="dt">int</span> st=read(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> x=read(); a[i]=x-st; st=x;} n--;</span>
<span id="cb5-24"><a href="#cb5-24"></a>    inc(i,<span class="dv">1</span>,n){s.insert((sn){i,a[i]}); nds[i]=(nd){a[i],i-<span class="dv">1</span>,i+<span class="dv">1</span>&gt;n?<span class="dv">0</span>:i+<span class="dv">1</span>};}</span>
<span id="cb5-25"><a href="#cb5-25"></a>    inc(i,<span class="dv">1</span>,k){</span>
<span id="cb5-26"><a href="#cb5-26"></a>        set&lt;sn&gt;::iterator xx=s.begin(); <span class="dt">int</span> x=xx-&gt;pos; ans+=xx-&gt;v; s.erase(xx);</span>
<span id="cb5-27"><a href="#cb5-27"></a>        <span class="cf">if</span>(!nds[x].l&amp;&amp;!nds[x].r)<span class="cf">continue</span>;</span>
<span id="cb5-28"><a href="#cb5-28"></a>        <span class="cf">else</span> <span class="cf">if</span>(!nds[x].r){</span>
<span id="cb5-29"><a href="#cb5-29"></a>            xx=s.find((sn){nds[x].l,nds[nds[x].l].v}); s.erase(xx); nds[nds[nds[x].l].l].r=<span class="dv">0</span>;</span>
<span id="cb5-30"><a href="#cb5-30"></a>        }<span class="cf">else</span> <span class="cf">if</span>(!nds[x].l){</span>
<span id="cb5-31"><a href="#cb5-31"></a>            xx=s.find((sn){nds[x].r,nds[nds[x].r].v}); s.erase(xx); nds[nds[nds[x].r].r].l=<span class="dv">0</span>;</span>
<span id="cb5-32"><a href="#cb5-32"></a>        }<span class="cf">else</span>{</span>
<span id="cb5-33"><a href="#cb5-33"></a>            nds[x].v=nds[nds[x].l].v+nds[nds[x].r].v-nds[x].v;</span>
<span id="cb5-34"><a href="#cb5-34"></a>            xx=s.find((sn){nds[x].l,nds[nds[x].l].v}); s.erase(xx);</span>
<span id="cb5-35"><a href="#cb5-35"></a>            xx=s.find((sn){nds[x].r,nds[nds[x].r].v}); s.erase(xx);</span>
<span id="cb5-36"><a href="#cb5-36"></a>            s.insert((sn){x,nds[x].v});</span>
<span id="cb5-37"><a href="#cb5-37"></a>            nds[x].l=nds[nds[x].l].l; nds[x].r=nds[nds[x].r].r; nds[nds[x].l].r=x; nds[nds[x].r].l=x;</span>
<span id="cb5-38"><a href="#cb5-38"></a>        }</span>
<span id="cb5-39"><a href="#cb5-39"></a>    }</span>
<span id="cb5-40"><a href="#cb5-40"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb5-41"><a href="#cb5-41"></a>}</span></code></pre></div>
<h3 id="bzoj2288poj-challenge生日礼物2016.9.5">bzoj2288【POJ Challenge】生日礼物*（2016.9.5）</h3>
<h4 id="题意-5">题意</h4>
<p>给一个序列，求不超过m个连续的部分，使元素和最大。序列大小≤100000</p>
<h4 id="题解-5">题解</h4>
<p>先把连续的正数和负数合并起来，接着如果正数个数小于m则全选，否则需要确定去掉那个正数或合并哪个正数。初始ans设为所有正数和，将所有的数按绝对值大小放入堆中，然后重复m-正数个数操作：每次选取绝对值最小的数，如果是负数且它在边界处则重新选，否则将这个数删除并将两边的数合并，同时ans-=该数绝对值。该操作的意义在于：如果删去的是正数表示不选它，否则表示选这个负数以将左右的的正数合并起来。类似于1150，我用链表和STLset维护这个过程。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb6-14"><a href="#cb6-14"></a>}</span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="dt">int</span> n,m,a[maxn],b[maxn],tot,ans;</span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="kw">struct</span> sn{</span>
<span id="cb6-17"><a href="#cb6-17"></a>    <span class="dt">int</span> pos,v;</span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> sn &amp;x)<span class="at">const</span>{<span class="cf">return</span> v!=x.v?v&lt;x.v:pos&lt;x.pos;}</span>
<span id="cb6-19"><a href="#cb6-19"></a>};</span>
<span id="cb6-20"><a href="#cb6-20"></a>set&lt;sn&gt;s;</span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="kw">struct</span> nd{<span class="dt">int</span> v,l,r; <span class="dt">bool</span> bit;}; nd nds[maxn];</span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="dt">int</span> main(){</span>
<span id="cb6-23"><a href="#cb6-23"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)b[i]=read();</span>
<span id="cb6-24"><a href="#cb6-24"></a>    <span class="dt">int</span> last=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n){</span>
<span id="cb6-25"><a href="#cb6-25"></a>        <span class="cf">if</span>(b[i]==<span class="dv">0</span>)<span class="cf">continue</span>; <span class="cf">if</span>(!last||(last&gt;<span class="dv">0</span>^b[i]&gt;<span class="dv">0</span>))a[++tot]=b[i];<span class="cf">else</span> a[tot]+=b[i]; last=b[i];</span>
<span id="cb6-26"><a href="#cb6-26"></a>    }</span>
<span id="cb6-27"><a href="#cb6-27"></a>    n=tot; tot=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(a[i]&gt;<span class="dv">0</span>)tot++,ans+=a[i];</span>
<span id="cb6-28"><a href="#cb6-28"></a>    <span class="cf">if</span>(tot&gt;m){</span>
<span id="cb6-29"><a href="#cb6-29"></a>        inc(i,<span class="dv">1</span>,n){s.insert((sn){i,abs(a[i])}); nds[i]=(nd){abs(a[i]),i-<span class="dv">1</span>,i+<span class="dv">1</span>&gt;n?<span class="dv">0</span>:i+<span class="dv">1</span>,a[i]&gt;<span class="dv">0</span>};}</span>
<span id="cb6-30"><a href="#cb6-30"></a>        inc(i,<span class="dv">1</span>,tot-m){</span>
<span id="cb6-31"><a href="#cb6-31"></a>            set&lt;sn&gt;::iterator xx; <span class="dt">int</span> x;</span>
<span id="cb6-32"><a href="#cb6-32"></a>            <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb6-33"><a href="#cb6-33"></a>                xx=s.begin(); x=xx-&gt;pos; s.erase(xx);</span>
<span id="cb6-34"><a href="#cb6-34"></a>                <span class="cf">if</span>((!nds[x].l||!nds[x].r)&amp;&amp;!nds[x].bit){</span>
<span id="cb6-35"><a href="#cb6-35"></a>                    <span class="cf">if</span>(!nds[x].l)nds[nds[x].r].l=<span class="dv">0</span>; <span class="cf">if</span>(!nds[x].r)nds[nds[x].l].r=<span class="dv">0</span>;</span>
<span id="cb6-36"><a href="#cb6-36"></a>                }<span class="cf">else</span> <span class="cf">break</span>;</span>
<span id="cb6-37"><a href="#cb6-37"></a>            }</span>
<span id="cb6-38"><a href="#cb6-38"></a>            ans-=nds[x].v;</span>
<span id="cb6-39"><a href="#cb6-39"></a>            <span class="cf">if</span>(!nds[x].l&amp;&amp;!nds[x].r)<span class="cf">continue</span>;</span>
<span id="cb6-40"><a href="#cb6-40"></a>            <span class="cf">else</span> <span class="cf">if</span>(!nds[x].r)nds[nds[x].l].r=<span class="dv">0</span>;</span>
<span id="cb6-41"><a href="#cb6-41"></a>            <span class="cf">else</span> <span class="cf">if</span>(!nds[x].l)nds[nds[x].r].l=<span class="dv">0</span>;</span>
<span id="cb6-42"><a href="#cb6-42"></a>            <span class="cf">else</span>{</span>
<span id="cb6-43"><a href="#cb6-43"></a>                nds[x].v=nds[nds[x].l].v+nds[nds[x].r].v-nds[x].v; nds[x].bit=nds[nds[x].l].bit;</span>
<span id="cb6-44"><a href="#cb6-44"></a>                xx=s.find((sn){nds[x].l,nds[nds[x].l].v}); s.erase(xx);</span>
<span id="cb6-45"><a href="#cb6-45"></a>                xx=s.find((sn){nds[x].r,nds[nds[x].r].v}); s.erase(xx);</span>
<span id="cb6-46"><a href="#cb6-46"></a>                s.insert((sn){x,nds[x].v});</span>
<span id="cb6-47"><a href="#cb6-47"></a>                nds[x].l=nds[nds[x].l].l; nds[x].r=nds[nds[x].r].r; nds[nds[x].l].r=x; nds[nds[x].r].l=x;</span>
<span id="cb6-48"><a href="#cb6-48"></a>            }</span>
<span id="cb6-49"><a href="#cb6-49"></a>        }</span>
<span id="cb6-50"><a href="#cb6-50"></a>    }</span>
<span id="cb6-51"><a href="#cb6-51"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb6-52"><a href="#cb6-52"></a>}</span></code></pre></div>
<h3 id="bzoj2287poj-challenge消失之物2016.9.5">bzoj2287【POJ Challenge】消失之物*（2016.9.5）</h3>
<h4 id="题意-6">题意</h4>
<p>给出n，m，求用除了第i（1≤i≤n）个之外的物品填满容量为j（1≤j≤m）的背包的方法数。n，m≤2000。</p>
<h4 id="题解-6">题解</h4>
<p>令f[n][j]为所有物品可用填满j的方案数，F[i][j]为题目所求，则当j&lt;a[i]时F[i][j]=f[n][j]，否则F[i][j]=f[n][j]-F[i][j-a[i]]。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="pp">#define maxn </span><span class="dv">2001</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb7-10"><a href="#cb7-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb7-13"><a href="#cb7-13"></a>}</span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="dt">int</span> f[maxn],c[maxn][maxn],n,m,a[maxn];</span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="dt">int</span> main(){</span>
<span id="cb7-16"><a href="#cb7-16"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); f[<span class="dv">0</span>]=<span class="dv">1</span>;</span>
<span id="cb7-17"><a href="#cb7-17"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">for</span>(<span class="dt">int</span> j=m;j&gt;=a[i];j--)f[j]=(f[j]+f[j-a[i]])%<span class="dv">10</span>;</span>
<span id="cb7-18"><a href="#cb7-18"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb7-19"><a href="#cb7-19"></a>        c[i][<span class="dv">0</span>]=<span class="dv">1</span>;</span>
<span id="cb7-20"><a href="#cb7-20"></a>        inc(j,<span class="dv">1</span>,m){<span class="cf">if</span>(j&lt;a[i])c[i][j]=f[j];<span class="cf">else</span> c[i][j]=(f[j]+<span class="dv">10</span>-c[i][j-a[i]])%<span class="dv">10</span>; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,c[i][j]);}</span>
<span id="cb7-21"><a href="#cb7-21"></a>        puts(<span class="st">&quot;&quot;</span>);</span>
<span id="cb7-22"><a href="#cb7-22"></a>    }</span>
<span id="cb7-23"><a href="#cb7-23"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb7-24"><a href="#cb7-24"></a>}</span></code></pre></div>
<h3 id="bzoj2296poj-challenge随机种子2016.9.5">bzoj2296【POJ Challenge】随机种子*（2016.9.5）</h3>
<h4 id="题意-7">题意</h4>
<p>求一个≤10^16的数，使这个数包含123456789且为x的倍数。x≤1000000。</p>
<h4 id="题解-7">题解</h4>
<p>16-6刚好等于10。因此我们可以直接让所求的数的前10位为1234567890，则只要求出1234567890000000加上什么≤1000000的数可以为x的倍数即可，而这个可以很容易求出。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="at">const</span> <span class="dt">long</span> <span class="dt">long</span> a=<span class="dv">1</span><span class="bu">LL</span>*<span class="dv">1234567890</span>*<span class="dv">1000000</span>;</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="dt">int</span> t; <span class="dt">long</span> <span class="dt">long</span> b;</span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="dt">int</span> main(){</span>
<span id="cb8-10"><a href="#cb8-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;t); inc(i,<span class="dv">1</span>,t){scanf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,&amp;b); <span class="cf">if</span>(b)printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,a+b-a%b);<span class="cf">else</span> puts(<span class="st">&quot;-1&quot;</span>);} <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb8-11"><a href="#cb8-11"></a>}</span></code></pre></div>
<h3 id="bzoj2295poj-challenge我爱你啊2016.9.5">bzoj2295【POJ Challenge】我爱你啊*（2016.9.5）</h3>
<h4 id="题意-8">题意</h4>
<p>求一个字符串中有多少个“luvletter”（不包括引号）。字符串长度≤100000。</p>
<h4 id="题解-8">题解</h4>
<p>连kmp都不用……</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb9-7"><a href="#cb9-7"></a></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="dt">char</span> s[maxn]; <span class="dt">char</span> t[<span class="dv">20</span>]=<span class="st">&quot;luvletter&quot;</span>;</span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="dt">int</span> main(){</span>
<span id="cb9-10"><a href="#cb9-10"></a>    <span class="dt">int</span> T; scanf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,&amp;T);</span>
<span id="cb9-11"><a href="#cb9-11"></a>    inc(i,<span class="dv">1</span>,T){</span>
<span id="cb9-12"><a href="#cb9-12"></a>        fgets(s+<span class="dv">1</span>,maxn,stdin); <span class="dt">int</span> len=strlen(s+<span class="dv">1</span>),now=<span class="dv">0</span>,ans=<span class="dv">0</span>;</span>
<span id="cb9-13"><a href="#cb9-13"></a>        inc(i,<span class="dv">1</span>,len){<span class="cf">if</span>(s[i]==t[now])now++; <span class="cf">if</span>(now==<span class="dv">9</span>)ans++,now=<span class="dv">0</span>;} printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb9-14"><a href="#cb9-14"></a>    }</span>
<span id="cb9-15"><a href="#cb9-15"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb9-16"><a href="#cb9-16"></a>}</span></code></pre></div>
<h3 id="bzoj2292poj-challenge-永远挑战2016.9.5">bzoj2292【POJ Challenge 】永远挑战*（2016.9.5）</h3>
<h4 id="题意-9">题意</h4>
<p>有向图，每条边长度为1或2，求1到n最短路。点数≤100000，边数≤1000000。</p>
<h4 id="题解-9">题解</h4>
<p>有人说spfa会T，所以我用了dijkstra。不过这不是正解，神犇ZS告诉我正解应该是把所有边长度为2的边拆成两条，orz……</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb10-13"><a href="#cb10-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb10-15"><a href="#cb10-15"></a>}</span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="dt">int</span> n,m,d[maxn]; <span class="dt">bool</span> vis[maxn];</span>
<span id="cb10-17"><a href="#cb10-17"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}; e es[maxn*<span class="dv">10</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess;}</span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="kw">struct</span> hn{<span class="dt">int</span> u,w; <span class="dt">bool</span> <span class="kw">operator</span> &lt;(<span class="at">const</span> hn &amp;a)<span class="at">const</span>{<span class="cf">return</span> w&gt;a.w;}}; priority_queue&lt;hn&gt;q;</span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="dt">int</span> dijkstra(){</span>
<span id="cb10-21"><a href="#cb10-21"></a>    inc(i,<span class="dv">1</span>,n)d[i]=INF; d[<span class="dv">1</span>]=<span class="dv">0</span>; q.push((hn){<span class="dv">1</span>,<span class="dv">0</span>});</span>
<span id="cb10-22"><a href="#cb10-22"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb10-23"><a href="#cb10-23"></a>        <span class="dt">int</span> x=q.top().u; <span class="cf">while</span>(!q.empty()&amp;&amp;vis[x])q.pop(),x=q.top().u; <span class="cf">if</span>(q.empty()&amp;&amp;vis[x])<span class="cf">break</span>;</span>
<span id="cb10-24"><a href="#cb10-24"></a>        vis[x]=<span class="dv">1</span>; <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t]&gt;d[x]+es[i].w){</span>
<span id="cb10-25"><a href="#cb10-25"></a>            d[es[i].t]=d[x]+es[i].w; q.push((hn){es[i].t,d[es[i].t]});</span>
<span id="cb10-26"><a href="#cb10-26"></a>        }</span>
<span id="cb10-27"><a href="#cb10-27"></a>    }</span>
<span id="cb10-28"><a href="#cb10-28"></a>    <span class="cf">return</span> d[n];</span>
<span id="cb10-29"><a href="#cb10-29"></a>}</span>
<span id="cb10-30"><a href="#cb10-30"></a><span class="dt">int</span> main(){</span>
<span id="cb10-31"><a href="#cb10-31"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(),c=read(); pe(a,b,c);}</span>
<span id="cb10-32"><a href="#cb10-32"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dijkstra()); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb10-33"><a href="#cb10-33"></a>}</span></code></pre></div>
<h3 id="bzoj1941sdoi2010hide-and-seek2016.9.6">bzoj1941[Sdoi2010]Hide and Seek（2016.9.6）</h3>
<h4 id="题意-10">题意</h4>
<p>平面上n个点，求一个点使得离它最近的点和最远的点离它的曼哈顿距离差最小（若选的点处已有点，则改点不算）。n≤500000</p>
<h4 id="题解-10">题解</h4>
<p>第一次写kd树，感觉眼睛又瞎了（玄学复杂度）。首先先把所有点横坐标和纵坐标轮流为关键字排序建一个平衡树，维护每棵子树里的横纵坐标最大最小值。在树上查询时就启发式搜索，比如说正在查询里某点最远的点，则如果当前子树的横纵坐标最大最小值与某点的曼哈顿距离小于答案，就返回，否则对左右子树估价，那边越可能得到最优解就先往哪边走。这么暴力的操作，却可以证明，单次查询均摊复杂度为O(sqrt(n))。好神奇（不过常数应该不小）。</p>
<p>对应于本题，先将所有点建成kd树，然后有奇怪性质：所求点一定是这些点中的一个，所以枚举所有点，查询离这个点最远最近的点的与它的曼哈顿距离差，寻找最小的一个输出。估价函数具体见代码，注意求最远点和求最近点的估价函数不一样。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="pp">#define maxn </span><span class="dv">500010</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb11-13"><a href="#cb11-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb11-14"><a href="#cb11-14"></a>}</span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="dt">int</span> n,f,rt,mxans,mnans;</span>
<span id="cb11-16"><a href="#cb11-16"></a><span class="kw">struct</span> p{<span class="dt">int</span> pos[<span class="dv">2</span>]; <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> p &amp;a)<span class="at">const</span>{<span class="cf">return</span> pos[f]&lt;a.pos[f];}}ps[maxn];</span>
<span id="cb11-17"><a href="#cb11-17"></a><span class="kw">struct</span> nd{p pos; <span class="dt">int</span> mx[<span class="dv">2</span>],mn[<span class="dv">2</span>],lc,rc;}nds[maxn];</span>
<span id="cb11-18"><a href="#cb11-18"></a><span class="dt">int</span> dis(p a,p b){<span class="cf">return</span> abs(a.pos[<span class="dv">0</span>]-b.pos[<span class="dv">0</span>])+abs(a.pos[<span class="dv">1</span>]-b.pos[<span class="dv">1</span>]);}</span>
<span id="cb11-19"><a href="#cb11-19"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb11-20"><a href="#cb11-20"></a>    inc(i,<span class="dv">0</span>,<span class="dv">1</span>){</span>
<span id="cb11-21"><a href="#cb11-21"></a>        <span class="cf">if</span>(nds[x].lc)</span>
<span id="cb11-22"><a href="#cb11-22"></a>            nds[x].mx[i]=max(nds[x].mx[i],nds[nds[x].lc].mx[i]),</span>
<span id="cb11-23"><a href="#cb11-23"></a>            nds[x].mn[i]=min(nds[x].mn[i],nds[nds[x].lc].mn[i]);</span>
<span id="cb11-24"><a href="#cb11-24"></a>        <span class="cf">if</span>(nds[x].rc)</span>
<span id="cb11-25"><a href="#cb11-25"></a>            nds[x].mx[i]=max(nds[x].mx[i],nds[nds[x].rc].mx[i]),</span>
<span id="cb11-26"><a href="#cb11-26"></a>            nds[x].mn[i]=min(nds[x].mn[i],nds[nds[x].rc].mn[i]);</span>
<span id="cb11-27"><a href="#cb11-27"></a>    }</span>
<span id="cb11-28"><a href="#cb11-28"></a>}</span>
<span id="cb11-29"><a href="#cb11-29"></a><span class="dt">int</span> build(<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> now){</span>
<span id="cb11-30"><a href="#cb11-30"></a>    f=now; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; nth_element(ps+l,ps+mid,ps+r+<span class="dv">1</span>);</span>
<span id="cb11-31"><a href="#cb11-31"></a>    inc(i,<span class="dv">0</span>,<span class="dv">1</span>)nds[mid].mx[i]=nds[mid].mn[i]=ps[mid].pos[i]; nds[mid].pos=ps[mid];</span>
<span id="cb11-32"><a href="#cb11-32"></a>    <span class="cf">if</span>(l&lt;mid)nds[mid].lc=build(l,mid-<span class="dv">1</span>,now^<span class="dv">1</span>); <span class="cf">if</span>(mid&lt;r)nds[mid].rc=build(mid+<span class="dv">1</span>,r,now^<span class="dv">1</span>);</span>
<span id="cb11-33"><a href="#cb11-33"></a>    update(mid); <span class="cf">return</span> mid;</span>
<span id="cb11-34"><a href="#cb11-34"></a>}</span>
<span id="cb11-35"><a href="#cb11-35"></a><span class="dt">int</span> getmax(<span class="dt">int</span> x,p a){</span>
<span id="cb11-36"><a href="#cb11-36"></a>    <span class="dt">int</span> q=<span class="dv">0</span>; inc(i,<span class="dv">0</span>,<span class="dv">1</span>)q+=max(abs(a.pos[i]-nds[x].mx[i]),abs(a.pos[i]-nds[x].mn[i])); <span class="cf">return</span> q;</span>
<span id="cb11-37"><a href="#cb11-37"></a>}</span>
<span id="cb11-38"><a href="#cb11-38"></a><span class="dt">int</span> getmin(<span class="dt">int</span> x,p a){</span>
<span id="cb11-39"><a href="#cb11-39"></a>    <span class="dt">int</span> q=<span class="dv">0</span>; inc(i,<span class="dv">0</span>,<span class="dv">1</span>)q+=max(a.pos[i]-nds[x].mx[i],<span class="dv">0</span>),q+=max(nds[x].mn[i]-a.pos[i],<span class="dv">0</span>); <span class="cf">return</span> q;</span>
<span id="cb11-40"><a href="#cb11-40"></a>}</span>
<span id="cb11-41"><a href="#cb11-41"></a><span class="dt">void</span> querymax(<span class="dt">int</span> x,p a){</span>
<span id="cb11-42"><a href="#cb11-42"></a>    mxans=max(mxans,dis(a,nds[x].pos)); <span class="dt">int</span> dl=<span class="dv">0</span>,dr=<span class="dv">0</span>;</span>
<span id="cb11-43"><a href="#cb11-43"></a>    <span class="cf">if</span>(nds[x].lc)dl=getmax(nds[x].lc,a); <span class="cf">if</span>(nds[x].rc)dr=getmax(nds[x].rc,a);</span>
<span id="cb11-44"><a href="#cb11-44"></a>    <span class="cf">if</span>(dl&gt;dr){</span>
<span id="cb11-45"><a href="#cb11-45"></a>        <span class="cf">if</span>(mxans&lt;dl)querymax(nds[x].lc,a); <span class="cf">if</span>(mxans&lt;dr)querymax(nds[x].rc,a);</span>
<span id="cb11-46"><a href="#cb11-46"></a>    }<span class="cf">else</span>{</span>
<span id="cb11-47"><a href="#cb11-47"></a>        <span class="cf">if</span>(mxans&lt;dr)querymax(nds[x].rc,a); <span class="cf">if</span>(mxans&lt;dl)querymax(nds[x].lc,a);</span>
<span id="cb11-48"><a href="#cb11-48"></a>    }</span>
<span id="cb11-49"><a href="#cb11-49"></a>}</span>
<span id="cb11-50"><a href="#cb11-50"></a><span class="dt">void</span> querymin(<span class="dt">int</span> x,p a){</span>
<span id="cb11-51"><a href="#cb11-51"></a>    <span class="cf">if</span>(dis(a,nds[x].pos))mnans=min(mnans,dis(a,nds[x].pos)); <span class="dt">int</span> dl=INF,dr=INF;</span>
<span id="cb11-52"><a href="#cb11-52"></a>    <span class="cf">if</span>(nds[x].lc)dl=getmin(nds[x].lc,a); <span class="cf">if</span>(nds[x].rc)dr=getmin(nds[x].rc,a);</span>
<span id="cb11-53"><a href="#cb11-53"></a>    <span class="cf">if</span>(dl&lt;dr){</span>
<span id="cb11-54"><a href="#cb11-54"></a>        <span class="cf">if</span>(mnans&gt;dl)querymin(nds[x].lc,a); <span class="cf">if</span>(mnans&gt;dr)querymin(nds[x].rc,a);</span>
<span id="cb11-55"><a href="#cb11-55"></a>    }<span class="cf">else</span>{</span>
<span id="cb11-56"><a href="#cb11-56"></a>        <span class="cf">if</span>(mnans&gt;dr)querymin(nds[x].rc,a); <span class="cf">if</span>(mnans&gt;dl)querymin(nds[x].lc,a);</span>
<span id="cb11-57"><a href="#cb11-57"></a>    }</span>
<span id="cb11-58"><a href="#cb11-58"></a>}</span>
<span id="cb11-59"><a href="#cb11-59"></a><span class="dt">int</span> query(p a){</span>
<span id="cb11-60"><a href="#cb11-60"></a>    mxans=<span class="dv">0</span>; querymax(rt,a); mnans=INF; querymin(rt,a); <span class="cf">return</span> mxans-mnans;</span>
<span id="cb11-61"><a href="#cb11-61"></a>}</span>
<span id="cb11-62"><a href="#cb11-62"></a><span class="dt">int</span> main(){</span>
<span id="cb11-63"><a href="#cb11-63"></a>    n=read(); inc(i,<span class="dv">1</span>,n)ps[i].pos[<span class="dv">0</span>]=read(),ps[i].pos[<span class="dv">1</span>]=read(); rt=build(<span class="dv">1</span>,n,<span class="dv">0</span>);</span>
<span id="cb11-64"><a href="#cb11-64"></a>    <span class="dt">int</span> ans=INF; inc(i,<span class="dv">1</span>,n)ans=min(ans,query(ps[i])); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb11-65"><a href="#cb11-65"></a>}</span></code></pre></div>
<h3 id="bzoj2648sjy摆棋子bzoj2716violet-3天使玩偶2016.9.6">bzoj2648SJY摆棋子&amp;bzoj2716[Violet 3]天使玩偶*（2016.9.6）</h3>
<h4 id="题意-11">题意</h4>
<p>棋盘上有n个棋子，现在有m个操作，一种是加棋子，一种是查询离某个点最近的棋子。n，m≤500000。</p>
<h4 id="题解-11">题解</h4>
<p>先将已有的棋子建kd树，然后加棋子就直接向kd树插入节点。因为本题数据弱，所以直接插节点不会T，如果是一些数据比较强的题目，需要在插入一定量节点后重构整棵树。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="pp">#define maxn </span><span class="dv">500010</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb12-8"><a href="#cb12-8"></a></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb12-11"><a href="#cb12-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb12-12"><a href="#cb12-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb12-14"><a href="#cb12-14"></a>}</span>
<span id="cb12-15"><a href="#cb12-15"></a><span class="dt">int</span> n,m,f,rt,ans;</span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="kw">struct</span> p{<span class="dt">int</span> pos[<span class="dv">2</span>]; <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> p &amp;a)<span class="at">const</span>{<span class="cf">return</span> pos[f]&lt;a.pos[f];}}ps[maxn];</span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="kw">struct</span> nd{p pos; <span class="dt">int</span> mx[<span class="dv">2</span>],mn[<span class="dv">2</span>],lc,rc;}nds[maxn*<span class="dv">2</span>];</span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="dt">int</span> dis(p a,p b){<span class="cf">return</span> abs(a.pos[<span class="dv">0</span>]-b.pos[<span class="dv">0</span>])+abs(a.pos[<span class="dv">1</span>]-b.pos[<span class="dv">1</span>]);}</span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb12-20"><a href="#cb12-20"></a>    inc(i,<span class="dv">0</span>,<span class="dv">1</span>){</span>
<span id="cb12-21"><a href="#cb12-21"></a>        <span class="cf">if</span>(nds[x].lc)</span>
<span id="cb12-22"><a href="#cb12-22"></a>            nds[x].mx[i]=max(nds[x].mx[i],nds[nds[x].lc].mx[i]),</span>
<span id="cb12-23"><a href="#cb12-23"></a>            nds[x].mn[i]=min(nds[x].mn[i],nds[nds[x].lc].mn[i]);</span>
<span id="cb12-24"><a href="#cb12-24"></a>        <span class="cf">if</span>(nds[x].rc)</span>
<span id="cb12-25"><a href="#cb12-25"></a>            nds[x].mx[i]=max(nds[x].mx[i],nds[nds[x].rc].mx[i]),</span>
<span id="cb12-26"><a href="#cb12-26"></a>            nds[x].mn[i]=min(nds[x].mn[i],nds[nds[x].rc].mn[i]);</span>
<span id="cb12-27"><a href="#cb12-27"></a>    }</span>
<span id="cb12-28"><a href="#cb12-28"></a>}</span>
<span id="cb12-29"><a href="#cb12-29"></a><span class="dt">int</span> build(<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> now){</span>
<span id="cb12-30"><a href="#cb12-30"></a>    f=now; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; nth_element(ps+l,ps+mid,ps+r+<span class="dv">1</span>);</span>
<span id="cb12-31"><a href="#cb12-31"></a>    inc(i,<span class="dv">0</span>,<span class="dv">1</span>)nds[mid].mx[i]=nds[mid].mn[i]=ps[mid].pos[i]; nds[mid].pos=ps[mid];</span>
<span id="cb12-32"><a href="#cb12-32"></a>    <span class="cf">if</span>(l&lt;mid)nds[mid].lc=build(l,mid-<span class="dv">1</span>,now^<span class="dv">1</span>); <span class="cf">if</span>(mid&lt;r)nds[mid].rc=build(mid+<span class="dv">1</span>,r,now^<span class="dv">1</span>);</span>
<span id="cb12-33"><a href="#cb12-33"></a>    update(mid); <span class="cf">return</span> mid;</span>
<span id="cb12-34"><a href="#cb12-34"></a>}</span>
<span id="cb12-35"><a href="#cb12-35"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;x,p a,<span class="dt">int</span> now){</span>
<span id="cb12-36"><a href="#cb12-36"></a>    <span class="cf">if</span>(!x){x=++n; inc(i,<span class="dv">0</span>,<span class="dv">1</span>)nds[x].mx[i]=nds[x].mn[i]=a.pos[i]; nds[x].pos=a; <span class="cf">return</span>;}</span>
<span id="cb12-37"><a href="#cb12-37"></a>    f=now; <span class="cf">if</span>(a&lt;nds[x].pos)insert(nds[x].lc,a,now^<span class="dv">1</span>);<span class="cf">else</span> insert(nds[x].rc,a,now^<span class="dv">1</span>); update(x);</span>
<span id="cb12-38"><a href="#cb12-38"></a>}</span>
<span id="cb12-39"><a href="#cb12-39"></a><span class="dt">int</span> get(<span class="dt">int</span> x,p a){</span>
<span id="cb12-40"><a href="#cb12-40"></a>    <span class="dt">int</span> q=<span class="dv">0</span>; inc(i,<span class="dv">0</span>,<span class="dv">1</span>)q+=max(a.pos[i]-nds[x].mx[i],<span class="dv">0</span>),q+=max(nds[x].mn[i]-a.pos[i],<span class="dv">0</span>); <span class="cf">return</span> q;</span>
<span id="cb12-41"><a href="#cb12-41"></a>}</span>
<span id="cb12-42"><a href="#cb12-42"></a><span class="dt">void</span> query(<span class="dt">int</span> x,p a){</span>
<span id="cb12-43"><a href="#cb12-43"></a>    ans=min(ans,dis(a,nds[x].pos)); <span class="dt">int</span> dl=INF-<span class="dv">1</span>,dr=INF-<span class="dv">1</span>;</span>
<span id="cb12-44"><a href="#cb12-44"></a>    <span class="cf">if</span>(nds[x].lc)dl=get(nds[x].lc,a); <span class="cf">if</span>(nds[x].rc)dr=get(nds[x].rc,a);</span>
<span id="cb12-45"><a href="#cb12-45"></a>    <span class="cf">if</span>(dl&lt;dr){</span>
<span id="cb12-46"><a href="#cb12-46"></a>        <span class="cf">if</span>(ans&gt;dl)query(nds[x].lc,a); <span class="cf">if</span>(ans&gt;dr)query(nds[x].rc,a);</span>
<span id="cb12-47"><a href="#cb12-47"></a>    }<span class="cf">else</span>{</span>
<span id="cb12-48"><a href="#cb12-48"></a>        <span class="cf">if</span>(ans&gt;dr)query(nds[x].rc,a); <span class="cf">if</span>(ans&gt;dl)query(nds[x].lc,a);</span>
<span id="cb12-49"><a href="#cb12-49"></a>    }</span>
<span id="cb12-50"><a href="#cb12-50"></a>}</span>
<span id="cb12-51"><a href="#cb12-51"></a><span class="dt">int</span> main(){</span>
<span id="cb12-52"><a href="#cb12-52"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)ps[i].pos[<span class="dv">0</span>]=read(),ps[i].pos[<span class="dv">1</span>]=read(); rt=build(<span class="dv">1</span>,n,<span class="dv">0</span>);</span>
<span id="cb12-53"><a href="#cb12-53"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb12-54"><a href="#cb12-54"></a>        <span class="dt">int</span> t=read(),x=read(),y=read();</span>
<span id="cb12-55"><a href="#cb12-55"></a>        <span class="cf">if</span>(t==<span class="dv">1</span>)insert(rt,(p){x,y},<span class="dv">0</span>);<span class="cf">else</span> ans=INF,query(rt,(p){x,y}),printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb12-56"><a href="#cb12-56"></a>    }</span>
<span id="cb12-57"><a href="#cb12-57"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb12-58"><a href="#cb12-58"></a>}</span></code></pre></div>
<h3 id="bzoj2850巧克力王国2016.9.6">bzoj2850巧克力王国*（2016.9.6）</h3>
<h4 id="题意-12">题意</h4>
<p>n个巧克力，每个有牛奶含量，可可含量和美味值。m个人，每个有三个权值a，b，c，如果某个巧克力的牛奶含量*a+可可含量*b&lt;c就可以接受。问每个人能接受的巧克力美味值之和。n，m≤50000。</p>
<h4 id="题解-12">题解</h4>
<p>对所有巧克力建kd树，树上节点除了维护子树横纵坐标最大最小值还要维护子树美味值之和。在查询时如果估价得出这个子树的牛奶含量最大值乘a+可可含量最大值*b小于c则整棵子树都能接受，否则只要该子树可能有机会存在可接受巧克力就遍历这棵子树。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb13-10"><a href="#cb13-10"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb13-11"><a href="#cb13-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb13-12"><a href="#cb13-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb13-13"><a href="#cb13-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb13-14"><a href="#cb13-14"></a>}</span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="dt">int</span> n,m,f,rt; ll ans;</span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="kw">struct</span> p{<span class="dt">int</span> pos[<span class="dv">2</span>],v; <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> p &amp;a)<span class="at">const</span>{<span class="cf">return</span> pos[f]&lt;a.pos[f];}}ps[maxn];</span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="kw">struct</span> nd{p pos; <span class="dt">int</span> mx[<span class="dv">2</span>],mn[<span class="dv">2</span>],lc,rc; ll sm;}nds[maxn];</span>
<span id="cb13-18"><a href="#cb13-18"></a><span class="dt">bool</span> check(<span class="dt">int</span> a,<span class="dt">int</span> b,ll c,ll d,ll e){<span class="cf">return</span> c*a+d*b&lt;e;}</span>
<span id="cb13-19"><a href="#cb13-19"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb13-20"><a href="#cb13-20"></a>    inc(i,<span class="dv">0</span>,<span class="dv">1</span>){</span>
<span id="cb13-21"><a href="#cb13-21"></a>        <span class="cf">if</span>(nds[x].lc)</span>
<span id="cb13-22"><a href="#cb13-22"></a>            nds[x].mx[i]=max(nds[x].mx[i],nds[nds[x].lc].mx[i]),</span>
<span id="cb13-23"><a href="#cb13-23"></a>            nds[x].mn[i]=min(nds[x].mn[i],nds[nds[x].lc].mn[i]);</span>
<span id="cb13-24"><a href="#cb13-24"></a>        <span class="cf">if</span>(nds[x].rc)</span>
<span id="cb13-25"><a href="#cb13-25"></a>            nds[x].mx[i]=max(nds[x].mx[i],nds[nds[x].rc].mx[i]),</span>
<span id="cb13-26"><a href="#cb13-26"></a>            nds[x].mn[i]=min(nds[x].mn[i],nds[nds[x].rc].mn[i]);</span>
<span id="cb13-27"><a href="#cb13-27"></a>    }</span>
<span id="cb13-28"><a href="#cb13-28"></a>    <span class="cf">if</span>(nds[x].lc)nds[x].sm+=nds[nds[x].lc].sm;</span>
<span id="cb13-29"><a href="#cb13-29"></a>    <span class="cf">if</span>(nds[x].rc)nds[x].sm+=nds[nds[x].rc].sm;</span>
<span id="cb13-30"><a href="#cb13-30"></a>}</span>
<span id="cb13-31"><a href="#cb13-31"></a><span class="dt">int</span> build(<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> now){</span>
<span id="cb13-32"><a href="#cb13-32"></a>    f=now; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; nth_element(ps+l,ps+mid,ps+r+<span class="dv">1</span>);</span>
<span id="cb13-33"><a href="#cb13-33"></a>    inc(i,<span class="dv">0</span>,<span class="dv">1</span>)nds[mid].mx[i]=nds[mid].mn[i]=ps[mid].pos[i]; nds[mid].sm=ps[mid].v; nds[mid].pos=ps[mid];</span>
<span id="cb13-34"><a href="#cb13-34"></a>    <span class="cf">if</span>(l&lt;mid)nds[mid].lc=build(l,mid-<span class="dv">1</span>,now^<span class="dv">1</span>); <span class="cf">if</span>(mid&lt;r)nds[mid].rc=build(mid+<span class="dv">1</span>,r,now^<span class="dv">1</span>);</span>
<span id="cb13-35"><a href="#cb13-35"></a>    update(mid); <span class="cf">return</span> mid;</span>
<span id="cb13-36"><a href="#cb13-36"></a>}</span>
<span id="cb13-37"><a href="#cb13-37"></a><span class="dt">int</span> get(<span class="dt">int</span> x,ll a,ll b,ll c){</span>
<span id="cb13-38"><a href="#cb13-38"></a>    <span class="dt">int</span> q=<span class="dv">0</span>;</span>
<span id="cb13-39"><a href="#cb13-39"></a>    q+=check(nds[x].mx[<span class="dv">0</span>],nds[x].mx[<span class="dv">1</span>],a,b,c); q+=check(nds[x].mx[<span class="dv">0</span>],nds[x].mn[<span class="dv">1</span>],a,b,c);</span>
<span id="cb13-40"><a href="#cb13-40"></a>    q+=check(nds[x].mn[<span class="dv">0</span>],nds[x].mx[<span class="dv">1</span>],a,b,c); q+=check(nds[x].mn[<span class="dv">0</span>],nds[x].mn[<span class="dv">1</span>],a,b,c);</span>
<span id="cb13-41"><a href="#cb13-41"></a>    <span class="cf">return</span> q;</span>
<span id="cb13-42"><a href="#cb13-42"></a>}</span>
<span id="cb13-43"><a href="#cb13-43"></a><span class="dt">void</span> query(<span class="dt">int</span> x,ll a,ll b,ll c){</span>
<span id="cb13-44"><a href="#cb13-44"></a>    <span class="cf">if</span>(check(nds[x].pos.pos[<span class="dv">0</span>],nds[x].pos.pos[<span class="dv">1</span>],a,b,c))ans+=nds[x].pos.v; <span class="dt">int</span> dl=<span class="dv">0</span>,dr=<span class="dv">0</span>;</span>
<span id="cb13-45"><a href="#cb13-45"></a>    <span class="cf">if</span>(nds[x].lc)dl=get(nds[x].lc,a,b,c); <span class="cf">if</span>(nds[x].rc)dr=get(nds[x].rc,a,b,c);</span>
<span id="cb13-46"><a href="#cb13-46"></a>    <span class="cf">if</span>(dl==<span class="dv">4</span>)ans+=nds[nds[x].lc].sm;<span class="cf">else</span> <span class="cf">if</span>(dl)query(nds[x].lc,a,b,c);</span>
<span id="cb13-47"><a href="#cb13-47"></a>    <span class="cf">if</span>(dr==<span class="dv">4</span>)ans+=nds[nds[x].rc].sm;<span class="cf">else</span> <span class="cf">if</span>(dr)query(nds[x].rc,a,b,c);</span>
<span id="cb13-48"><a href="#cb13-48"></a>}</span>
<span id="cb13-49"><a href="#cb13-49"></a><span class="dt">int</span> main(){</span>
<span id="cb13-50"><a href="#cb13-50"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)ps[i].pos[<span class="dv">0</span>]=read(),ps[i].pos[<span class="dv">1</span>]=read(),ps[i].v=read(); rt=build(<span class="dv">1</span>,n,<span class="dv">0</span>);</span>
<span id="cb13-51"><a href="#cb13-51"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb13-52"><a href="#cb13-52"></a>        ll x=read(),y=read(),z=read(); ans=<span class="dv">0</span>; query(rt,x,y,z); printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb13-53"><a href="#cb13-53"></a>    }</span>
<span id="cb13-54"><a href="#cb13-54"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb13-55"><a href="#cb13-55"></a>}</span></code></pre></div>
<h3 id="bzoj3781小b的询问2016.9.6">bzoj3781小B的询问*（2016.9.6）</h3>
<h4 id="题意-13">题意</h4>
<p>给定一个长度为n的序列，序列里的数≤k，m个询问l,r：求<span class="math inline">\(\sum_{i=1}^k{c[i]^2}\)</span>，c[i]为i在[l,r]的出现次数。n，m，k≤50000。</p>
<h4 id="题解-13">题解</h4>
<p>莫队算法直接上。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb14-9"><a href="#cb14-9"></a></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb14-12"><a href="#cb14-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb14-13"><a href="#cb14-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb14-14"><a href="#cb14-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb14-15"><a href="#cb14-15"></a>}</span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="kw">struct</span> ask{<span class="dt">int</span> l,r,id;}asks[maxn]; <span class="dt">int</span> bel[maxn],n,sz,m,k,l,r; ll ans,a[maxn],c[maxn],p[maxn];</span>
<span id="cb14-17"><a href="#cb14-17"></a><span class="dt">bool</span> cmp(ask a,ask b){<span class="cf">return</span> bel[a.l]==bel[b.l]?a.r&lt;b.r:bel[a.l]&lt;bel[b.l];}</span>
<span id="cb14-18"><a href="#cb14-18"></a>ll sqr(ll a){<span class="cf">return</span> a*a;}</span>
<span id="cb14-19"><a href="#cb14-19"></a><span class="dt">int</span> main(){</span>
<span id="cb14-20"><a href="#cb14-20"></a>    n=read(); m=read(); k=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); sz=(<span class="dt">int</span>)sqrt(n);</span>
<span id="cb14-21"><a href="#cb14-21"></a>    inc(i,<span class="dv">1</span>,n)bel[i]=(i-<span class="dv">1</span>)/sz+<span class="dv">1</span>; inc(i,<span class="dv">1</span>,m)asks[i]=(ask){read(),read(),i};</span>
<span id="cb14-22"><a href="#cb14-22"></a>    sort(asks+<span class="dv">1</span>,asks+m+<span class="dv">1</span>,cmp); ans=<span class="dv">0</span>; l=<span class="dv">1</span>; r=<span class="dv">0</span>;</span>
<span id="cb14-23"><a href="#cb14-23"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb14-24"><a href="#cb14-24"></a>        <span class="cf">while</span>(asks[i].r&gt;r)r++,ans-=sqr(c[a[r]]),c[a[r]]++,ans+=sqr(c[a[r]]);</span>
<span id="cb14-25"><a href="#cb14-25"></a>        <span class="cf">while</span>(asks[i].l&lt;l)l--,ans-=sqr(c[a[l]]),c[a[l]]++,ans+=sqr(c[a[l]]);</span>
<span id="cb14-26"><a href="#cb14-26"></a>        <span class="cf">while</span>(asks[i].r&lt;r)ans-=sqr(c[a[r]]),c[a[r]]--,ans+=sqr(c[a[r]]),r--;</span>
<span id="cb14-27"><a href="#cb14-27"></a>        <span class="cf">while</span>(asks[i].l&gt;l)ans-=sqr(c[a[l]]),c[a[l]]--,ans+=sqr(c[a[l]]),l++;</span>
<span id="cb14-28"><a href="#cb14-28"></a>        p[asks[i].id]=ans;</span>
<span id="cb14-29"><a href="#cb14-29"></a>    }</span>
<span id="cb14-30"><a href="#cb14-30"></a>    inc(i,<span class="dv">1</span>,m)printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,p[i]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb14-31"><a href="#cb14-31"></a>}</span></code></pre></div>
<h3 id="bzoj1726usaco2006-novroadblocks第二短路2016.9.7">bzoj1726[Usaco2006 Nov]Roadblocks第二短路*（2016.9.7）</h3>
<h4 id="题意-14">题意</h4>
<p>求无向图点1到n的次短路（长度严格小于最短路）。点数≤5000，边数≤100000。</p>
<h4 id="题解-14">题解</h4>
<p>求源点为1的单源最短路和源点为n的单源最短路。然后枚举每个点，如果某点到点1和点n的距离和不等于1到n的最短路距离且最小则答案为它。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="pp">#define maxn </span><span class="dv">5010</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb15-9"><a href="#cb15-9"></a></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb15-11"><a href="#cb15-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb15-13"><a href="#cb15-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb15-14"><a href="#cb15-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb15-15"><a href="#cb15-15"></a>}</span>
<span id="cb15-16"><a href="#cb15-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,w,n;}es[maxn*<span class="dv">40</span>]; <span class="dt">int</span> g[maxn],ess,d[<span class="dv">2</span>][maxn],n,m; <span class="dt">bool</span> inq[maxn]; queue&lt;<span class="dt">int</span>&gt;q;</span>
<span id="cb15-17"><a href="#cb15-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){f,t,w,g[f]}; g[f]=ess; es[++ess]=(e){t,f,w,g[t]}; g[t]=ess;}</span>
<span id="cb15-18"><a href="#cb15-18"></a><span class="dt">void</span> spfa(<span class="dt">int</span> s,<span class="dt">bool</span> a){</span>
<span id="cb15-19"><a href="#cb15-19"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); inc(i,<span class="dv">1</span>,n)d[a][i]=INF;</span>
<span id="cb15-20"><a href="#cb15-20"></a>    q.push(s); inq[s]=<span class="dv">1</span>; d[a][s]=<span class="dv">0</span>;</span>
<span id="cb15-21"><a href="#cb15-21"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb15-22"><a href="#cb15-22"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb15-23"><a href="#cb15-23"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[a][es[i].t]&gt;d[a][x]+es[i].w){</span>
<span id="cb15-24"><a href="#cb15-24"></a>            d[a][es[i].t]=d[a][x]+es[i].w;</span>
<span id="cb15-25"><a href="#cb15-25"></a>            <span class="cf">if</span>(!inq[es[i].t])q.push(es[i].t),inq[es[i].t]=<span class="dv">1</span>;</span>
<span id="cb15-26"><a href="#cb15-26"></a>        }</span>
<span id="cb15-27"><a href="#cb15-27"></a>    }</span>
<span id="cb15-28"><a href="#cb15-28"></a>}</span>
<span id="cb15-29"><a href="#cb15-29"></a><span class="dt">int</span> main(){</span>
<span id="cb15-30"><a href="#cb15-30"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(),c=read(); pe(a,b,c);}</span>
<span id="cb15-31"><a href="#cb15-31"></a>    spfa(<span class="dv">1</span>,<span class="dv">0</span>); spfa(n,<span class="dv">1</span>); <span class="dt">int</span> mn=INF;</span>
<span id="cb15-32"><a href="#cb15-32"></a>    inc(i,<span class="dv">1</span>,ess){</span>
<span id="cb15-33"><a href="#cb15-33"></a>        <span class="cf">if</span>(d[<span class="dv">0</span>][es[i].f]+es[i].w+d[<span class="dv">1</span>][es[i].t]&lt;mn&amp;&amp;d[<span class="dv">0</span>][es[i].f]+es[i].w+d[<span class="dv">1</span>][es[i].t]!=d[<span class="dv">0</span>][n])</span>
<span id="cb15-34"><a href="#cb15-34"></a>            mn=d[<span class="dv">0</span>][es[i].f]+es[i].w+d[<span class="dv">1</span>][es[i].t];</span>
<span id="cb15-35"><a href="#cb15-35"></a>    }</span>
<span id="cb15-36"><a href="#cb15-36"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,mn); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb15-37"><a href="#cb15-37"></a>}</span></code></pre></div>
<h3 id="bzoj2060usaco2010-novvisiting-cows-拜访奶牛2016.9.7">bzoj2060[Usaco2010 Nov]Visiting Cows 拜访奶牛*（2016.9.7）</h3>
<h4 id="题意-15">题意</h4>
<p>给棵树，要求如果取了某个节点就不能取与它相邻的节点，问最多可取几个节点。树的大小≤50000。</p>
<h4 id="题解-15">题解</h4>
<p>树形dp。令f[i][0]不取i节点，f[i][1]为取i节点，则方程为f[i][0]=sum(max(f[j][0],f[j][1]+1)),f[i][1]=sum(f[j][0])，j为i的子节点。最后答案为max(f[1][0],f[1][1]+1)。注意不要漏了那个“+1”。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb16-12"><a href="#cb16-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb16-13"><a href="#cb16-13"></a>}</span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess,n,dp[maxn][<span class="dv">2</span>];</span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;}</span>
<span id="cb16-16"><a href="#cb16-16"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> fa){</span>
<span id="cb16-17"><a href="#cb16-17"></a>    dp[x][<span class="dv">0</span>]=dp[x][<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb16-18"><a href="#cb16-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa){</span>
<span id="cb16-19"><a href="#cb16-19"></a>        dfs(es[i].t,x); dp[x][<span class="dv">0</span>]+=max(dp[es[i].t][<span class="dv">1</span>]+<span class="dv">1</span>,dp[es[i].t][<span class="dv">0</span>]); dp[x][<span class="dv">1</span>]+=dp[es[i].t][<span class="dv">0</span>];</span>
<span id="cb16-20"><a href="#cb16-20"></a>    }</span>
<span id="cb16-21"><a href="#cb16-21"></a>}</span>
<span id="cb16-22"><a href="#cb16-22"></a><span class="dt">int</span> main(){</span>
<span id="cb16-23"><a href="#cb16-23"></a>    n=read(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a=read(),b=read(); pe(a,b);} dfs(<span class="dv">1</span>,<span class="dv">0</span>);</span>
<span id="cb16-24"><a href="#cb16-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,max(dp[<span class="dv">1</span>][<span class="dv">0</span>],dp[<span class="dv">1</span>][<span class="dv">1</span>]+<span class="dv">1</span>)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb16-25"><a href="#cb16-25"></a>}</span></code></pre></div>
<h3 id="bzoj3312usaco2013-novno-change2016.9.7">bzoj3312[Usaco2013 Nov]No Change*（2016.9.7）</h3>
<h4 id="题意-16">题意</h4>
<p>K个硬币，要按顺序买N个物品。当选定买的东西物品序列后，付出钱后，货主是不会找零钱的。现希望通过改变硬币的顺序使买完所需要的东西后，留下的钱越多越好，如果不能完成购买任务，输出-1。k≤16，n≤100000。</p>
<h4 id="题解-16">题解</h4>
<p>状压dp。f[S]表示用硬币集合S所能买的最大物品数量。转移则是f[S]=f[S/i]+g(i)],g(i)等于coin[i]从f[S/coin[i]]+1开始能买的最大数量物品，而这个可以用前缀和加二分快速求出。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb17-10"><a href="#cb17-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb17-13"><a href="#cb17-13"></a>}</span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="dt">int</span> sm[maxn],coin[maxn],k,n,dp[maxn],ans;</span>
<span id="cb17-15"><a href="#cb17-15"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb17-16"><a href="#cb17-16"></a>    <span class="dt">int</span> y=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,k)<span class="cf">if</span>(!(x&amp;(<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>))))y+=coin[i]; ans=max(ans,y);</span>
<span id="cb17-17"><a href="#cb17-17"></a>}</span>
<span id="cb17-18"><a href="#cb17-18"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb17-19"><a href="#cb17-19"></a>    <span class="cf">if</span>(dp[x]!=-<span class="dv">1</span>)<span class="cf">return</span> dp[x]; dp[x]=<span class="dv">0</span>;</span>
<span id="cb17-20"><a href="#cb17-20"></a>    inc(i,<span class="dv">1</span>,k)<span class="cf">if</span>(x&amp;(<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>))){</span>
<span id="cb17-21"><a href="#cb17-21"></a>        <span class="dt">int</span> y=dfs(x^(<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>))); dp[x]=max(dp[x],upper_bound(sm+<span class="dv">1</span>,sm+<span class="dv">1</span>+n,sm[y]+coin[i])-sm-<span class="dv">1</span>);</span>
<span id="cb17-22"><a href="#cb17-22"></a>    }</span>
<span id="cb17-23"><a href="#cb17-23"></a>    <span class="cf">if</span>(dp[x]==n)update(x); <span class="cf">return</span> dp[x];</span>
<span id="cb17-24"><a href="#cb17-24"></a>}</span>
<span id="cb17-25"><a href="#cb17-25"></a><span class="dt">int</span> main(){</span>
<span id="cb17-26"><a href="#cb17-26"></a>    k=read(); n=read(); inc(i,<span class="dv">1</span>,k)coin[i]=read(); inc(i,<span class="dv">1</span>,n)sm[i]=read(),sm[i]+=sm[i-<span class="dv">1</span>];</span>
<span id="cb17-27"><a href="#cb17-27"></a>    memset(dp,-<span class="dv">1</span>,<span class="kw">sizeof</span>(dp)); ans=-<span class="dv">1</span>; dfs((<span class="dv">1</span>&lt;&lt;k)-<span class="dv">1</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb17-28"><a href="#cb17-28"></a>}</span></code></pre></div>
<h3 id="bzoj3396usaco2009-jantotal-flow-水流2016.9.8">bzoj3396[Usaco2009 Jan]Total flow 水流*（2016.9.8）</h3>
<h4 id="题意-17">题意</h4>
<p>求无环图的最大流。边数≤700。</p>
<h4 id="题解-17">题解</h4>
<p>管它有没有环。注意本题的节点标号既有大写字母，也有小写字母。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="pp">#define maxn </span><span class="dv">100</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb18-9"><a href="#cb18-9"></a></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,c,n;}es[maxn*<span class="dv">80</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> c){</span>
<span id="cb18-12"><a href="#cb18-12"></a>    es[++ess]=(e){t,c,g[f]}; g[f]=ess; es[++ess]=(e){f,<span class="dv">0</span>,g[t]}; g[t]=ess;</span>
<span id="cb18-13"><a href="#cb18-13"></a>    es[++ess]=(e){f,c,g[t]}; g[t]=ess; es[++ess]=(e){t,<span class="dv">0</span>,g[f]}; g[f]=ess;</span>
<span id="cb18-14"><a href="#cb18-14"></a>}</span>
<span id="cb18-15"><a href="#cb18-15"></a>queue&lt;<span class="dt">int</span>&gt;q; <span class="dt">int</span> h[maxn];</span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="dt">bool</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb18-17"><a href="#cb18-17"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(h,-<span class="dv">1</span>,<span class="kw">sizeof</span>(h)); q.push(s); h[s]=<span class="dv">0</span>;</span>
<span id="cb18-18"><a href="#cb18-18"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb18-19"><a href="#cb18-19"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb18-20"><a href="#cb18-20"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==-<span class="dv">1</span>){h[es[i].t]=h[x]+<span class="dv">1</span>; q.push(es[i].t);}</span>
<span id="cb18-21"><a href="#cb18-21"></a>    }</span>
<span id="cb18-22"><a href="#cb18-22"></a>    <span class="cf">return</span> h[t]!=-<span class="dv">1</span>;</span>
<span id="cb18-23"><a href="#cb18-23"></a>}</span>
<span id="cb18-24"><a href="#cb18-24"></a><span class="dt">int</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> t,<span class="dt">int</span> f){</span>
<span id="cb18-25"><a href="#cb18-25"></a>    <span class="cf">if</span>(x==t)<span class="cf">return</span> f; <span class="dt">int</span> u=<span class="dv">0</span>;</span>
<span id="cb18-26"><a href="#cb18-26"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].c&amp;&amp;h[es[i].t]==h[x]+<span class="dv">1</span>){</span>
<span id="cb18-27"><a href="#cb18-27"></a>        <span class="dt">int</span> w=dfs(es[i].t,t,min(f,es[i].c)); f-=w; u+=w;</span>
<span id="cb18-28"><a href="#cb18-28"></a>        es[i].c-=w; es[i^<span class="dv">1</span>].c+=w; <span class="cf">if</span>(f==<span class="dv">0</span>)<span class="cf">return</span> u;</span>
<span id="cb18-29"><a href="#cb18-29"></a>    }</span>
<span id="cb18-30"><a href="#cb18-30"></a>    <span class="cf">if</span>(u==<span class="dv">0</span>)h[x]=-<span class="dv">1</span>; <span class="cf">return</span> u;</span>
<span id="cb18-31"><a href="#cb18-31"></a>}</span>
<span id="cb18-32"><a href="#cb18-32"></a><span class="dt">int</span> dinic(<span class="dt">int</span> s,<span class="dt">int</span> t){</span>
<span id="cb18-33"><a href="#cb18-33"></a>    <span class="dt">int</span> f=<span class="dv">0</span>; <span class="cf">while</span>(bfs(s,t))f+=dfs(s,t,INF); <span class="cf">return</span> f;</span>
<span id="cb18-34"><a href="#cb18-34"></a>}</span>
<span id="cb18-35"><a href="#cb18-35"></a><span class="dt">int</span> s,t,n;</span>
<span id="cb18-36"><a href="#cb18-36"></a><span class="dt">int</span> main(){</span>
<span id="cb18-37"><a href="#cb18-37"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n); ess=<span class="dv">1</span>; s=<span class="dv">0</span>; t=<span class="ch">&#39;Z&#39;</span>-<span class="ch">&#39;A&#39;</span>;</span>
<span id="cb18-38"><a href="#cb18-38"></a>    inc(i,<span class="dv">1</span>,n){<span class="dt">char</span> x[<span class="dv">3</span>],y[<span class="dv">3</span>]; <span class="dt">int</span> z; scanf(<span class="st">&quot;</span><span class="sc">%s%s%d</span><span class="st">&quot;</span>,x,y,&amp;z); pe(x[<span class="dv">0</span>]-<span class="ch">&#39;A&#39;</span>,y[<span class="dv">0</span>]-<span class="ch">&#39;A&#39;</span>,z);}</span>
<span id="cb18-39"><a href="#cb18-39"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dinic(s,t)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb18-40"><a href="#cb18-40"></a>}</span></code></pre></div>
<h3 id="bzoj1231usaco2008-novmixup2-混乱的奶牛2016.9.8">bzoj1231[Usaco2008 Nov]mixup2 混乱的奶牛*（2016.9.8）</h3>
<h4 id="题意-18">题意</h4>
<p>n头奶牛，每头有一个编号，求有多少种排列顺序使得相邻两头奶牛的编号差不超过k。n≤16。</p>
<h4 id="题解-18">题解</h4>
<p>状压dp。f[i][S]表示已选状态为S，上一个选的是i，满足要求的方案数，则f[i][S]=sum(f[j][S|j]),abs(num[i]-num[j])≤k。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb19-8"><a href="#cb19-8"></a></span>
<span id="cb19-9"><a href="#cb19-9"></a>ll dp[<span class="dv">20</span>][<span class="dv">80000</span>]; <span class="dt">int</span> n,k,s[<span class="dv">20</span>];</span>
<span id="cb19-10"><a href="#cb19-10"></a>ll dfs(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb19-11"><a href="#cb19-11"></a>    <span class="cf">if</span>(!y)<span class="cf">return</span> <span class="dv">1</span>; <span class="cf">if</span>(dp[x][y]!=-<span class="dv">1</span>)<span class="cf">return</span> dp[x][y]; dp[x][y]=<span class="dv">0</span>;</span>
<span id="cb19-12"><a href="#cb19-12"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>((y&amp;(<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>)))&amp;&amp;abs(s[i]-s[x])&gt;k)dp[x][y]+=dfs(i,y^(<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>)));</span>
<span id="cb19-13"><a href="#cb19-13"></a>    <span class="cf">return</span> dp[x][y];</span>
<span id="cb19-14"><a href="#cb19-14"></a>}</span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="dt">int</span> main(){</span>
<span id="cb19-16"><a href="#cb19-16"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;s[i]); memset(dp,-<span class="dv">1</span>,<span class="kw">sizeof</span>(dp));</span>
<span id="cb19-17"><a href="#cb19-17"></a>    s[<span class="dv">0</span>]=-INF; printf(<span class="st">&quot;</span><span class="sc">%lld\n</span><span class="st">&quot;</span>,dfs(<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;n)-<span class="dv">1</span>)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb19-18"><a href="#cb19-18"></a>}</span></code></pre></div>
<h3 id="bzoj1725usaco2006-novcorn-fields牧场的安排2016.9.8">bzoj1725[Usaco2006 Nov]Corn Fields牧场的安排*（2016.9.8）</h3>
<h4 id="题意-19">题意</h4>
<p>n*m的土地，有的土地不能种草。求有多少种种草方案使得没有两块草地相邻。n，m≤12。</p>
<h4 id="题解-19">题解</h4>
<p>先预处理出存在草地左右相邻的不合法状态，然后状压dp。f[i][S]表示当前处理第i行上一行状态为S，则f[i][S]=sum(f[i+1][T]),T满足没有草种在不能种的地上且不与上一行上下相邻同时不存在左右相邻。本来按道理来说这种方法是会超时的，然而似乎本题数据弱。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#define mod </span><span class="dv">100000000</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb20-7"><a href="#cb20-7"></a></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="dt">int</span> f[<span class="dv">2</span>][<span class="dv">5000</span>],t[<span class="dv">20</span>],n,m,x,y,ans; <span class="dt">bool</span> bad[<span class="dv">5000</span>];</span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="dt">int</span> main(){</span>
<span id="cb20-10"><a href="#cb20-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n){t[i]=<span class="dv">0</span>; inc(j,<span class="dv">1</span>,m){<span class="dt">int</span> x; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x); t[i]+=((!x)&lt;&lt;(j-<span class="dv">1</span>));}}</span>
<span id="cb20-11"><a href="#cb20-11"></a>    inc(i,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;m)-<span class="dv">1</span>){</span>
<span id="cb20-12"><a href="#cb20-12"></a>        inc(j,<span class="dv">1</span>,m-<span class="dv">1</span>)<span class="cf">if</span>((i&amp;(<span class="dv">1</span>&lt;&lt;(j-<span class="dv">1</span>)))&amp;&amp;(i&amp;(<span class="dv">1</span>&lt;&lt;j))){bad[i]=<span class="dv">1</span>; <span class="cf">break</span>;}</span>
<span id="cb20-13"><a href="#cb20-13"></a>    }</span>
<span id="cb20-14"><a href="#cb20-14"></a>    x=<span class="dv">0</span>; y=<span class="dv">1</span>; inc(i,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;m)-<span class="dv">1</span>)<span class="cf">if</span>(!(i&amp;t[n])&amp;&amp;!bad[i])f[x][i]=<span class="dv">1</span>;</span>
<span id="cb20-15"><a href="#cb20-15"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n-<span class="dv">1</span>;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb20-16"><a href="#cb20-16"></a>        inc(j,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;m)-<span class="dv">1</span>){</span>
<span id="cb20-17"><a href="#cb20-17"></a>            f[y][j]=<span class="dv">0</span>; <span class="cf">if</span>(!(j&amp;t[i])&amp;&amp;!bad[j]){inc(k,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;m)-<span class="dv">1</span>)<span class="cf">if</span>(!(k&amp;j))f[y][j]=(f[y][j]+f[x][k])%mod;}</span>
<span id="cb20-18"><a href="#cb20-18"></a>        }</span>
<span id="cb20-19"><a href="#cb20-19"></a>        swap(x,y);</span>
<span id="cb20-20"><a href="#cb20-20"></a>    }</span>
<span id="cb20-21"><a href="#cb20-21"></a>    inc(i,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;m)-<span class="dv">1</span>)ans=(ans+f[x][i])%mod; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb20-22"><a href="#cb20-22"></a>}</span></code></pre></div>
<h3 id="bzoj4395usaco2015-decswitching-on-the-lights2016.9.8">bzoj4395[Usaco2015 dec]Switching on the Lights*（2016.9.8）</h3>
<h4 id="题意-20">题意</h4>
<p>n*n个房间，奶牛初始在(1,1)，且只能在亮的房间里活动。每当奶牛经过一个房间，就可以打开这个房间里控制其它房间灯的开关。问奶牛最多可点亮多少个房间。n≤100。</p>
<h4 id="题解-20">题解</h4>
<p>因为只要一个房间灯亮了，它将一直亮着，所以可以做bfs，每次由队列中的节点扩展可以到的节点。然而这样做不行，因为可能之前尝试过不能到达的房间的灯可以在之后到达的房间里被打开。解决方法是不停做bfs，直到答案不再更新。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb21-8"><a href="#cb21-8"></a></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb21-11"><a href="#cb21-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb21-12"><a href="#cb21-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb21-13"><a href="#cb21-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb21-14"><a href="#cb21-14"></a>}</span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="kw">struct</span> nd{<span class="dt">int</span> x,y,n;}nds[maxn*<span class="dv">200</span>]; <span class="dt">int</span> g[maxn][maxn];</span>
<span id="cb21-16"><a href="#cb21-16"></a><span class="dt">int</span> n,m,ans; <span class="dt">bool</span> lg[maxn][maxn],vis[maxn][maxn]; queue&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; &gt;q;</span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="dt">void</span> bfs(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb21-18"><a href="#cb21-18"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); q.push(make_pair(x,y)); vis[x][y]=<span class="dv">1</span>;</span>
<span id="cb21-19"><a href="#cb21-19"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x][y];i;i=nds[i].n)<span class="cf">if</span>(!lg[nds[i].x][nds[i].y])lg[nds[i].x][nds[i].y]=<span class="dv">1</span>,ans++;</span>
<span id="cb21-20"><a href="#cb21-20"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb21-21"><a href="#cb21-21"></a>        <span class="dt">int</span> nowx=q.front().first,nowy=q.front().second; q.pop();</span>
<span id="cb21-22"><a href="#cb21-22"></a>        <span class="cf">if</span>(nowx&gt;<span class="dv">1</span>&amp;&amp;lg[nowx-<span class="dv">1</span>][nowy]&amp;&amp;!vis[nowx-<span class="dv">1</span>][nowy]){</span>
<span id="cb21-23"><a href="#cb21-23"></a>            q.push(make_pair(nowx-<span class="dv">1</span>,nowy)); vis[nowx-<span class="dv">1</span>][nowy]=<span class="dv">1</span>;</span>
<span id="cb21-24"><a href="#cb21-24"></a>            <span class="cf">for</span>(<span class="dt">int</span> i=g[nowx-<span class="dv">1</span>][nowy];i;i=nds[i].n)</span>
<span id="cb21-25"><a href="#cb21-25"></a>                <span class="cf">if</span>(!lg[nds[i].x][nds[i].y])lg[nds[i].x][nds[i].y]=<span class="dv">1</span>,ans++;</span>
<span id="cb21-26"><a href="#cb21-26"></a>        }</span>
<span id="cb21-27"><a href="#cb21-27"></a>        <span class="cf">if</span>(nowx&lt;n&amp;&amp;lg[nowx+<span class="dv">1</span>][nowy]&amp;&amp;!vis[nowx+<span class="dv">1</span>][nowy]){</span>
<span id="cb21-28"><a href="#cb21-28"></a>            q.push(make_pair(nowx+<span class="dv">1</span>,nowy)); vis[nowx+<span class="dv">1</span>][nowy]=<span class="dv">1</span>;</span>
<span id="cb21-29"><a href="#cb21-29"></a>            <span class="cf">for</span>(<span class="dt">int</span> i=g[nowx+<span class="dv">1</span>][nowy];i;i=nds[i].n)</span>
<span id="cb21-30"><a href="#cb21-30"></a>                <span class="cf">if</span>(!lg[nds[i].x][nds[i].y])lg[nds[i].x][nds[i].y]=<span class="dv">1</span>,ans++;</span>
<span id="cb21-31"><a href="#cb21-31"></a>        }</span>
<span id="cb21-32"><a href="#cb21-32"></a>        <span class="cf">if</span>(nowy&gt;<span class="dv">1</span>&amp;&amp;lg[nowx][nowy-<span class="dv">1</span>]&amp;&amp;!vis[nowx][nowy-<span class="dv">1</span>]){</span>
<span id="cb21-33"><a href="#cb21-33"></a>            q.push(make_pair(nowx,nowy-<span class="dv">1</span>)); vis[nowx][nowy-<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb21-34"><a href="#cb21-34"></a>            <span class="cf">for</span>(<span class="dt">int</span> i=g[nowx][nowy-<span class="dv">1</span>];i;i=nds[i].n)</span>
<span id="cb21-35"><a href="#cb21-35"></a>                <span class="cf">if</span>(!lg[nds[i].x][nds[i].y])lg[nds[i].x][nds[i].y]=<span class="dv">1</span>,ans++;</span>
<span id="cb21-36"><a href="#cb21-36"></a>        }</span>
<span id="cb21-37"><a href="#cb21-37"></a>        <span class="cf">if</span>(nowy&lt;n&amp;&amp;lg[nowx][nowy+<span class="dv">1</span>]&amp;&amp;!vis[nowx][nowy+<span class="dv">1</span>]){</span>
<span id="cb21-38"><a href="#cb21-38"></a>            q.push(make_pair(nowx,nowy+<span class="dv">1</span>)); vis[nowx][nowy+<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb21-39"><a href="#cb21-39"></a>            <span class="cf">for</span>(<span class="dt">int</span> i=g[nowx][nowy+<span class="dv">1</span>];i;i=nds[i].n)</span>
<span id="cb21-40"><a href="#cb21-40"></a>                <span class="cf">if</span>(!lg[nds[i].x][nds[i].y])lg[nds[i].x][nds[i].y]=<span class="dv">1</span>,ans++;</span>
<span id="cb21-41"><a href="#cb21-41"></a>        }</span>
<span id="cb21-42"><a href="#cb21-42"></a>    }</span>
<span id="cb21-43"><a href="#cb21-43"></a>}</span>
<span id="cb21-44"><a href="#cb21-44"></a><span class="dt">int</span> main(){</span>
<span id="cb21-45"><a href="#cb21-45"></a>    n=read(); m=read();</span>
<span id="cb21-46"><a href="#cb21-46"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb21-47"><a href="#cb21-47"></a>        <span class="dt">int</span> a=read(),b=read(),c=read(),d=read(); nds[i]=(nd){c,d,g[a][b]}; g[a][b]=i;</span>
<span id="cb21-48"><a href="#cb21-48"></a>    }</span>
<span id="cb21-49"><a href="#cb21-49"></a>    ans=<span class="dv">1</span>; lg[<span class="dv">1</span>][<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb21-50"><a href="#cb21-50"></a>    <span class="cf">while</span>(<span class="dv">1</span>){<span class="dt">int</span> x=ans; bfs(<span class="dv">1</span>,<span class="dv">1</span>); <span class="cf">if</span>(ans==x)<span class="cf">break</span>;} printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb21-51"><a href="#cb21-51"></a>}</span></code></pre></div>
<h3 id="bzoj4396usaco2015-dechigh-card-wins2016.9.8">bzoj4396[Usaco2015 dec]High Card Wins*（2016.9.8）</h3>
<h4 id="题意-21">题意</h4>
<p>一共有2n张牌，Alice有n张，Bob有n张，每一局点数大的赢。知道Bob的出牌顺序，求Alice最多能赢几局。n≤50000。</p>
<h4 id="题解-21">题解</h4>
<p>贪心。将Alice和Bob的牌按点数大小排序，然后如果Alice当前牌能赢Bob当前牌就ans++否则就不断调整Bob的当前牌直到Alice当前牌能赢Bob当前牌。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb22-7"><a href="#cb22-7"></a></span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb22-9"><a href="#cb22-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb22-10"><a href="#cb22-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb22-12"><a href="#cb22-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb22-13"><a href="#cb22-13"></a>}</span>
<span id="cb22-14"><a href="#cb22-14"></a><span class="dt">int</span> a[maxn],b[maxn],ans,n,tot; <span class="dt">bool</span> c[maxn*<span class="dv">2</span>];</span>
<span id="cb22-15"><a href="#cb22-15"></a><span class="dt">int</span> main(){</span>
<span id="cb22-16"><a href="#cb22-16"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(),c[a[i]]=<span class="dv">1</span>; inc(i,<span class="dv">1</span>,<span class="dv">2</span>*n)<span class="cf">if</span>(!c[i])b[++tot]=i; sort(a+<span class="dv">1</span>,a+n+<span class="dv">1</span>);</span>
<span id="cb22-17"><a href="#cb22-17"></a>    <span class="dt">int</span> p=<span class="dv">1</span>,q=<span class="dv">1</span>;</span>
<span id="cb22-18"><a href="#cb22-18"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb22-19"><a href="#cb22-19"></a>        <span class="cf">while</span>(p&lt;=n&amp;&amp;b[p]&lt;a[q])p++; <span class="cf">if</span>(p==n+<span class="dv">1</span>)<span class="cf">break</span>; ans++; p++; q++;</span>
<span id="cb22-20"><a href="#cb22-20"></a>    }</span>
<span id="cb22-21"><a href="#cb22-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb22-22"><a href="#cb22-22"></a>}</span></code></pre></div>
<h3 id="bzoj4397usaco2015-decbreed-counting2016.9.8">bzoj4397[Usaco2015 dec]Breed Counting*（2016.9.8）</h3>
<h4 id="题意-22">题意</h4>
<p>给定一个长度为N的序列，每个位置上的数只可能是1，2，3中的一种。有Q次询问，每次给定两个数a,b，请分别输出区间[a,b]里数字1，2，3的个数。n≤100000，q≤100000。</p>
<h4 id="题解-22">题解</h4>
<p>裸前缀和。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb23-5"><a href="#cb23-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb23-7"><a href="#cb23-7"></a></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb23-9"><a href="#cb23-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb23-10"><a href="#cb23-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb23-11"><a href="#cb23-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb23-12"><a href="#cb23-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb23-13"><a href="#cb23-13"></a>}</span>
<span id="cb23-14"><a href="#cb23-14"></a><span class="dt">int</span> sm[<span class="dv">4</span>][maxn],n,q;</span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="dt">int</span> main(){</span>
<span id="cb23-16"><a href="#cb23-16"></a>    n=read(); q=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(); inc(j,<span class="dv">1</span>,<span class="dv">3</span>)sm[j][i]=sm[j][i-<span class="dv">1</span>]; sm[x][i]++;}</span>
<span id="cb23-17"><a href="#cb23-17"></a>    inc(i,<span class="dv">1</span>,q){</span>
<span id="cb23-18"><a href="#cb23-18"></a>        <span class="dt">int</span> l=read(),r=read(); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d\n</span><span class="st">&quot;</span>,sm[<span class="dv">1</span>][r]-sm[<span class="dv">1</span>][l-<span class="dv">1</span>],sm[<span class="dv">2</span>][r]-sm[<span class="dv">2</span>][l-<span class="dv">1</span>],sm[<span class="dv">3</span>][r]-sm[<span class="dv">3</span>][l-<span class="dv">1</span>]);</span>
<span id="cb23-19"><a href="#cb23-19"></a>    }</span>
<span id="cb23-20"><a href="#cb23-20"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb23-21"><a href="#cb23-21"></a>}</span></code></pre></div>
<h3 id="bzoj4393usaco2015-decfruit-feast2016.9.8">bzoj4393[Usaco2015 Dec]Fruit Feast*（2016.9.8）</h3>
<h4 id="题意-23">题意</h4>
<p>奶牛一开始饱胀值为0，上限为T。每个柠檬派提供a点饱胀值，每个橘子派提供b点饱胀值，有一次机会喝水，使得饱胀值div2。柠檬派和橘子派有无限个，求最大饱胀值。T≤5000000。</p>
<h4 id="题解-23">题解</h4>
<p>dfs。f[i][1/0]表示当前饱胀值为i，是/否喝过水的状态能否达到。则由f[i][1]可递推出f[i+a][1]、f[i+b][1]，由f[i][0]可递推出f[i+a][0]、f[i+b][0]、f[i/2][1]。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="pp">#define maxn </span><span class="dv">5000010</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb24-7"><a href="#cb24-7"></a></span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="dt">bool</span> vis[maxn][<span class="dv">2</span>]; <span class="dt">int</span> n,a,b,ans;</span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb24-10"><a href="#cb24-10"></a>    <span class="cf">if</span>(vis[x][y])<span class="cf">return</span>; vis[x][y]=<span class="dv">1</span>; <span class="cf">if</span>(x+a&lt;=n)dfs(x+a,y); <span class="cf">if</span>(x+b&lt;=n)dfs(x+b,y);</span>
<span id="cb24-11"><a href="#cb24-11"></a>    <span class="cf">if</span>(!y)dfs(x/<span class="dv">2</span>,<span class="dv">1</span>); ans=max(ans,x);</span>
<span id="cb24-12"><a href="#cb24-12"></a>}</span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="dt">int</span> main(){</span>
<span id="cb24-14"><a href="#cb24-14"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;a,&amp;b); memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); dfs(<span class="dv">0</span>,<span class="dv">0</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb24-15"><a href="#cb24-15"></a>}</span></code></pre></div>
<h3 id="bzoj4390usaco2015-decmax-flow2016.9.8">bzoj4390[Usaco2015 dec]Max Flow*（2016.9.8）</h3>
<h4 id="题意-24">题意</h4>
<p>给定一棵有N个点的树，所有节点的权值都为0。有K次操作，每次指定两个点s,t，将s到t路径上所有点的权值都加一。请输出K次操作完毕后权值最大的那个点的权值。n≤50000，k≤100000。</p>
<h4 id="题解-24">题解</h4>
<p>先链剖把树变为链。然后用数组区间加的方式（即在数组区间左端点位置增加值，数组区间右端点+1位置增加这个值的相反数，最后扫一遍a[i]+=a[i-1]）累计权值。类似bzoj3631</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb25-7"><a href="#cb25-7"></a></span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb25-9"><a href="#cb25-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb25-11"><a href="#cb25-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb25-12"><a href="#cb25-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb25-13"><a href="#cb25-13"></a>}</span>
<span id="cb25-14"><a href="#cb25-14"></a><span class="dt">int</span> sm[maxn],sz[maxn],dep[maxn],fa[maxn],top[maxn],pos[maxn],n,q,ans,tot;</span>
<span id="cb25-15"><a href="#cb25-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb25-16"><a href="#cb25-16"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;}</span>
<span id="cb25-17"><a href="#cb25-17"></a><span class="dt">void</span> dfs1(<span class="dt">int</span> x,<span class="dt">int</span> f){</span>
<span id="cb25-18"><a href="#cb25-18"></a>    sz[x]=<span class="dv">1</span>;</span>
<span id="cb25-19"><a href="#cb25-19"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f){</span>
<span id="cb25-20"><a href="#cb25-20"></a>        fa[es[i].t]=x; dep[es[i].t]=dep[x]+<span class="dv">1</span>; dfs1(es[i].t,x); sz[x]+=sz[es[i].t];</span>
<span id="cb25-21"><a href="#cb25-21"></a>    }</span>
<span id="cb25-22"><a href="#cb25-22"></a>}</span>
<span id="cb25-23"><a href="#cb25-23"></a><span class="dt">void</span> dfs2(<span class="dt">int</span> x,<span class="dt">int</span> f,<span class="dt">int</span> tp){</span>
<span id="cb25-24"><a href="#cb25-24"></a>    pos[x]=++tot; top[x]=tp; <span class="dt">int</span> mx1=<span class="dv">0</span>,mx2=<span class="dv">0</span>;</span>
<span id="cb25-25"><a href="#cb25-25"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f&amp;&amp;sz[es[i].t]&gt;mx1)mx1=sz[es[i].t],mx2=es[i].t;</span>
<span id="cb25-26"><a href="#cb25-26"></a>    <span class="cf">if</span>(!mx2)<span class="cf">return</span>; dfs2(mx2,x,tp);</span>
<span id="cb25-27"><a href="#cb25-27"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f&amp;&amp;es[i].t!=mx2)dfs2(es[i].t,x,es[i].t);</span>
<span id="cb25-28"><a href="#cb25-28"></a>}</span>
<span id="cb25-29"><a href="#cb25-29"></a><span class="dt">void</span> solve(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb25-30"><a href="#cb25-30"></a>    <span class="cf">for</span>(;top[x]!=top[y];sm[pos[top[x]]]++,sm[pos[x]+<span class="dv">1</span>]--,x=fa[top[x]])<span class="cf">if</span>(dep[top[x]]&lt;dep[top[y]])swap(x,y);</span>
<span id="cb25-31"><a href="#cb25-31"></a>    <span class="cf">if</span>(dep[x]&gt;dep[y])swap(x,y); sm[pos[x]]++; sm[pos[y]+<span class="dv">1</span>]--;</span>
<span id="cb25-32"><a href="#cb25-32"></a>}</span>
<span id="cb25-33"><a href="#cb25-33"></a><span class="dt">int</span> main(){</span>
<span id="cb25-34"><a href="#cb25-34"></a>    n=read(); q=read(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> x=read(),y=read(); pe(x,y);} dfs1(<span class="dv">1</span>,<span class="dv">0</span>); dfs2(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>);</span>
<span id="cb25-35"><a href="#cb25-35"></a>    inc(i,<span class="dv">1</span>,q){<span class="dt">int</span> x=read(),y=read(); solve(x,y);}</span>
<span id="cb25-36"><a href="#cb25-36"></a>    inc(i,<span class="dv">1</span>,n)sm[i]+=sm[i-<span class="dv">1</span>],ans=max(ans,sm[i]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb25-37"><a href="#cb25-37"></a>}</span></code></pre></div>
<h3 id="bzoj3524poi2014couriers2016.9.8">bzoj3524[Poi2014]Couriers*（2016.9.8）</h3>
<h4 id="题意-25">题意</h4>
<p>给一个长度为n的序列a。1≤a[i]≤n。m组询问，每次询问一个区间[l,r]，是否存在一个数在[l,r]中出现的次数大于(r-l+1)/2。如果存在，输出这个数，否则输出0。n，m≤500000。</p>
<h4 id="题解-25">题解</h4>
<p>先建主席树，之后在查找时，只走size值大于(r-l+1)/2的节点，如果两个儿子的size值都≤(r-l+1)/2则返回0否则返回最后走到的叶子节点。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="pp">#define maxn </span><span class="dv">500010</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb26-9"><a href="#cb26-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb26-10"><a href="#cb26-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb26-11"><a href="#cb26-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb26-12"><a href="#cb26-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb26-13"><a href="#cb26-13"></a>}</span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="dt">int</span> tot,sz[maxn*<span class="dv">23</span>],ch[maxn*<span class="dv">23</span>][<span class="dv">2</span>],rt[maxn],n,a[maxn],m;</span>
<span id="cb26-15"><a href="#cb26-15"></a><span class="dt">void</span> build(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb26-16"><a href="#cb26-16"></a>    x=++tot; sz[x]=<span class="dv">0</span>; <span class="cf">if</span>(l==r)<span class="cf">return</span>; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; build(ch[x][<span class="dv">0</span>],l,mid); build(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r);</span>
<span id="cb26-17"><a href="#cb26-17"></a>}</span>
<span id="cb26-18"><a href="#cb26-18"></a><span class="dt">void</span> insert(<span class="dt">int</span> &amp;x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> v){</span>
<span id="cb26-19"><a href="#cb26-19"></a>    tot++; sz[tot]=sz[x]+<span class="dv">1</span>; ch[tot][<span class="dv">0</span>]=ch[x][<span class="dv">0</span>]; ch[tot][<span class="dv">1</span>]=ch[x][<span class="dv">1</span>]; x=tot; <span class="cf">if</span>(l==r)<span class="cf">return</span>;</span>
<span id="cb26-20"><a href="#cb26-20"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(v&lt;=mid)insert(ch[x][<span class="dv">0</span>],l,mid,v); <span class="cf">if</span>(v&gt;mid)insert(ch[x][<span class="dv">1</span>],mid+<span class="dv">1</span>,r,v);</span>
<span id="cb26-21"><a href="#cb26-21"></a>    sz[x]=sz[ch[x][<span class="dv">0</span>]]+sz[ch[x][<span class="dv">1</span>]];</span>
<span id="cb26-22"><a href="#cb26-22"></a>}</span>
<span id="cb26-23"><a href="#cb26-23"></a><span class="dt">int</span> query(<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb26-24"><a href="#cb26-24"></a>    <span class="dt">int</span> x=(qr-ql+<span class="dv">1</span>)&gt;&gt;<span class="dv">1</span>,l=<span class="dv">1</span>,r=n,y=rt[qr],z=rt[ql-<span class="dv">1</span>];</span>
<span id="cb26-25"><a href="#cb26-25"></a>    <span class="cf">while</span>(<span class="dv">1</span>){</span>
<span id="cb26-26"><a href="#cb26-26"></a>        <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb26-27"><a href="#cb26-27"></a>        <span class="cf">if</span>(sz[ch[y][<span class="dv">0</span>]]-sz[ch[z][<span class="dv">0</span>]]&gt;x)y=ch[y][<span class="dv">0</span>],z=ch[z][<span class="dv">0</span>],r=mid;</span>
<span id="cb26-28"><a href="#cb26-28"></a>        <span class="cf">else</span> <span class="cf">if</span>(sz[ch[y][<span class="dv">1</span>]]-sz[ch[z][<span class="dv">1</span>]]&gt;x)y=ch[y][<span class="dv">1</span>],z=ch[z][<span class="dv">1</span>],l=mid+<span class="dv">1</span>;</span>
<span id="cb26-29"><a href="#cb26-29"></a>        <span class="cf">else</span> <span class="cf">if</span>(l==r)<span class="cf">return</span> l; <span class="cf">else</span> <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb26-30"><a href="#cb26-30"></a>    }</span>
<span id="cb26-31"><a href="#cb26-31"></a>}</span>
<span id="cb26-32"><a href="#cb26-32"></a><span class="dt">int</span> main(){</span>
<span id="cb26-33"><a href="#cb26-33"></a>    n=read(); m=read(); build(rt[<span class="dv">0</span>],<span class="dv">1</span>,n); inc(i,<span class="dv">1</span>,n)rt[i]=rt[i-<span class="dv">1</span>],insert(rt[i],<span class="dv">1</span>,n,read());</span>
<span id="cb26-34"><a href="#cb26-34"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb26-35"><a href="#cb26-35"></a>        <span class="dt">int</span> l=read(),r=read(); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query(l,r));</span>
<span id="cb26-36"><a href="#cb26-36"></a>    }</span>
<span id="cb26-37"><a href="#cb26-37"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb26-38"><a href="#cb26-38"></a>}</span></code></pre></div>
<h3 id="bzoj3893usaco2014-deccow-jog2016.9.9">bzoj3893[Usaco2014 Dec]Cow Jog*（2016.9.9）</h3>
<h4 id="题意-26">题意</h4>
<p>在一条无限长的跑道上有N头牛，每头牛有自己的初始位置及奔跑的速度。牛之间不能互相穿透。当一只牛追上另一只牛时，它不得不慢下来，成为一个群体。求T分钟后一共有几个群体。n≤100000，t≤1000000000</p>
<h4 id="题解-26">题解</h4>
<p>如果慢车经过t时间到达的位置大于快车t时间到达的位置，则这两只车成为一个群体。具体看代码。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb27-4"><a href="#cb27-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb27-6"><a href="#cb27-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb27-7"><a href="#cb27-7"></a></span>
<span id="cb27-8"><a href="#cb27-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb27-10"><a href="#cb27-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb27-11"><a href="#cb27-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb27-12"><a href="#cb27-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb27-13"><a href="#cb27-13"></a>}</span>
<span id="cb27-14"><a href="#cb27-14"></a><span class="dt">int</span> p[maxn],v[maxn],n,slow,ans,t;</span>
<span id="cb27-15"><a href="#cb27-15"></a><span class="dt">int</span> main(){</span>
<span id="cb27-16"><a href="#cb27-16"></a>    n=read(); t=read(); inc(i,<span class="dv">1</span>,n)p[i]=read(),v[i]=read(); slow=n; ans=<span class="dv">1</span>;</span>
<span id="cb27-17"><a href="#cb27-17"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n-<span class="dv">1</span>;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb27-18"><a href="#cb27-18"></a>        <span class="cf">if</span>(<span class="dv">1</span><span class="bu">LL</span>*p[i]+<span class="dv">1</span><span class="bu">LL</span>*v[i]*t&lt;<span class="dv">1</span><span class="bu">LL</span>*p[slow]+<span class="dv">1</span><span class="bu">LL</span>*v[slow]*t)ans++,slow=i;</span>
<span id="cb27-19"><a href="#cb27-19"></a>    }</span>
<span id="cb27-20"><a href="#cb27-20"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb27-21"><a href="#cb27-21"></a>}</span></code></pre></div>
<h3 id="bzoj3892usaco2014-decmarathon2016.9.9">bzoj3892[Usaco2014 Dec]Marathon*（2016.9.9）</h3>
<h4 id="题意-27">题意</h4>
<p>在二维平面上有N个点，从(x1,y1)到(x2,y2)的代价为|x1-x2|+|y1-y2|。求从1号点出发，按从1到N的顺序依次到达每个点的最小总代价。你有K次机会可以跳过某个点，不允许跳过1号点或N号点。n≤500。</p>
<h4 id="题解-27">题解</h4>
<p>dp。f[i][j]表示当前在i个点，剩j次，则f[i][j]=min(f[i+1][j]+abs(x[i+1]-x[i])+abs(y[i+1]-y[i]),f[i+k+1][j-k]),i+k+1≤n,k≤j。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="pp">#define maxn </span><span class="dv">510</span></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb28-7"><a href="#cb28-7"></a></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb28-9"><a href="#cb28-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb28-10"><a href="#cb28-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb28-11"><a href="#cb28-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb28-12"><a href="#cb28-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb28-13"><a href="#cb28-13"></a>}</span>
<span id="cb28-14"><a href="#cb28-14"></a><span class="dt">int</span> n,k,x[maxn],y[maxn],dp[maxn][maxn];</span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="dt">int</span> dfs(<span class="dt">int</span> a,<span class="dt">int</span> b){</span>
<span id="cb28-16"><a href="#cb28-16"></a>    <span class="cf">if</span>(a==n)<span class="cf">return</span> <span class="dv">0</span>; <span class="cf">if</span>(dp[a][b]!=-<span class="dv">1</span>)<span class="cf">return</span> dp[a][b];</span>
<span id="cb28-17"><a href="#cb28-17"></a>    dp[a][b]=dfs(a+<span class="dv">1</span>,b)+abs(x[a]-x[a+<span class="dv">1</span>])+abs(y[a]-y[a+<span class="dv">1</span>]);</span>
<span id="cb28-18"><a href="#cb28-18"></a>    inc(i,<span class="dv">1</span>,min(b,n-a-<span class="dv">1</span>))dp[a][b]=min(dp[a][b],dfs(a+i+<span class="dv">1</span>,b-i)+abs(x[a]-x[a+i+<span class="dv">1</span>])+abs(y[a]-y[a+i+<span class="dv">1</span>]));</span>
<span id="cb28-19"><a href="#cb28-19"></a>    <span class="cf">return</span> dp[a][b];</span>
<span id="cb28-20"><a href="#cb28-20"></a>}</span>
<span id="cb28-21"><a href="#cb28-21"></a><span class="dt">int</span> main(){</span>
<span id="cb28-22"><a href="#cb28-22"></a>    n=read(); k=read(); inc(i,<span class="dv">1</span>,n)x[i]=read(),y[i]=read(); memset(dp,-<span class="dv">1</span>,<span class="kw">sizeof</span>(dp));</span>
<span id="cb28-23"><a href="#cb28-23"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dfs(<span class="dv">1</span>,k)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb28-24"><a href="#cb28-24"></a>}</span></code></pre></div>
<h3 id="bzoj3891usaco2014-decpiggy-back2016.9.9">bzoj3891[Usaco2014 Dec]Piggy Back*（2016.9.9）</h3>
<h4 id="题意-28">题意</h4>
<p>给定一个N个点M条边的无向图，其中Bessie在1号点，Elsie在2号点，它们的目的地为N号点。Bessie每经过一条边需要消耗B点能量，Elsie每经过一条边需要消耗E点能量。当它们相遇时，它们可以一起行走，此时它们每经过一条边需要消耗P点能量。求它们两个到达N号点时最少消耗多少能量。n，m≤40000。</p>
<h4 id="题解-28">题解</h4>
<p>先求出以1、2、n为源点的最短路（因为边权为1所以用bfs）。答案初始设为1到n的最短路*B+2到n的最短路*E。接着枚举每个点，让该点到1最短路*B+该点到2最短路*E+该点到n的最短路*P和答案比较。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="pp">#define maxn </span><span class="dv">40010</span></span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb29-8"><a href="#cb29-8"></a></span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb29-10"><a href="#cb29-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb29-11"><a href="#cb29-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb29-12"><a href="#cb29-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb29-13"><a href="#cb29-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb29-14"><a href="#cb29-14"></a>}</span>
<span id="cb29-15"><a href="#cb29-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb29-16"><a href="#cb29-16"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){</span>
<span id="cb29-17"><a href="#cb29-17"></a>    es[++ess]=(e){t,g[f]}; g[f]=ess; es[++ess]=(e){f,g[t]}; g[t]=ess;</span>
<span id="cb29-18"><a href="#cb29-18"></a>}</span>
<span id="cb29-19"><a href="#cb29-19"></a><span class="dt">int</span> n,m,b,e,p,d[<span class="dv">3</span>][maxn]; <span class="dt">long</span> <span class="dt">long</span> ans; queue&lt;<span class="dt">int</span>&gt;q; <span class="dt">bool</span> vis[maxn];</span>
<span id="cb29-20"><a href="#cb29-20"></a><span class="dt">void</span> bfs(<span class="dt">int</span> s,<span class="dt">int</span> o){</span>
<span id="cb29-21"><a href="#cb29-21"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis));</span>
<span id="cb29-22"><a href="#cb29-22"></a>    q.push(s); vis[s]=<span class="dv">1</span>; d[o][s]=<span class="dv">0</span>;</span>
<span id="cb29-23"><a href="#cb29-23"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb29-24"><a href="#cb29-24"></a>        <span class="dt">int</span> x=q.front(); q.pop();</span>
<span id="cb29-25"><a href="#cb29-25"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(!vis[es[i].t]){</span>
<span id="cb29-26"><a href="#cb29-26"></a>            d[o][es[i].t]=d[o][x]+<span class="dv">1</span>; q.push(es[i].t); vis[es[i].t]=<span class="dv">1</span>;</span>
<span id="cb29-27"><a href="#cb29-27"></a>        }</span>
<span id="cb29-28"><a href="#cb29-28"></a>    }</span>
<span id="cb29-29"><a href="#cb29-29"></a>}</span>
<span id="cb29-30"><a href="#cb29-30"></a><span class="dt">int</span> main(){</span>
<span id="cb29-31"><a href="#cb29-31"></a>    b=read(); e=read(); p=read(); n=read(); m=read(); inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(); pe(x,y);}</span>
<span id="cb29-32"><a href="#cb29-32"></a>    bfs(<span class="dv">1</span>,<span class="dv">0</span>); bfs(<span class="dv">2</span>,<span class="dv">1</span>); bfs(n,<span class="dv">2</span>); ans=<span class="dv">1</span><span class="bu">LL</span>*d[<span class="dv">0</span>][n]*b+<span class="dv">1</span><span class="bu">LL</span>*d[<span class="dv">1</span>][n]*e;</span>
<span id="cb29-33"><a href="#cb29-33"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(<span class="dv">1</span><span class="bu">LL</span>*d[<span class="dv">0</span>][i]*b+<span class="dv">1</span><span class="bu">LL</span>*d[<span class="dv">1</span>][i]*e+<span class="dv">1</span><span class="bu">LL</span>*d[<span class="dv">2</span>][i]*p&lt;ans)ans=<span class="dv">1</span><span class="bu">LL</span>*d[<span class="dv">0</span>][i]*b+<span class="dv">1</span><span class="bu">LL</span>*d[<span class="dv">1</span>][i]*e+<span class="dv">1</span><span class="bu">LL</span>*d[<span class="dv">2</span>][i]*p;</span>
<span id="cb29-34"><a href="#cb29-34"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb29-35"><a href="#cb29-35"></a>}</span></code></pre></div>
<h3 id="bzoj3538usaco2014-opendueling-gps2016.9.9">bzoj3538[Usaco2014 Open]Dueling GPS*（2016.9.9）</h3>
<h4 id="题意-29">题意</h4>
<p>给你一个N个点的有向图，设定初始位置为1，结束位置为n。有两个GPS定位系统,分别认为经过边i的时间为Pi,和Qi.每走一条边的时候,如果一个系统认为走的这条边不是它认为的最短路,就会受到警告一次。如果走的这条边都不在两个系统认为的最短路范围内,就会受到2次警告。求最少需要受到多少次警告。n≤10000，边数≤50000</p>
<h4 id="题解-29">题解</h4>
<p>分别按两个GPS的边权求最短路，然后枚举每条边，把该边的边权变为其警告数，然后再求一次最短路。判断该边是不是最短路的条件是是否dis[es[i].f]+es[i].w==dis[es[i].t]。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb30-9"><a href="#cb30-9"></a></span>
<span id="cb30-10"><a href="#cb30-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb30-11"><a href="#cb30-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb30-12"><a href="#cb30-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb30-13"><a href="#cb30-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb30-14"><a href="#cb30-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb30-15"><a href="#cb30-15"></a>}</span>
<span id="cb30-16"><a href="#cb30-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,w,n;}es[maxn*<span class="dv">5</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb30-17"><a href="#cb30-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){f,t,w,g[f]}; g[f]=ess;}</span>
<span id="cb30-18"><a href="#cb30-18"></a><span class="dt">int</span> n,m,a[<span class="dv">2</span>][maxn*<span class="dv">5</span>],b[maxn*<span class="dv">5</span>],d[<span class="dv">2</span>][maxn]; queue&lt;<span class="dt">int</span>&gt;q; <span class="dt">bool</span> inq[maxn];</span>
<span id="cb30-19"><a href="#cb30-19"></a><span class="dt">void</span> spfa(<span class="dt">int</span> s,<span class="dt">int</span> o){</span>
<span id="cb30-20"><a href="#cb30-20"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); inc(i,<span class="dv">1</span>,n)d[o][i]=INF;</span>
<span id="cb30-21"><a href="#cb30-21"></a>    q.push(s); inq[s]=<span class="dv">1</span>; d[o][s]=<span class="dv">0</span>;</span>
<span id="cb30-22"><a href="#cb30-22"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb30-23"><a href="#cb30-23"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb30-24"><a href="#cb30-24"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[o][x]+es[i].w&lt;d[o][es[i].t]){</span>
<span id="cb30-25"><a href="#cb30-25"></a>            d[o][es[i].t]=d[o][x]+es[i].w; <span class="cf">if</span>(!inq[es[i].t])q.push(es[i].t),inq[es[i].t]=<span class="dv">1</span>;</span>
<span id="cb30-26"><a href="#cb30-26"></a>        }</span>
<span id="cb30-27"><a href="#cb30-27"></a>    }</span>
<span id="cb30-28"><a href="#cb30-28"></a>}</span>
<span id="cb30-29"><a href="#cb30-29"></a><span class="dt">int</span> main(){</span>
<span id="cb30-30"><a href="#cb30-30"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(),z=read(); pe(y,x,z); a[<span class="dv">0</span>][i]=z; a[<span class="dv">1</span>][i]=read();}</span>
<span id="cb30-31"><a href="#cb30-31"></a>    spfa(n,<span class="dv">0</span>); inc(i,<span class="dv">1</span>,m)es[i].w=a[<span class="dv">1</span>][i]; spfa(n,<span class="dv">1</span>);</span>
<span id="cb30-32"><a href="#cb30-32"></a>    inc(i,<span class="dv">1</span>,m){inc(j,<span class="dv">0</span>,<span class="dv">1</span>)<span class="cf">if</span>(d[j][es[i].f]+a[j][i]&gt;d[j][es[i].t])b[i]++; es[i].w=b[i];}</span>
<span id="cb30-33"><a href="#cb30-33"></a>    spfa(n,<span class="dv">0</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,d[<span class="dv">0</span>][<span class="dv">1</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb30-34"><a href="#cb30-34"></a>}</span></code></pre></div>
<h3 id="bzoj3375usaco2004-marparanoid-cows-发疯的奶牛2016.9.9">bzoj3375[Usaco2004 Mar]Paranoid Cows 发疯的奶牛*（2016.9.9）</h3>
<h4 id="题意-30">题意</h4>
<p>依次给出n只奶牛的产奶时间段，求最大的k使得前k只奶牛不存在一个时间段被另一个时间段完全覆盖的情况。n≤100000。</p>
<h4 id="题解-30">题解</h4>
<p>设当前在处理第i只奶牛，前i-1只奶牛都合法。那么如果前i-1只奶牛中时间段左端点小于且最接近第i只奶牛时间段左端点的奶牛右端点大于当前奶牛则不合法，且如果前i-1只奶牛中时间段左端点大于且最接近第i只奶牛时间段左端点的奶牛右端点小于第i只奶牛则不合法，这是一个贪心的过程，可以用STLset维护。注意set要先插入一个+INF和负INF以防边界炸。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="pp">#define sit </span>set&lt;nd&gt;::iterator</span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb31-9"><a href="#cb31-9"></a></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb31-11"><a href="#cb31-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb31-12"><a href="#cb31-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb31-13"><a href="#cb31-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb31-14"><a href="#cb31-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb31-15"><a href="#cb31-15"></a>}</span>
<span id="cb31-16"><a href="#cb31-16"></a><span class="kw">struct</span> nd{<span class="dt">int</span> l,r; <span class="dt">bool</span> <span class="kw">operator</span> &lt;(<span class="at">const</span> nd&amp;a)<span class="at">const</span>{<span class="cf">return</span> l==a.l?r&lt;a.r:l&lt;a.l;}};</span>
<span id="cb31-17"><a href="#cb31-17"></a>set&lt;nd&gt;s; <span class="dt">int</span> n;</span>
<span id="cb31-18"><a href="#cb31-18"></a><span class="dt">int</span> main(){</span>
<span id="cb31-19"><a href="#cb31-19"></a>    n=read(); s.insert((nd){INF,<span class="dv">0</span>}); s.insert((nd){-INF,<span class="dv">0</span>});</span>
<span id="cb31-20"><a href="#cb31-20"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb31-21"><a href="#cb31-21"></a>        <span class="dt">int</span> x=read(),y=read();</span>
<span id="cb31-22"><a href="#cb31-22"></a>        s.insert((nd){x,y}); sit a=s.find((nd){x,y});</span>
<span id="cb31-23"><a href="#cb31-23"></a>        sit b=--a; a++; sit c=++a; a--;</span>
<span id="cb31-24"><a href="#cb31-24"></a>        <span class="cf">if</span>(b-&gt;r&gt;=y&amp;&amp;b-&gt;l!=-INF){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,i-<span class="dv">1</span>); <span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb31-25"><a href="#cb31-25"></a>        <span class="cf">if</span>(c-&gt;r&lt;=y&amp;&amp;c-&gt;l!=INF){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,i-<span class="dv">1</span>); <span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb31-26"><a href="#cb31-26"></a>    }</span>
<span id="cb31-27"><a href="#cb31-27"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,n); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb31-28"><a href="#cb31-28"></a>}</span></code></pre></div>
<h3 id="bzoj3380usaco2004-opencave-cows-1-洞穴里的牛之一2016.9.9">bzoj3380[Usaco2004 Open]Cave Cows 1 洞穴里的牛之一*（2016.9.9）</h3>
<h4 id="题意-31">题意</h4>
<p>给一个无向图，每一条边都有一个阈值，有一些点有草。牛从点1出发，每当它到达有草的点可以选择吃或不吃，如果吃的话体重加1。对于边如果它的阈值小于牛的体重，则此边不可通过。求牛走一圈回到点1的最大体重。有草节点数≤14。点数≤100，边数≤1000。</p>
<h4 id="题解-31">题解</h4>
<p>f[i][S]表示当前点为i，草状态为S的状态能否达到。具体看代码。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb32-7"><a href="#cb32-7"></a></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb32-9"><a href="#cb32-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb32-10"><a href="#cb32-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb32-11"><a href="#cb32-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb32-12"><a href="#cb32-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb32-13"><a href="#cb32-13"></a>}</span>
<span id="cb32-14"><a href="#cb32-14"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}es[maxn*<span class="dv">20</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb32-15"><a href="#cb32-15"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){</span>
<span id="cb32-16"><a href="#cb32-16"></a>    es[++ess]=(e){t,w,g[f]}; g[f]=ess; es[++ess]=(e){f,w,g[t]}; g[t]=ess;</span>
<span id="cb32-17"><a href="#cb32-17"></a>}</span>
<span id="cb32-18"><a href="#cb32-18"></a><span class="dt">bool</span> vis[maxn][<span class="dv">17000</span>]; <span class="dt">int</span> ans,a[<span class="dv">17000</span>],n,m,k,b[maxn];</span>
<span id="cb32-19"><a href="#cb32-19"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb32-20"><a href="#cb32-20"></a>    <span class="cf">if</span>(vis[x][y])<span class="cf">return</span>; vis[x][y]=<span class="dv">1</span>; <span class="cf">if</span>(x==<span class="dv">1</span>)ans=max(ans,a[y]);</span>
<span id="cb32-21"><a href="#cb32-21"></a>    <span class="cf">if</span>(b[x]&amp;&amp;(y&amp;(<span class="dv">1</span>&lt;&lt;(b[x]-<span class="dv">1</span>))))dfs(x,y^(<span class="dv">1</span>&lt;&lt;(b[x]-<span class="dv">1</span>)));</span>
<span id="cb32-22"><a href="#cb32-22"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].w&gt;=a[y])dfs(es[i].t,y);</span>
<span id="cb32-23"><a href="#cb32-23"></a>}</span>
<span id="cb32-24"><a href="#cb32-24"></a><span class="dt">int</span> main(){</span>
<span id="cb32-25"><a href="#cb32-25"></a>    n=read(); m=read(); k=read(); inc(i,<span class="dv">1</span>,k){<span class="dt">int</span> x=read(); b[x]=i;}</span>
<span id="cb32-26"><a href="#cb32-26"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(),z=read(); pe(x,y,z);}</span>
<span id="cb32-27"><a href="#cb32-27"></a>    inc(i,<span class="dv">0</span>,(<span class="dv">1</span>&lt;&lt;k)-<span class="dv">1</span>){inc(j,<span class="dv">0</span>,k-<span class="dv">1</span>)<span class="cf">if</span>(!(i&amp;(<span class="dv">1</span>&lt;&lt;j)))a[i]++;} dfs(<span class="dv">1</span>,(<span class="dv">1</span>&lt;&lt;k)-<span class="dv">1</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb32-28"><a href="#cb32-28"></a>}</span></code></pre></div>
<h3 id="bzoj3381usaco2004-opencave-cows-2-洞穴里的牛之二2016.9.12">bzoj3381[Usaco2004 Open]Cave Cows 2 洞穴里的牛之二*（2016.9.12）</h3>
<h4 id="题意-32">题意</h4>
<p>RMQ问题。序列长度≤25000，问题数≤25000。</p>
<h4 id="题解-32">题解</h4>
<p>倍增。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="pp">#define maxn </span><span class="dv">25100</span></span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb33-7"><a href="#cb33-7"></a></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb33-9"><a href="#cb33-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb33-10"><a href="#cb33-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb33-11"><a href="#cb33-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb33-12"><a href="#cb33-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb33-13"><a href="#cb33-13"></a>}</span>
<span id="cb33-14"><a href="#cb33-14"></a><span class="dt">int</span> n,m,lg[maxn],mn[maxn][<span class="dv">20</span>];</span>
<span id="cb33-15"><a href="#cb33-15"></a><span class="dt">int</span> main(){</span>
<span id="cb33-16"><a href="#cb33-16"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)mn[i][<span class="dv">0</span>]=read();</span>
<span id="cb33-17"><a href="#cb33-17"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;<span class="dv">1</span>&lt;&lt;i&lt;=n;i++)lg[<span class="dv">1</span>&lt;&lt;i]=i; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!lg[i])lg[i]=lg[i-<span class="dv">1</span>];</span>
<span id="cb33-18"><a href="#cb33-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;<span class="dv">1</span>&lt;&lt;i&lt;=n;i++)inc(j,<span class="dv">1</span>,n)<span class="cf">if</span>(j+(<span class="dv">1</span>&lt;&lt;i)-<span class="dv">1</span>&lt;=n)mn[j][i]=min(mn[j][i-<span class="dv">1</span>],mn[j+(<span class="dv">1</span>&lt;&lt;(i-<span class="dv">1</span>))][i-<span class="dv">1</span>]);</span>
<span id="cb33-19"><a href="#cb33-19"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb33-20"><a href="#cb33-20"></a>        <span class="dt">int</span> a=read(),b=read(),c=lg[b-a+<span class="dv">1</span>];</span>
<span id="cb33-21"><a href="#cb33-21"></a>        printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,min(mn[a][c],mn[b-(<span class="dv">1</span>&lt;&lt;c)+<span class="dv">1</span>][c]));</span>
<span id="cb33-22"><a href="#cb33-22"></a>    }</span>
<span id="cb33-23"><a href="#cb33-23"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb33-24"><a href="#cb33-24"></a>}</span></code></pre></div>
<h3 id="bzoj3382usaco2004-opencave-cows-3-洞穴里的牛之三2016.9.12">bzoj3382[Usaco2004 Open]Cave Cows 3 洞穴里的牛之三*（2016.9.12）</h3>
<h4 id="题意-33">题意</h4>
<p>n个点，求最远曼哈顿距离。n≤50000。</p>
<h4 id="题解-33">题解</h4>
<p>曼哈顿距离转切比雪夫距离（点(x,y)变为点(x+y,x-y)），然后输出最大横坐标-最小横坐标与最大纵坐标-最小纵坐标的较大值即可。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb34-8"><a href="#cb34-8"></a></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb34-10"><a href="#cb34-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb34-11"><a href="#cb34-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb34-12"><a href="#cb34-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb34-13"><a href="#cb34-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb34-14"><a href="#cb34-14"></a>}</span>
<span id="cb34-15"><a href="#cb34-15"></a><span class="dt">int</span> x[maxn],y[maxn],n,ans,mx,mn;</span>
<span id="cb34-16"><a href="#cb34-16"></a><span class="dt">int</span> main(){</span>
<span id="cb34-17"><a href="#cb34-17"></a>    n=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a=read(),b=read(); x[i]=a+b; y[i]=a-b;} ans=<span class="dv">0</span>;</span>
<span id="cb34-18"><a href="#cb34-18"></a>    mx=-INF; mn=INF; inc(i,<span class="dv">1</span>,n)mx=max(mx,x[i]),mn=min(mn,x[i]); ans=max(ans,mx-mn);</span>
<span id="cb34-19"><a href="#cb34-19"></a>    mx=-INF; mn=INF; inc(i,<span class="dv">1</span>,n)mx=max(mx,y[i]),mn=min(mn,y[i]); ans=max(ans,mx-mn);</span>
<span id="cb34-20"><a href="#cb34-20"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb34-21"><a href="#cb34-21"></a>}</span></code></pre></div>
<h3 id="bzoj3383usaco2004-opencave-cows-4-洞穴里的牛之四2016.9.12">bzoj3383[Usaco2004 Open]Cave Cows 4 洞穴里的牛之四*（2016.9.12）</h3>
<h4 id="题意-34">题意</h4>
<p>平面直角坐标系有n个点，从(0,0)出发，从一个点上可以跳到所有与它横纵坐标距离都≤2的点上，求最少步数使得纵坐标为T。</p>
<h4 id="题解-34">题解</h4>
<p>先用set存下所有的点。在做dp的时候把所有横纵坐标与当前节点距离≤2的节点都在set中查找，如果可以查到则可以转移到那个节点。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb35-8"><a href="#cb35-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb35-9"><a href="#cb35-9"></a></span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb35-11"><a href="#cb35-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb35-12"><a href="#cb35-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb35-13"><a href="#cb35-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb35-14"><a href="#cb35-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb35-15"><a href="#cb35-15"></a>}</span>
<span id="cb35-16"><a href="#cb35-16"></a><span class="dt">int</span> x[maxn],y[maxn],n,t,dis[maxn]; queue&lt;<span class="dt">int</span>&gt;q;</span>
<span id="cb35-17"><a href="#cb35-17"></a><span class="kw">struct</span> nd{</span>
<span id="cb35-18"><a href="#cb35-18"></a>    <span class="dt">int</span> x,y,id;</span>
<span id="cb35-19"><a href="#cb35-19"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd &amp;a)<span class="at">const</span>{<span class="cf">return</span> x!=a.x?x&lt;a.x:y&lt;a.y;}</span>
<span id="cb35-20"><a href="#cb35-20"></a>};</span>
<span id="cb35-21"><a href="#cb35-21"></a>set&lt;nd&gt;st;</span>
<span id="cb35-22"><a href="#cb35-22"></a><span class="dt">int</span> main(){</span>
<span id="cb35-23"><a href="#cb35-23"></a>    n=read(); t=read(); inc(i,<span class="dv">1</span>,n)x[i]=read(),y[i]=read(),st.insert((nd){x[i],y[i],i});</span>
<span id="cb35-24"><a href="#cb35-24"></a>    q.push(<span class="dv">0</span>); dis[<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb35-25"><a href="#cb35-25"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb35-26"><a href="#cb35-26"></a>        <span class="dt">int</span> z=q.front(); q.pop();</span>
<span id="cb35-27"><a href="#cb35-27"></a>        inc(i,-<span class="dv">2</span>,<span class="dv">2</span>)inc(j,-<span class="dv">2</span>,<span class="dv">2</span>){</span>
<span id="cb35-28"><a href="#cb35-28"></a>            set&lt;nd&gt;::iterator a=st.find((nd){x[z]+i,y[z]+j,<span class="dv">0</span>});</span>
<span id="cb35-29"><a href="#cb35-29"></a>            <span class="cf">if</span>(a!=st.end()){</span>
<span id="cb35-30"><a href="#cb35-30"></a>                dis[a-&gt;id]=dis[z]+<span class="dv">1</span>; q.push(a-&gt;id);</span>
<span id="cb35-31"><a href="#cb35-31"></a>                <span class="cf">if</span>(a-&gt;y==t){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dis[a-&gt;id]); <span class="cf">return</span> <span class="dv">0</span>;} st.erase(a);</span>
<span id="cb35-32"><a href="#cb35-32"></a>            }</span>
<span id="cb35-33"><a href="#cb35-33"></a>        }</span>
<span id="cb35-34"><a href="#cb35-34"></a>    }</span>
<span id="cb35-35"><a href="#cb35-35"></a>    printf(<span class="st">&quot;-1&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb35-36"><a href="#cb35-36"></a>}</span></code></pre></div>
<h3 id="bzoj3374usaco2004-marspecial-serial-numbers-特殊编号2016.9.12">bzoj3374[Usaco2004 Mar]Special Serial Numbers 特殊编号*（2016.9.12）</h3>
<h4 id="题意-35">题意</h4>
<p>求比一个数大的最小的一半以上的数位相同的数。数位数≤100。</p>
<h4 id="题解-35">题解</h4>
<p>模拟题。从低位枚举到高位，对于每一位枚举比原数该位大的数，同时枚举这一位之后要由0和哪一个数组成，最后得到一个最小的数输出。具体看代码。</p>
<p>有点像NOIP的那道Jam的计数法。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="pp">#define maxn </span><span class="dv">110</span></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb36-7"><a href="#cb36-7"></a></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="dt">char</span> str[maxn]; <span class="dt">int</span> sm[<span class="dv">10</span>][maxn],num[maxn],n;</span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="dt">int</span> main(){</span>
<span id="cb36-10"><a href="#cb36-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,str+<span class="dv">1</span>); n=strlen(str+<span class="dv">1</span>);</span>
<span id="cb36-11"><a href="#cb36-11"></a>    inc(i,<span class="dv">1</span>,n){num[i]=str[i]-<span class="ch">&#39;0&#39;</span>; inc(j,<span class="dv">0</span>,<span class="dv">9</span>)sm[j][i]=sm[j][i-<span class="dv">1</span>]; sm[num[i]][i]++;}</span>
<span id="cb36-12"><a href="#cb36-12"></a>    inc(i,num[n],<span class="dv">9</span>){</span>
<span id="cb36-13"><a href="#cb36-13"></a>        inc(j,<span class="dv">0</span>,<span class="dv">9</span>)<span class="cf">if</span>(sm[j][n-<span class="dv">1</span>]+(i==j)&gt;n/<span class="dv">2</span>){inc(k,<span class="dv">1</span>,n-<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,num[k]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,i); <span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb36-14"><a href="#cb36-14"></a>    }</span>
<span id="cb36-15"><a href="#cb36-15"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n-<span class="dv">1</span>;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb36-16"><a href="#cb36-16"></a>        inc(j,num[i]+<span class="dv">1</span>,<span class="dv">9</span>){</span>
<span id="cb36-17"><a href="#cb36-17"></a>            <span class="dt">int</span> mn1=n-i+<span class="dv">1</span>,mn2;</span>
<span id="cb36-18"><a href="#cb36-18"></a>            inc(k,<span class="dv">0</span>,<span class="dv">9</span>)<span class="cf">if</span>(n/<span class="dv">2</span>+<span class="dv">1</span>-(sm[k][i-<span class="dv">1</span>]+(k==j))&lt;mn1)mn1=n/<span class="dv">2</span>+<span class="dv">1</span>-(sm[k][i-<span class="dv">1</span>]+(k==j)),mn2=k;</span>
<span id="cb36-19"><a href="#cb36-19"></a>            <span class="cf">if</span>(mn1!=n-i+<span class="dv">1</span>){</span>
<span id="cb36-20"><a href="#cb36-20"></a>                inc(k,<span class="dv">1</span>,i-<span class="dv">1</span>)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,num[k]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,j); inc(k,<span class="dv">1</span>,n-i-mn1)printf(<span class="st">&quot;0&quot;</span>);</span>
<span id="cb36-21"><a href="#cb36-21"></a>                inc(k,<span class="dv">1</span>,mn1)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,mn2); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb36-22"><a href="#cb36-22"></a>            }</span>
<span id="cb36-23"><a href="#cb36-23"></a>        }</span>
<span id="cb36-24"><a href="#cb36-24"></a>    }</span>
<span id="cb36-25"><a href="#cb36-25"></a>}</span></code></pre></div>
<h3 id="bzoj2442usaco2011-open修剪草坪2016.9.12">bzoj2442[Usaco2011 Open]修剪草坪*（2016.9.12）</h3>
<h4 id="题意-36">题意</h4>
<p>从一个序列中选n个数，要求这些数中不能有超过k个数在原序列中位置是连续的。求最大的取数之和。n≤100000。</p>
<h4 id="题解-36">题解</h4>
<p>f[i]表示不选i，1到i-1可以得到的最大取数之和。则f[i]=max(f[j]+sum[i-1]-sum[j]),i-j≤k。j比k好当且仅当f[j]+sum[i-1]-sum[j]&gt;f[k]+sum[i-1]-sum[k]，即f[j]-sum[j]＞f[k]-sum[k]。故只要用单调队列维护f[j]-sum[j]即可。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb37-8"><a href="#cb37-8"></a></span>
<span id="cb37-9"><a href="#cb37-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb37-10"><a href="#cb37-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb37-11"><a href="#cb37-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb37-12"><a href="#cb37-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb37-13"><a href="#cb37-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb37-14"><a href="#cb37-14"></a>}</span>
<span id="cb37-15"><a href="#cb37-15"></a>ll sm[maxn],q1[maxn],f[maxn]; <span class="dt">int</span> n,k,l,r,q2[maxn];</span>
<span id="cb37-16"><a href="#cb37-16"></a><span class="dt">int</span> main(){</span>
<span id="cb37-17"><a href="#cb37-17"></a>    n=read(); k=read(); inc(i,<span class="dv">1</span>,n)sm[i]=sm[i-<span class="dv">1</span>]+read();</span>
<span id="cb37-18"><a href="#cb37-18"></a>    l=<span class="dv">1</span>; r=<span class="dv">2</span>; q1[l]=q2[l]=<span class="dv">0</span>; q1[r]=-sm[<span class="dv">1</span>]; q2[r]=<span class="dv">1</span>;</span>
<span id="cb37-19"><a href="#cb37-19"></a>    inc(i,<span class="dv">2</span>,n+<span class="dv">1</span>){</span>
<span id="cb37-20"><a href="#cb37-20"></a>        <span class="cf">while</span>(l&lt;=r&amp;&amp;q2[l]&lt;i-k-<span class="dv">1</span>)l++; f[i]=q1[l]+sm[i-<span class="dv">1</span>];</span>
<span id="cb37-21"><a href="#cb37-21"></a>        <span class="cf">while</span>(l&lt;=r&amp;&amp;f[i]-sm[i]&gt;=q1[r])r--; q1[++r]=f[i]-sm[i]; q2[r]=i;</span>
<span id="cb37-22"><a href="#cb37-22"></a>    }</span>
<span id="cb37-23"><a href="#cb37-23"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f[n+<span class="dv">1</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb37-24"><a href="#cb37-24"></a>}</span></code></pre></div>
<h3 id="bzoj1715usaco2006-decwormholes-虫洞2016.9.12">bzoj1715[Usaco2006 Dec]Wormholes 虫洞*（2016.9.12）</h3>
<h4 id="题意-37">题意</h4>
<p>判一个图是否有负环。点数≤500，边数≤3000。（我看不懂原题，后来看了题解，就直接这样说了）</p>
<h4 id="题解-37">题解</h4>
<p>SPFA中如果一个点被更新了n次以上，那么这个图中存在负环。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb38-4"><a href="#cb38-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb38-6"><a href="#cb38-6"></a><span class="pp">#define maxn </span><span class="dv">510</span></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb38-8"><a href="#cb38-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb38-9"><a href="#cb38-9"></a></span>
<span id="cb38-10"><a href="#cb38-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb38-11"><a href="#cb38-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb38-12"><a href="#cb38-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb38-13"><a href="#cb38-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb38-14"><a href="#cb38-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb38-15"><a href="#cb38-15"></a>}</span>
<span id="cb38-16"><a href="#cb38-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}es[maxn*<span class="dv">15</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb38-17"><a href="#cb38-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess;}</span>
<span id="cb38-18"><a href="#cb38-18"></a><span class="dt">int</span> f,n,m,w,d[maxn],cnt[maxn]; <span class="dt">bool</span> inq[maxn]; queue&lt;<span class="dt">int</span>&gt;q;</span>
<span id="cb38-19"><a href="#cb38-19"></a><span class="dt">bool</span> spfa(){</span>
<span id="cb38-20"><a href="#cb38-20"></a>    <span class="cf">while</span>(!q.empty())q.pop(); inc(i,<span class="dv">1</span>,n)d[i]=INF,cnt[i]=inq[i]=<span class="dv">0</span>; d[<span class="dv">1</span>]=<span class="dv">0</span>; inq[<span class="dv">1</span>]=<span class="dv">1</span>; q.push(<span class="dv">1</span>);</span>
<span id="cb38-21"><a href="#cb38-21"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb38-22"><a href="#cb38-22"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb38-23"><a href="#cb38-23"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t]&gt;d[x]+es[i].w){</span>
<span id="cb38-24"><a href="#cb38-24"></a>            d[es[i].t]=d[x]+es[i].w; cnt[es[i].t]++; <span class="cf">if</span>(cnt[es[i].t]&gt;n)<span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb38-25"><a href="#cb38-25"></a>            <span class="cf">if</span>(!inq[es[i].t])q.push(es[i].t),inq[es[i].t]=<span class="dv">1</span>;</span>
<span id="cb38-26"><a href="#cb38-26"></a>        }</span>
<span id="cb38-27"><a href="#cb38-27"></a>    }</span>
<span id="cb38-28"><a href="#cb38-28"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb38-29"><a href="#cb38-29"></a>}</span>
<span id="cb38-30"><a href="#cb38-30"></a><span class="dt">int</span> main(){</span>
<span id="cb38-31"><a href="#cb38-31"></a>    f=read();</span>
<span id="cb38-32"><a href="#cb38-32"></a>    <span class="cf">while</span>(f--){</span>
<span id="cb38-33"><a href="#cb38-33"></a>        n=read(); m=read(); w=read(); memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g)); ess=<span class="dv">0</span>;</span>
<span id="cb38-34"><a href="#cb38-34"></a>        inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(),z=read(); pe(x,y,z); pe(y,x,z);}</span>
<span id="cb38-35"><a href="#cb38-35"></a>        inc(i,<span class="dv">1</span>,w){<span class="dt">int</span> x=read(),y=read(),z=read(); pe(x,y,-z);}</span>
<span id="cb38-36"><a href="#cb38-36"></a>        <span class="cf">if</span>(spfa())puts(<span class="st">&quot;YES&quot;</span>);<span class="cf">else</span> puts(<span class="st">&quot;NO&quot;</span>);</span>
<span id="cb38-37"><a href="#cb38-37"></a>    }</span>
<span id="cb38-38"><a href="#cb38-38"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb38-39"><a href="#cb38-39"></a>}</span></code></pre></div>
<h3 id="bzoj1602usaco2008-oct牧场行走2016.9.13">bzoj1602[Usaco2008 Oct]牧场行走*（2016.9.13）</h3>
<h4 id="题意-38">题意</h4>
<p>n点树（有边权），q个询问求两个点之间的最短距离。n，q≤1000。</p>
<h4 id="题解-38">题解</h4>
<p>倍增求lca。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb39-4"><a href="#cb39-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb39-5"><a href="#cb39-5"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb39-6"><a href="#cb39-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb39-7"><a href="#cb39-7"></a></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb39-9"><a href="#cb39-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb39-10"><a href="#cb39-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb39-11"><a href="#cb39-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb39-12"><a href="#cb39-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb39-13"><a href="#cb39-13"></a>}</span>
<span id="cb39-14"><a href="#cb39-14"></a><span class="dt">int</span> f[<span class="dv">15</span>][maxn],h[<span class="dv">15</span>][maxn],n,q,k,dep[maxn];</span>
<span id="cb39-15"><a href="#cb39-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> ess,g[maxn];</span>
<span id="cb39-16"><a href="#cb39-16"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess; es[++ess]=(e){f,w,g[t]}; g[t]=ess;}</span>
<span id="cb39-17"><a href="#cb39-17"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> fa){</span>
<span id="cb39-18"><a href="#cb39-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa){</span>
<span id="cb39-19"><a href="#cb39-19"></a>        f[<span class="dv">0</span>][es[i].t]=x; h[<span class="dv">0</span>][es[i].t]=es[i].w; dep[es[i].t]=dep[x]+<span class="dv">1</span>; dfs(es[i].t,x);</span>
<span id="cb39-20"><a href="#cb39-20"></a>    }</span>
<span id="cb39-21"><a href="#cb39-21"></a>}</span>
<span id="cb39-22"><a href="#cb39-22"></a><span class="dt">void</span> init(){</span>
<span id="cb39-23"><a href="#cb39-23"></a>    <span class="cf">for</span>(k=<span class="dv">0</span>;(<span class="dv">1</span>&lt;&lt;k)&lt;=n;k++); k--;</span>
<span id="cb39-24"><a href="#cb39-24"></a>    inc(i,<span class="dv">1</span>,k)inc(j,<span class="dv">1</span>,n)f[i][j]=f[i-<span class="dv">1</span>][f[i-<span class="dv">1</span>][j]],h[i][j]=h[i-<span class="dv">1</span>][j]+h[i-<span class="dv">1</span>][f[i-<span class="dv">1</span>][j]];</span>
<span id="cb39-25"><a href="#cb39-25"></a>}</span>
<span id="cb39-26"><a href="#cb39-26"></a><span class="dt">int</span> query(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb39-27"><a href="#cb39-27"></a>    <span class="cf">if</span>(dep[x]&lt;dep[y])swap(x,y); <span class="dt">int</span> t=dep[x]-dep[y],q=<span class="dv">0</span>;</span>
<span id="cb39-28"><a href="#cb39-28"></a>    inc(i,<span class="dv">0</span>,k)<span class="cf">if</span>(t&amp;(<span class="dv">1</span>&lt;&lt;i))q+=h[i][x],x=f[i][x];</span>
<span id="cb39-29"><a href="#cb39-29"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=k;i&gt;=<span class="dv">0</span>;i--)<span class="cf">if</span>(f[i][x]!=f[i][y])q+=(h[i][x]+h[i][y]),x=f[i][x],y=f[i][y];</span>
<span id="cb39-30"><a href="#cb39-30"></a>    <span class="cf">if</span>(x==y)<span class="cf">return</span> q;<span class="cf">else</span> <span class="cf">return</span> q+=(h[<span class="dv">0</span>][x]+h[<span class="dv">0</span>][y]);</span>
<span id="cb39-31"><a href="#cb39-31"></a>}</span>
<span id="cb39-32"><a href="#cb39-32"></a><span class="dt">int</span> main(){</span>
<span id="cb39-33"><a href="#cb39-33"></a>    n=read(); q=read(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> a=read(),b=read(),c=read(); pe(a,b,c);} dfs(<span class="dv">1</span>,<span class="dv">0</span>); init();</span>
<span id="cb39-34"><a href="#cb39-34"></a>    inc(i,<span class="dv">1</span>,q){<span class="dt">int</span> a=read(),b=read(); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query(a,b));} <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb39-35"><a href="#cb39-35"></a>}</span></code></pre></div>
<h3 id="bzoj1613usaco2007-janrunning贝茜的晨练计划2016.9.13">bzoj1613[Usaco2007 Jan]Running贝茜的晨练计划*（2016.9.13）</h3>
<h4 id="题意-39">题意</h4>
<p>贝茜进行N分钟的晨跑。在每分钟的开始，贝茜会选择下一分钟是用来跑步还是休息，如果贝茜选择在第i分钟内跑步，她可以在这一分钟内跑Di米，并且她的疲劳度会增加 1。贝茜的疲劳度上限为M。如果贝茜选择休息，那么她的疲劳度就会每分钟减少1，但她必须休息到疲劳度恢复到0为止。在疲劳度为0时休息的话，疲劳度不会再变动。晨跑开始时，贝茜的疲劳度为0。 还有，在N分钟的锻炼结束时，贝茜的疲劳度也必须恢复到0。求贝茜最多能跑多少米。n≤10000，m≤500。</p>
<h4 id="题解-39">题解</h4>
<p>dp。f[i][j]表示现在是第i分钟，疲劳度为j。具体看代码。注意当贝茜疲劳度为0时也可以休息，过渡到下一分钟且疲劳度不变。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="pp">#define maxn </span><span class="dv">510</span></span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb40-7"><a href="#cb40-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb40-8"><a href="#cb40-8"></a></span>
<span id="cb40-9"><a href="#cb40-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb40-10"><a href="#cb40-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb40-11"><a href="#cb40-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb40-12"><a href="#cb40-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb40-13"><a href="#cb40-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb40-14"><a href="#cb40-14"></a>}</span>
<span id="cb40-15"><a href="#cb40-15"></a><span class="dt">int</span> f[maxn*<span class="dv">20</span>][maxn],d[maxn*<span class="dv">20</span>],n,m;</span>
<span id="cb40-16"><a href="#cb40-16"></a><span class="dt">int</span> main(){</span>
<span id="cb40-17"><a href="#cb40-17"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)d[i]=read(); f[n+<span class="dv">1</span>][<span class="dv">0</span>]=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,m)f[n+<span class="dv">1</span>][i]=-INF;</span>
<span id="cb40-18"><a href="#cb40-18"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--)</span>
<span id="cb40-19"><a href="#cb40-19"></a>        inc(j,<span class="dv">0</span>,m){</span>
<span id="cb40-20"><a href="#cb40-20"></a>            <span class="cf">if</span>(i+j&gt;n+<span class="dv">1</span>)f[i][j]=-INF; <span class="cf">else</span> <span class="cf">if</span>(j==m)f[i][j]=f[i+j][<span class="dv">0</span>];</span>
<span id="cb40-21"><a href="#cb40-21"></a>            <span class="cf">else</span> <span class="cf">if</span>(j==<span class="dv">0</span>)f[i][j]=max(f[i+<span class="dv">1</span>][j+<span class="dv">1</span>]+d[i],f[i+<span class="dv">1</span>][<span class="dv">0</span>]);</span>
<span id="cb40-22"><a href="#cb40-22"></a>            <span class="cf">else</span> f[i][j]=max(f[i+<span class="dv">1</span>][j+<span class="dv">1</span>]+d[i],f[i+j][<span class="dv">0</span>]);</span>
<span id="cb40-23"><a href="#cb40-23"></a>        }</span>
<span id="cb40-24"><a href="#cb40-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[<span class="dv">1</span>][<span class="dv">0</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb40-25"><a href="#cb40-25"></a>}</span></code></pre></div>
<h3 id="bzoj1230usaco2008-novlites-开关灯2016.9.17">bzoj1230[Usaco2008 Nov]lites 开关灯*（2016.9.17）</h3>
<h4 id="题意-40">题意</h4>
<p>一个01序列，初始全部元素为0，两种操作：l到r全部元素取反、询问l到r1的个数。序列长度≤100000，询问个数≤100000。</p>
<h4 id="题解-40">题解</h4>
<p>线段树维护区间和，区间修改就让区间和变为区间长度减原区间和。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb41-5"><a href="#cb41-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb41-6"><a href="#cb41-6"></a><span class="pp">#define maxn </span><span class="dv">400010</span></span>
<span id="cb41-7"><a href="#cb41-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb41-8"><a href="#cb41-8"></a></span>
<span id="cb41-9"><a href="#cb41-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb41-10"><a href="#cb41-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb41-11"><a href="#cb41-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb41-12"><a href="#cb41-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb41-13"><a href="#cb41-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb41-14"><a href="#cb41-14"></a>}</span>
<span id="cb41-15"><a href="#cb41-15"></a><span class="dt">int</span> sm[maxn],n,m,lr[maxn]; <span class="dt">bool</span> tg[maxn];</span>
<span id="cb41-16"><a href="#cb41-16"></a><span class="dt">void</span> update(<span class="dt">int</span> x){sm[x]=sm[x&lt;&lt;<span class="dv">1</span>]+sm[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>];}</span>
<span id="cb41-17"><a href="#cb41-17"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb41-18"><a href="#cb41-18"></a>    <span class="cf">if</span>(tg[x]){</span>
<span id="cb41-19"><a href="#cb41-19"></a>        <span class="cf">if</span>(lr[x&lt;&lt;<span class="dv">1</span>])sm[x&lt;&lt;<span class="dv">1</span>]=lr[x&lt;&lt;<span class="dv">1</span>]-sm[x&lt;&lt;<span class="dv">1</span>],tg[x&lt;&lt;<span class="dv">1</span>]^=<span class="dv">1</span>;</span>
<span id="cb41-20"><a href="#cb41-20"></a>        <span class="cf">if</span>(lr[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>])sm[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=lr[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]-sm[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>],tg[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]^=<span class="dv">1</span>;</span>
<span id="cb41-21"><a href="#cb41-21"></a>        tg[x]^=<span class="dv">1</span>;</span>
<span id="cb41-22"><a href="#cb41-22"></a>    }</span>
<span id="cb41-23"><a href="#cb41-23"></a>}</span>
<span id="cb41-24"><a href="#cb41-24"></a><span class="dt">void</span> build(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb41-25"><a href="#cb41-25"></a>    lr[x]=r-l+<span class="dv">1</span>; <span class="cf">if</span>(l==r)<span class="cf">return</span>; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; build(x&lt;&lt;<span class="dv">1</span>,l,mid); build(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r);</span>
<span id="cb41-26"><a href="#cb41-26"></a>}</span>
<span id="cb41-27"><a href="#cb41-27"></a><span class="dt">void</span> modify(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb41-28"><a href="#cb41-28"></a>    pushdown(x); <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr){tg[x]^=<span class="dv">1</span>; sm[x]=lr[x]-sm[x]; <span class="cf">return</span>;} <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb41-29"><a href="#cb41-29"></a>    <span class="cf">if</span>(ql&lt;=mid)modify(x&lt;&lt;<span class="dv">1</span>,l,mid,ql,qr); <span class="cf">if</span>(mid&lt;qr)modify(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r,ql,qr); update(x);</span>
<span id="cb41-30"><a href="#cb41-30"></a>}</span>
<span id="cb41-31"><a href="#cb41-31"></a><span class="dt">int</span> query(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb41-32"><a href="#cb41-32"></a>    pushdown(x); <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr)<span class="cf">return</span> sm[x]; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>,q=<span class="dv">0</span>;</span>
<span id="cb41-33"><a href="#cb41-33"></a>    <span class="cf">if</span>(ql&lt;=mid)q+=query(x&lt;&lt;<span class="dv">1</span>,l,mid,ql,qr); <span class="cf">if</span>(mid&lt;qr)q+=query(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r,ql,qr); <span class="cf">return</span> q;</span>
<span id="cb41-34"><a href="#cb41-34"></a>}</span>
<span id="cb41-35"><a href="#cb41-35"></a><span class="dt">int</span> main(){</span>
<span id="cb41-36"><a href="#cb41-36"></a>    n=read(); m=read(); build(<span class="dv">1</span>,<span class="dv">1</span>,n);</span>
<span id="cb41-37"><a href="#cb41-37"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb41-38"><a href="#cb41-38"></a>        <span class="dt">int</span> opt=read(),l=read(),r=read(); <span class="cf">if</span>(!opt)modify(<span class="dv">1</span>,<span class="dv">1</span>,n,l,r);<span class="cf">else</span> printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,query(<span class="dv">1</span>,<span class="dv">1</span>,n,l,r));</span>
<span id="cb41-39"><a href="#cb41-39"></a>    }</span>
<span id="cb41-40"><a href="#cb41-40"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb41-41"><a href="#cb41-41"></a>}</span></code></pre></div>
<h3 id="bzoj1599usaco2008-oct笨重的石子2016.9.17">bzoj1599[Usaco2008 Oct]笨重的石子*（2016.9.17）</h3>
<h4 id="题意-41">题意</h4>
<p>三个不同的骰子，分别有S1,S2,S3个面。求出出现几率最大的和是多少。如果有很多种和出现的几率相同，那么就输出小的那一个。2≤S1≤20，2≤S2≤20，2≤S3≤40。</p>
<h4 id="题解-41">题解</h4>
<p>枚举。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb42-4"><a href="#cb42-4"></a></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="dt">int</span> a,b,c,cnt[<span class="dv">100</span>],mx1,mx2;</span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="dt">int</span> main(){</span>
<span id="cb42-7"><a href="#cb42-7"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d%d</span><span class="st">&quot;</span>,&amp;a,&amp;b,&amp;c); inc(i,<span class="dv">1</span>,a)inc(j,<span class="dv">1</span>,b)inc(k,<span class="dv">1</span>,c)cnt[i+j+k]++;</span>
<span id="cb42-8"><a href="#cb42-8"></a>    mx1=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,a+b+c)<span class="cf">if</span>(cnt[i]&gt;mx1)mx1=cnt[i],mx2=i; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,mx2); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb42-9"><a href="#cb42-9"></a>}</span></code></pre></div>
<h3 id="bzoj1603usaco2008-oct打谷机2016.9.17">bzoj1603[Usaco2008 Oct]打谷机*（2016.9.17）</h3>
<h4 id="题意-42">题意</h4>
<p>给个树，每个边都有边权0和1。0表示两个端点同色，1表示两个端点不同色。点1为黑色，问点n哪种颜色（颜色只有两种：黑和白）。树大小≤1000。</p>
<h4 id="题解-42">题解</h4>
<p>dfs一发。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb43-8"><a href="#cb43-8"></a></span>
<span id="cb43-9"><a href="#cb43-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb43-10"><a href="#cb43-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb43-11"><a href="#cb43-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb43-12"><a href="#cb43-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb43-13"><a href="#cb43-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb43-14"><a href="#cb43-14"></a>}</span>
<span id="cb43-15"><a href="#cb43-15"></a><span class="dt">int</span> g[maxn][maxn],n,ans[maxn];</span>
<span id="cb43-16"><a href="#cb43-16"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> fa){</span>
<span id="cb43-17"><a href="#cb43-17"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(i!=fa&amp;&amp;g[x][i]!=-<span class="dv">1</span>)ans[i]=ans[x]^g[x][i],dfs(i,x);</span>
<span id="cb43-18"><a href="#cb43-18"></a>}</span>
<span id="cb43-19"><a href="#cb43-19"></a><span class="dt">int</span> main(){</span>
<span id="cb43-20"><a href="#cb43-20"></a>    n=read(); memset(g,-<span class="dv">1</span>,<span class="kw">sizeof</span>(g)); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> x=read(),y=read(),z=read(); g[x][y]=g[y][x]=z;}</span>
<span id="cb43-21"><a href="#cb43-21"></a>    dfs(<span class="dv">1</span>,<span class="dv">0</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans[n]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb43-22"><a href="#cb43-22"></a>}</span></code></pre></div>
<h3 id="bzoj1611usaco2008-febmeteor-shower流星雨2016.9.17">bzoj1611[Usaco2008 Feb]Meteor Shower流星雨*（2016.9.17）</h3>
<h4 id="题意-43">题意</h4>
<p>给个网格，有m个流星，每个流星在ti时刻打在(xi,yi)的格子上，并把该格子和相邻的格子打烂。有个人从(0,0)出发，问最短逃离时间（格子被打烂之后就不能走）。</p>
<h4 id="题解-43">题解</h4>
<p>bfs一发，如果某格子被打烂的时间小于到达时间则不能到达，最后如果到达打烂时间为正无穷的格子即为成功逃出。注意网格的边界应该大于流星的边界，因为如果逃到那些地方也算安全地带。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="pp">#define maxn </span><span class="dv">500</span></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb44-8"><a href="#cb44-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb44-9"><a href="#cb44-9"></a></span>
<span id="cb44-10"><a href="#cb44-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb44-11"><a href="#cb44-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb44-12"><a href="#cb44-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb44-13"><a href="#cb44-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb44-14"><a href="#cb44-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb44-15"><a href="#cb44-15"></a>}</span>
<span id="cb44-16"><a href="#cb44-16"></a><span class="dt">int</span> m,vis[maxn][maxn],ear[maxn][maxn]; queue&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; &gt;q;</span>
<span id="cb44-17"><a href="#cb44-17"></a><span class="dt">int</span> bfs(){</span>
<span id="cb44-18"><a href="#cb44-18"></a>    q.push(make_pair(<span class="dv">1</span>,<span class="dv">1</span>)); <span class="cf">if</span>(!ear[<span class="dv">1</span>][<span class="dv">1</span>])<span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb44-19"><a href="#cb44-19"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb44-20"><a href="#cb44-20"></a>        <span class="dt">int</span> x=q.front().first,y=q.front().second; q.pop();</span>
<span id="cb44-21"><a href="#cb44-21"></a>        <span class="cf">if</span>(x&gt;<span class="dv">1</span>&amp;&amp;!vis[x-<span class="dv">1</span>][y]&amp;&amp;ear[x-<span class="dv">1</span>][y]&gt;vis[x][y]+<span class="dv">1</span>){</span>
<span id="cb44-22"><a href="#cb44-22"></a>            vis[x-<span class="dv">1</span>][y]=vis[x][y]+<span class="dv">1</span>; <span class="cf">if</span>(ear[x-<span class="dv">1</span>][y]==INF)<span class="cf">return</span> vis[x-<span class="dv">1</span>][y]; q.push(make_pair(x-<span class="dv">1</span>,y));</span>
<span id="cb44-23"><a href="#cb44-23"></a>        }</span>
<span id="cb44-24"><a href="#cb44-24"></a>        <span class="cf">if</span>(!vis[x+<span class="dv">1</span>][y]&amp;&amp;ear[x+<span class="dv">1</span>][y]&gt;vis[x][y]+<span class="dv">1</span>){</span>
<span id="cb44-25"><a href="#cb44-25"></a>            vis[x+<span class="dv">1</span>][y]=vis[x][y]+<span class="dv">1</span>; <span class="cf">if</span>(ear[x+<span class="dv">1</span>][y]==INF)<span class="cf">return</span> vis[x+<span class="dv">1</span>][y]; q.push(make_pair(x+<span class="dv">1</span>,y));</span>
<span id="cb44-26"><a href="#cb44-26"></a>        }</span>
<span id="cb44-27"><a href="#cb44-27"></a>        <span class="cf">if</span>(y&gt;<span class="dv">1</span>&amp;&amp;!vis[x][y-<span class="dv">1</span>]&amp;&amp;ear[x][y-<span class="dv">1</span>]&gt;vis[x][y]+<span class="dv">1</span>){</span>
<span id="cb44-28"><a href="#cb44-28"></a>            vis[x][y-<span class="dv">1</span>]=vis[x][y]+<span class="dv">1</span>; <span class="cf">if</span>(ear[x][y-<span class="dv">1</span>]==INF)<span class="cf">return</span> vis[x][y-<span class="dv">1</span>]; q.push(make_pair(x,y-<span class="dv">1</span>));</span>
<span id="cb44-29"><a href="#cb44-29"></a>        }</span>
<span id="cb44-30"><a href="#cb44-30"></a>        <span class="cf">if</span>(!vis[x][y+<span class="dv">1</span>]&amp;&amp;ear[x][y+<span class="dv">1</span>]&gt;vis[x][y]+<span class="dv">1</span>){</span>
<span id="cb44-31"><a href="#cb44-31"></a>            vis[x][y+<span class="dv">1</span>]=vis[x][y]+<span class="dv">1</span>; <span class="cf">if</span>(ear[x][y+<span class="dv">1</span>]==INF)<span class="cf">return</span> vis[x][y+<span class="dv">1</span>]; q.push(make_pair(x,y+<span class="dv">1</span>));</span>
<span id="cb44-32"><a href="#cb44-32"></a>        }</span>
<span id="cb44-33"><a href="#cb44-33"></a>    }</span>
<span id="cb44-34"><a href="#cb44-34"></a>    <span class="cf">return</span> -<span class="dv">1</span>;</span>
<span id="cb44-35"><a href="#cb44-35"></a>}</span>
<span id="cb44-36"><a href="#cb44-36"></a><span class="dt">int</span> main(){</span>
<span id="cb44-37"><a href="#cb44-37"></a>    m=read(); inc(i,<span class="dv">0</span>,<span class="dv">400</span>)inc(j,<span class="dv">0</span>,<span class="dv">400</span>)ear[i][j]=INF;</span>
<span id="cb44-38"><a href="#cb44-38"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb44-39"><a href="#cb44-39"></a>        <span class="dt">int</span> x=read()+<span class="dv">1</span>,y=read()+<span class="dv">1</span>,z=read();</span>
<span id="cb44-40"><a href="#cb44-40"></a>        inc(i,-<span class="dv">1</span>,<span class="dv">1</span>)ear[x+i][y]=min(ear[x+i][y],z),ear[x][y+i]=min(ear[x][y+i],z);</span>
<span id="cb44-41"><a href="#cb44-41"></a>    }</span>
<span id="cb44-42"><a href="#cb44-42"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,bfs()); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb44-43"><a href="#cb44-43"></a>}</span></code></pre></div>
<h3 id="bzoj1724usaco2006-novfence-repair-切割木板2016.9.17">bzoj1724[Usaco2006 Nov]Fence Repair 切割木板*（2016.9.17）</h3>
<h4 id="题意-44">题意</h4>
<p>FJ需要n块木板，第i块木板长度为ai。但他只有一块长度为sigma(i,1,n)ai的木板。每切一次的代价为所切割木板的长度，问最小代价。n≤20000</p>
<h4 id="题解-44">题解</h4>
<p>等价于合并石子（把单块木板的长度看作石子）。故用一个优先队列，每次找最小的两个堆合并起来再放入优先队列，代价计入答案。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb45-5"><a href="#cb45-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb45-6"><a href="#cb45-6"></a><span class="pp">#define maxn </span><span class="dv">20010</span></span>
<span id="cb45-7"><a href="#cb45-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb45-8"><a href="#cb45-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb45-9"><a href="#cb45-9"></a></span>
<span id="cb45-10"><a href="#cb45-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb45-11"><a href="#cb45-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb45-12"><a href="#cb45-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb45-13"><a href="#cb45-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb45-14"><a href="#cb45-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb45-15"><a href="#cb45-15"></a>}</span>
<span id="cb45-16"><a href="#cb45-16"></a><span class="dt">int</span> n; ll ans;</span>
<span id="cb45-17"><a href="#cb45-17"></a><span class="kw">struct</span> nd{ll a; <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd &amp;b)<span class="at">const</span>{<span class="cf">return</span> a&gt;b.a;}}; priority_queue&lt;nd&gt;q;</span>
<span id="cb45-18"><a href="#cb45-18"></a><span class="dt">int</span> main(){</span>
<span id="cb45-19"><a href="#cb45-19"></a>    n=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(); q.push((nd){x});}</span>
<span id="cb45-20"><a href="#cb45-20"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){ll x=q.top().a; q.pop(); ll y=q.top().a; q.pop(); q.push((nd){x+y}); ans+=x+y;}</span>
<span id="cb45-21"><a href="#cb45-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb45-22"><a href="#cb45-22"></a>}</span></code></pre></div>
<h3 id="bzoj1621usaco2008-openroads-around-the-farm分岔路口2016.9.18">bzoj1621[Usaco2008 Open]Roads Around The Farm分岔路口*（2016.9.18）</h3>
<h4 id="题意-45">题意</h4>
<p>n头牛在路上走，每当它们走到岔路，如果这些牛可以分为数量相差刚好为k的两群，那么它们就会分成这样的两群往前走，否则就会停下来吃草。问最后有多少群在吃草。n≤10^9，k≤1000。</p>
<h4 id="题解-45">题解</h4>
<p>暴力模拟。（好像实际上不管有多少只牛只要经过3、4个岔路后就会无法再分并停下来吃草）</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="dt">int</span> n,k,ans;</span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="dt">void</span> dfs(<span class="dt">int</span> n,<span class="dt">int</span> k){</span>
<span id="cb46-4"><a href="#cb46-4"></a>    <span class="cf">if</span>(n&gt;k&amp;&amp;(!((n-k)&amp;<span class="dv">1</span>)))dfs((n-k)/<span class="dv">2</span>,k),dfs((n-k)/<span class="dv">2</span>+k,k);<span class="cf">else</span> ans++;</span>
<span id="cb46-5"><a href="#cb46-5"></a>}</span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="dt">int</span> main(){</span>
<span id="cb46-7"><a href="#cb46-7"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;k); dfs(n,k); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb46-8"><a href="#cb46-8"></a>}</span></code></pre></div>
<h3 id="bzoj1232usaco2008nov安慰奶牛cheer2016.9.18">bzoj1232[Usaco2008Nov]安慰奶牛cheer*（2016.9.18）</h3>
<h4 id="题意-46">题意</h4>
<p>给出n个节点的带权图，第i个节点ci。现在你要在这个图中选出一棵树和一个起点，然后你要从起点出发到达所有的节点（不能跳点）再回到起点，经过边的时间为边权，每经过一个点就要花等同于点权的时间（即使这个点已经过）。问如何使时间最短。n≤10000。</p>
<h4 id="题解-46">题解</h4>
<p>每条边的边权为这条边原来的边权加两个端点的点权（因为每个点都要经过两次），然后做最小生成树。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb47-4"><a href="#cb47-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb47-5"><a href="#cb47-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb47-6"><a href="#cb47-6"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb47-7"><a href="#cb47-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb47-8"><a href="#cb47-8"></a></span>
<span id="cb47-9"><a href="#cb47-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb47-10"><a href="#cb47-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb47-11"><a href="#cb47-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb47-12"><a href="#cb47-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb47-13"><a href="#cb47-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb47-14"><a href="#cb47-14"></a>}</span>
<span id="cb47-15"><a href="#cb47-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,w;}es[maxn*<span class="dv">10</span>]; <span class="dt">bool</span> cmp(e a,e b){<span class="cf">return</span> a.w&lt;b.w;} <span class="dt">int</span> c[maxn],n,m,mn,ans,tot,fa[maxn];</span>
<span id="cb47-16"><a href="#cb47-16"></a><span class="dt">int</span> find(<span class="dt">int</span> x){</span>
<span id="cb47-17"><a href="#cb47-17"></a>    <span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);</span>
<span id="cb47-18"><a href="#cb47-18"></a>}</span>
<span id="cb47-19"><a href="#cb47-19"></a><span class="dt">int</span> main(){</span>
<span id="cb47-20"><a href="#cb47-20"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)c[i]=read(); mn=<span class="bn">0x3fffffff</span>; inc(i,<span class="dv">1</span>,n)mn=min(mn,c[i]);</span>
<span id="cb47-21"><a href="#cb47-21"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> a=read(),b=read(),d=read(); es[i]=(e){a,b,d*<span class="dv">2</span>+c[a]+c[b]};}</span>
<span id="cb47-22"><a href="#cb47-22"></a>    inc(i,<span class="dv">1</span>,n)fa[i]=i; sort(es+<span class="dv">1</span>,es+<span class="dv">1</span>+m,cmp);</span>
<span id="cb47-23"><a href="#cb47-23"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb47-24"><a href="#cb47-24"></a>        <span class="dt">int</span> x=find(es[i].f),y=find(es[i].t); <span class="cf">if</span>(x!=y)fa[x]=y,tot++,ans+=es[i].w; <span class="cf">if</span>(tot==n-<span class="dv">1</span>)<span class="cf">break</span>;</span>
<span id="cb47-25"><a href="#cb47-25"></a>    }</span>
<span id="cb47-26"><a href="#cb47-26"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans+mn); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb47-27"><a href="#cb47-27"></a>}</span></code></pre></div>
<h3 id="bzoj1572usaco2009-open工作安排job2016.9.18">bzoj1572[Usaco2009 Open]工作安排Job*（2016.9.18）</h3>
<h4 id="题意-47">题意</h4>
<p>n个工作，每个需要的时间都为1，最晚完成时间为ti，价值为vi，问最多能得到的价值。n≤100000。</p>
<h4 id="题解-47">题解</h4>
<p>先把所有工作按最晚开始时间排序，然后把能做的工作先做掉（如果前面的工作时间有空隙可以填上），处理剩下的工作时，比较之前做的工作中价值最小的工作的价值和当前工作的价值，如果之前做的工作价值更小就把它踢掉，换成当前工作。这一过程用优先队列维护。</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb48-8"><a href="#cb48-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb48-9"><a href="#cb48-9"></a></span>
<span id="cb48-10"><a href="#cb48-10"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb48-11"><a href="#cb48-11"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb48-12"><a href="#cb48-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb48-13"><a href="#cb48-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb48-14"><a href="#cb48-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb48-15"><a href="#cb48-15"></a>}</span>
<span id="cb48-16"><a href="#cb48-16"></a><span class="kw">struct</span> nd{ll t,v; <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd &amp;a)<span class="at">const</span>{<span class="cf">return</span> v&gt;a.v;}}nds[maxn]; priority_queue&lt;nd&gt;q;</span>
<span id="cb48-17"><a href="#cb48-17"></a><span class="dt">bool</span> cmp(nd a,nd b){<span class="cf">return</span> a.t&lt;b.t;} <span class="dt">int</span> n; ll ans,tot;</span>
<span id="cb48-18"><a href="#cb48-18"></a><span class="dt">int</span> main(){</span>
<span id="cb48-19"><a href="#cb48-19"></a>    n=read(); inc(i,<span class="dv">1</span>,n){ll x=read(); ll y=read(); nds[i]=(nd){x-<span class="dv">1</span>,y};} sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+n,cmp);</span>
<span id="cb48-20"><a href="#cb48-20"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb48-21"><a href="#cb48-21"></a>        <span class="cf">if</span>(tot&lt;=nds[i].t)q.push(nds[i]),ans+=nds[i].v,tot++;<span class="cf">else</span>{</span>
<span id="cb48-22"><a href="#cb48-22"></a>            ll a=q.top().v; <span class="cf">if</span>(a&lt;nds[i].v)q.pop(),q.push(nds[i]),ans-=a,ans+=nds[i].v;</span>
<span id="cb48-23"><a href="#cb48-23"></a>        }</span>
<span id="cb48-24"><a href="#cb48-24"></a>    }</span>
<span id="cb48-25"><a href="#cb48-25"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb48-26"><a href="#cb48-26"></a>}</span></code></pre></div>
<h3 id="bzoj1622usaco2008-openword-power-名字的能量2016.9.18">bzoj1622[Usaco2008 Open]Word Power 名字的能量*（2016.9.18）</h3>
<h4 id="题意-48">题意</h4>
<p>n个名字，m个能量字符串，每个名字的能量为其中含有能量字符串的种数（含有指有一个不连续子串与能量字符串相等），问每个名字的能量。n≤1000，m≤100。</p>
<h4 id="题解-48">题解</h4>
<p>暴力可过（似乎数据弱）。</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="pp">#include </span><span class="im">&lt;cctype&gt;</span></span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb49-7"><a href="#cb49-7"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb49-8"><a href="#cb49-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb49-9"><a href="#cb49-9"></a></span>
<span id="cb49-10"><a href="#cb49-10"></a><span class="dt">char</span> name[maxn][maxn],ener[maxn/<span class="dv">10</span>][maxn/<span class="dv">10</span>]; <span class="dt">int</span> n,m;</span>
<span id="cb49-11"><a href="#cb49-11"></a><span class="dt">int</span> main(){</span>
<span id="cb49-12"><a href="#cb49-12"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;n,&amp;m); inc(i,<span class="dv">1</span>,n)scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,name[i]+<span class="dv">1</span>); inc(i,<span class="dv">1</span>,m)scanf(<span class="st">&quot;</span><span class="sc">%s</span><span class="st">&quot;</span>,ener[i]+<span class="dv">1</span>);</span>
<span id="cb49-13"><a href="#cb49-13"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb49-14"><a href="#cb49-14"></a>        <span class="dt">int</span> len1=strlen(name[i]+<span class="dv">1</span>),ans=<span class="dv">0</span>;</span>
<span id="cb49-15"><a href="#cb49-15"></a>        inc(j,<span class="dv">1</span>,m){</span>
<span id="cb49-16"><a href="#cb49-16"></a>            <span class="dt">int</span> l=<span class="dv">0</span>,len2=strlen(ener[j]+<span class="dv">1</span>);</span>
<span id="cb49-17"><a href="#cb49-17"></a>            inc(k,<span class="dv">1</span>,len1){</span>
<span id="cb49-18"><a href="#cb49-18"></a>                <span class="cf">if</span>(tolower(name[i][k])==tolower(ener[j][l+<span class="dv">1</span>])){</span>
<span id="cb49-19"><a href="#cb49-19"></a>                    l++; <span class="cf">if</span>(l==len2){ans++; <span class="cf">break</span>;}</span>
<span id="cb49-20"><a href="#cb49-20"></a>                }</span>
<span id="cb49-21"><a href="#cb49-21"></a>            }</span>
<span id="cb49-22"><a href="#cb49-22"></a>        }</span>
<span id="cb49-23"><a href="#cb49-23"></a>        printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans);</span>
<span id="cb49-24"><a href="#cb49-24"></a>    }</span>
<span id="cb49-25"><a href="#cb49-25"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb49-26"><a href="#cb49-26"></a>}</span></code></pre></div>
<h3 id="bzoj1618usaco2008-novbuying-hay-购买干草2016.9.18">bzoj1618[Usaco2008 Nov]Buying Hay 购买干草*（2016.9.18）</h3>
<h4 id="题意-49">题意</h4>
<p>n种物品，每种无限个，重量为pi，费用为ci，要求总重量超过h的前提费用最小。求最小费用。n≤100，m≤50000。</p>
<h4 id="题解-49">题解</h4>
<p>dp。f[i][j]=min(f[i-1][j],f[i][j-p[i]]+c[i])，边界f[0][0]=0，f[0][1..m+mx]=INF。最后在f[n][m..m+mx]中找一个最小的。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb50-4"><a href="#cb50-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb50-5"><a href="#cb50-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb50-6"><a href="#cb50-6"></a><span class="pp">#define maxn </span><span class="dv">60010</span></span>
<span id="cb50-7"><a href="#cb50-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb50-8"><a href="#cb50-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb50-9"><a href="#cb50-9"></a></span>
<span id="cb50-10"><a href="#cb50-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb50-11"><a href="#cb50-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb50-12"><a href="#cb50-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb50-13"><a href="#cb50-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb50-14"><a href="#cb50-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb50-15"><a href="#cb50-15"></a>}</span>
<span id="cb50-16"><a href="#cb50-16"></a><span class="dt">int</span> f[<span class="dv">2</span>][maxn],mx,n,m,p[maxn],c[maxn],x,y;</span>
<span id="cb50-17"><a href="#cb50-17"></a><span class="dt">int</span> main(){</span>
<span id="cb50-18"><a href="#cb50-18"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)p[i]=read(),c[i]=read(),mx=max(mx,p[i]);</span>
<span id="cb50-19"><a href="#cb50-19"></a>    x=<span class="dv">0</span>; y=<span class="dv">1</span>; inc(i,<span class="dv">0</span>,m+mx)f[x][i]=INF; f[x][<span class="dv">0</span>]=<span class="dv">0</span>;</span>
<span id="cb50-20"><a href="#cb50-20"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb50-21"><a href="#cb50-21"></a>        inc(j,<span class="dv">0</span>,m+mx)f[y][j]=f[x][j];</span>
<span id="cb50-22"><a href="#cb50-22"></a>        inc(j,p[i],m+mx)f[y][j]=min(f[y][j],f[y][j-p[i]]+c[i]);</span>
<span id="cb50-23"><a href="#cb50-23"></a>        swap(x,y);</span>
<span id="cb50-24"><a href="#cb50-24"></a>    }</span>
<span id="cb50-25"><a href="#cb50-25"></a>    y=INF; inc(i,m,m+mx)y=min(y,f[x][i]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,y); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb50-26"><a href="#cb50-26"></a>}</span></code></pre></div>
<h3 id="bzoj2023usaco2005-novant-counting-数蚂蚁bzoj1630usaco2007-demoant-counting2016.9.19">bzoj2023[Usaco2005 Nov]Ant Counting 数蚂蚁*&amp;bzoj1630[Usaco2007 Demo]Ant Counting*（2016.9.19）</h3>
<h4 id="题意-50">题意</h4>
<p>t个族群，每个族群有ni只蚂蚁，同族群蚂蚁没有区别。问从所有蚂蚁中选出s到b只蚂蚁有多少方案。t≤1000，ni≤100。</p>
<h4 id="题解-50">题解</h4>
<p>dp，f[i][j]表示考虑第i个族群，剩下j只蚂蚁没选择。则f[i][j]=sum(f[i-1][j-k]),k=0..min(j,n[i])。然而O(n^3)会超时，注意到可以计算f[i-1][j]的前缀和sum[j]，然后就能比较方便的得到f[i-1][j-k],k=0..min(j,n[i])=j&lt;=n[i]?sum[j]:sum[j]-sum[j-k]，使复杂度变为O(n^2)。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb51-4"><a href="#cb51-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb51-5"><a href="#cb51-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb51-6"><a href="#cb51-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb51-7"><a href="#cb51-7"></a><span class="pp">#define mod </span><span class="dv">1000000</span></span>
<span id="cb51-8"><a href="#cb51-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb51-9"><a href="#cb51-9"></a></span>
<span id="cb51-10"><a href="#cb51-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb51-11"><a href="#cb51-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb51-12"><a href="#cb51-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb51-13"><a href="#cb51-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb51-14"><a href="#cb51-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb51-15"><a href="#cb51-15"></a>}</span>
<span id="cb51-16"><a href="#cb51-16"></a><span class="dt">int</span> f[maxn],cnt[maxn],t,a,s,b,ans,sum[maxn];</span>
<span id="cb51-17"><a href="#cb51-17"></a><span class="dt">int</span> main(){</span>
<span id="cb51-18"><a href="#cb51-18"></a>    t=read(); a=read(); s=read(); b=read(); inc(i,<span class="dv">1</span>,a){<span class="dt">int</span> x=read(); cnt[x]++;} inc(i,<span class="dv">0</span>,a)sum[i]=<span class="dv">1</span>;</span>
<span id="cb51-19"><a href="#cb51-19"></a>    inc(i,<span class="dv">1</span>,t){</span>
<span id="cb51-20"><a href="#cb51-20"></a>        inc(j,<span class="dv">0</span>,a){<span class="cf">if</span>(j&lt;=cnt[i])f[j]=sum[j];<span class="cf">else</span> f[j]=(mod+sum[j]-sum[j-cnt[i]-<span class="dv">1</span>])%mod;}</span>
<span id="cb51-21"><a href="#cb51-21"></a>        sum[<span class="dv">0</span>]=f[<span class="dv">0</span>]; inc(j,<span class="dv">1</span>,a)sum[j]=(sum[j-<span class="dv">1</span>]+f[j])%mod;</span>
<span id="cb51-22"><a href="#cb51-22"></a>    }</span>
<span id="cb51-23"><a href="#cb51-23"></a>    ans=<span class="dv">0</span>; inc(i,s,b)ans=(ans+f[i])%mod; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb51-24"><a href="#cb51-24"></a>}</span></code></pre></div>
<h3 id="bzoj1651usaco2006-febstall-reservations-专用牛棚2016.9.19">bzoj1651[Usaco2006 Feb]Stall Reservations 专用牛棚*（2016.9.19）</h3>
<h4 id="题意-51">题意</h4>
<p>有N头牛，每头牛有个喝水时间段，这段时间它将专用一个棚。现在给出每头牛的喝水时间段，问至少要多少个棚才能满足它们的要求。n≤50000，时刻≤1000000。</p>
<h4 id="题解-51">题解</h4>
<p>时间段左端点对应的sum元素++，右端点+1对应的sum元素–，最后从左到右加一遍就可以得到每个时刻的喝水牛数，找个最大值就可以了。</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb52-3"><a href="#cb52-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb52-4"><a href="#cb52-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb52-5"><a href="#cb52-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb52-6"><a href="#cb52-6"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb52-7"><a href="#cb52-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb52-8"><a href="#cb52-8"></a></span>
<span id="cb52-9"><a href="#cb52-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb52-10"><a href="#cb52-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb52-11"><a href="#cb52-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb52-12"><a href="#cb52-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb52-13"><a href="#cb52-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb52-14"><a href="#cb52-14"></a>}</span>
<span id="cb52-15"><a href="#cb52-15"></a><span class="dt">int</span> sm[maxn],n,mx,ans;</span>
<span id="cb52-16"><a href="#cb52-16"></a><span class="dt">int</span> main(){</span>
<span id="cb52-17"><a href="#cb52-17"></a>    n=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(),y=read(); sm[x]++; sm[y+<span class="dv">1</span>]--; mx=max(mx,y);}</span>
<span id="cb52-18"><a href="#cb52-18"></a>    inc(i,<span class="dv">1</span>,mx)sm[i]+=sm[i-<span class="dv">1</span>]; inc(i,<span class="dv">1</span>,mx)ans=max(ans,sm[i]); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb52-19"><a href="#cb52-19"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb52-20"><a href="#cb52-20"></a>}</span></code></pre></div>
<h3 id="bzoj1627usaco2007-dec穿越泥地2016.9.19">bzoj1627[Usaco2007 Dec]穿越泥地*（2016.9.19）</h3>
<h4 id="题意-52">题意</h4>
<p>网格中有一些障碍物，求从起点到终点最小步数。-500≤坐标≤500</p>
<h4 id="题解-52">题解</h4>
<p>bfs。所有坐标均加上500，就可以只考虑第一象限了。</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb53-3"><a href="#cb53-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb53-5"><a href="#cb53-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb53-6"><a href="#cb53-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb53-7"><a href="#cb53-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb53-8"><a href="#cb53-8"></a></span>
<span id="cb53-9"><a href="#cb53-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb53-10"><a href="#cb53-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb53-11"><a href="#cb53-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb53-12"><a href="#cb53-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb53-13"><a href="#cb53-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb53-14"><a href="#cb53-14"></a>}</span>
<span id="cb53-15"><a href="#cb53-15"></a><span class="dt">int</span> dis[maxn][maxn],x,y,n; <span class="dt">bool</span> bad[maxn][maxn]; queue&lt;pair&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt; &gt;q;</span>
<span id="cb53-16"><a href="#cb53-16"></a><span class="dt">int</span> main(){</span>
<span id="cb53-17"><a href="#cb53-17"></a>    x=read()+<span class="dv">500</span>; y=read()+<span class="dv">500</span>; n=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read()+<span class="dv">500</span>,y=read()+<span class="dv">500</span>; bad[x][y]=<span class="dv">1</span>;}</span>
<span id="cb53-18"><a href="#cb53-18"></a>    q.push(make_pair(<span class="dv">500</span>,<span class="dv">500</span>)); memset(dis,-<span class="dv">1</span>,<span class="kw">sizeof</span>(dis)); dis[<span class="dv">500</span>][<span class="dv">500</span>]=<span class="dv">0</span>;</span>
<span id="cb53-19"><a href="#cb53-19"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb53-20"><a href="#cb53-20"></a>        <span class="dt">int</span> xx=q.front().first,yy=q.front().second; q.pop();</span>
<span id="cb53-21"><a href="#cb53-21"></a>        <span class="cf">if</span>(xx&gt;-<span class="dv">1000</span>&amp;&amp;!bad[xx-<span class="dv">1</span>][yy]&amp;&amp;dis[xx-<span class="dv">1</span>][yy]==-<span class="dv">1</span>){</span>
<span id="cb53-22"><a href="#cb53-22"></a>            q.push(make_pair(xx-<span class="dv">1</span>,yy)); dis[xx-<span class="dv">1</span>][yy]=dis[xx][yy]+<span class="dv">1</span>;</span>
<span id="cb53-23"><a href="#cb53-23"></a>            <span class="cf">if</span>(xx-<span class="dv">1</span>==x&amp;&amp;yy==y){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dis[xx-<span class="dv">1</span>][yy]); <span class="cf">break</span>;}</span>
<span id="cb53-24"><a href="#cb53-24"></a>        }</span>
<span id="cb53-25"><a href="#cb53-25"></a>        <span class="cf">if</span>(xx&lt;<span class="dv">1000</span>&amp;&amp;!bad[xx+<span class="dv">1</span>][yy]&amp;&amp;dis[xx+<span class="dv">1</span>][yy]==-<span class="dv">1</span>){</span>
<span id="cb53-26"><a href="#cb53-26"></a>            q.push(make_pair(xx+<span class="dv">1</span>,yy)); dis[xx+<span class="dv">1</span>][yy]=dis[xx][yy]+<span class="dv">1</span>;</span>
<span id="cb53-27"><a href="#cb53-27"></a>            <span class="cf">if</span>(xx+<span class="dv">1</span>==x&amp;&amp;yy==y){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dis[xx+<span class="dv">1</span>][yy]); <span class="cf">break</span>;}</span>
<span id="cb53-28"><a href="#cb53-28"></a>        }</span>
<span id="cb53-29"><a href="#cb53-29"></a>        <span class="cf">if</span>(yy&gt;-<span class="dv">1000</span>&amp;&amp;!bad[xx][yy-<span class="dv">1</span>]&amp;&amp;dis[xx][yy-<span class="dv">1</span>]==-<span class="dv">1</span>){</span>
<span id="cb53-30"><a href="#cb53-30"></a>            q.push(make_pair(xx,yy-<span class="dv">1</span>)); dis[xx][yy-<span class="dv">1</span>]=dis[xx][yy]+<span class="dv">1</span>;</span>
<span id="cb53-31"><a href="#cb53-31"></a>            <span class="cf">if</span>(xx==x&amp;&amp;yy-<span class="dv">1</span>==y){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dis[xx][yy-<span class="dv">1</span>]); <span class="cf">break</span>;}</span>
<span id="cb53-32"><a href="#cb53-32"></a>        }</span>
<span id="cb53-33"><a href="#cb53-33"></a>        <span class="cf">if</span>(yy&lt;<span class="dv">1000</span>&amp;&amp;!bad[xx][yy+<span class="dv">1</span>]&amp;&amp;dis[xx][yy+<span class="dv">1</span>]==-<span class="dv">1</span>){</span>
<span id="cb53-34"><a href="#cb53-34"></a>            q.push(make_pair(xx,yy+<span class="dv">1</span>)); dis[xx][yy+<span class="dv">1</span>]=dis[xx][yy]+<span class="dv">1</span>;</span>
<span id="cb53-35"><a href="#cb53-35"></a>            <span class="cf">if</span>(xx==x&amp;&amp;yy+<span class="dv">1</span>==y){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,dis[xx][yy+<span class="dv">1</span>]); <span class="cf">break</span>;}</span>
<span id="cb53-36"><a href="#cb53-36"></a>        }</span>
<span id="cb53-37"><a href="#cb53-37"></a>    }</span>
<span id="cb53-38"><a href="#cb53-38"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb53-39"><a href="#cb53-39"></a>}</span></code></pre></div>
<h3 id="bzoj1113poi2008海报pla2016.9.19">bzoj1113[Poi2008]海报PLA*（2016.9.19）</h3>
<h4 id="题意-53">题意</h4>
<p>N个矩形，排成一排。现在希望用尽量少的矩形海报盖住它们。不能盖到矩形之外的地方。n≤250000。</p>
<h4 id="题解-53">题解</h4>
<p>发现如果有一对矩形高度相等，且中间的矩形高度都比它们高，那么就可以省下一个矩形海报。故可以用个单调递增的栈维护。</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb54-5"><a href="#cb54-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb54-6"><a href="#cb54-6"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb54-7"><a href="#cb54-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb54-8"><a href="#cb54-8"></a></span>
<span id="cb54-9"><a href="#cb54-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb54-10"><a href="#cb54-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb54-11"><a href="#cb54-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb54-12"><a href="#cb54-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb54-13"><a href="#cb54-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb54-14"><a href="#cb54-14"></a>}</span>
<span id="cb54-15"><a href="#cb54-15"></a>stack&lt;<span class="dt">int</span>&gt;st; <span class="dt">int</span> n,ans;</span>
<span id="cb54-16"><a href="#cb54-16"></a><span class="dt">int</span> main(){</span>
<span id="cb54-17"><a href="#cb54-17"></a>    n=read();</span>
<span id="cb54-18"><a href="#cb54-18"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb54-19"><a href="#cb54-19"></a>        <span class="dt">int</span> x=read(),y=read(); <span class="cf">while</span>(!st.empty()&amp;&amp;y&lt;=st.top()){<span class="cf">if</span>(y==st.top())ans++; st.pop();} st.push(y);</span>
<span id="cb54-20"><a href="#cb54-20"></a>    }</span>
<span id="cb54-21"><a href="#cb54-21"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,n-ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb54-22"><a href="#cb54-22"></a>}</span></code></pre></div>
<h3 id="bzoj1529poi2005ska-piggy-banks2016.9.19">bzoj1529[POI2005]ska Piggy banks*（2016.9.19）</h3>
<h4 id="题意-54">题意</h4>
<p>n个存钱罐，每个罐子的钥匙都在另外某个存钱罐里，问最少打破几个存钱罐，才能得到所有存钱罐里的钱。n≤1000000。</p>
<h4 id="题解-54">题解</h4>
<p>因为每个存钱罐只有一把钥匙，所以整幅图都是由一些互不连接的连着一个环的链组成，而打破存钱罐的个数正是这些连着一个环的链的个数，即图中联通块的个数，故用并查集维护。</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb55-3"><a href="#cb55-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb55-4"><a href="#cb55-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb55-5"><a href="#cb55-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb55-6"><a href="#cb55-6"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb55-7"><a href="#cb55-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb55-8"><a href="#cb55-8"></a></span>
<span id="cb55-9"><a href="#cb55-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb55-10"><a href="#cb55-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb55-11"><a href="#cb55-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb55-12"><a href="#cb55-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb55-13"><a href="#cb55-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb55-14"><a href="#cb55-14"></a>}</span>
<span id="cb55-15"><a href="#cb55-15"></a><span class="dt">int</span> fa[maxn],n,ans;</span>
<span id="cb55-16"><a href="#cb55-16"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb55-17"><a href="#cb55-17"></a><span class="dt">int</span> main(){</span>
<span id="cb55-18"><a href="#cb55-18"></a>    n=read(); inc(i,<span class="dv">1</span>,n)fa[i]=i; inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(),y=find(x),z=find(i); <span class="cf">if</span>(y!=z)fa[z]=y;}</span>
<span id="cb55-19"><a href="#cb55-19"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(i==fa[i])ans++; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb55-20"><a href="#cb55-20"></a>}</span></code></pre></div>
<h3 id="bzoj1131poi2008sta2016.9.19">bzoj1131[POI2008]Sta*（2016.9.19）</h3>
<h4 id="题意-55">题意</h4>
<p>给出一个n个点的树,找出一个点来,以这个点为根的树时,所有点的深度之和最大。n≤1000000。</p>
<h4 id="题解-55">题解</h4>
<p>两次dfs。第一次dfs维护子树的大小、节点的深度、以子树的根为根的子树深度和。第二次dfs维护以某节点为根除了以1为根时它的子树之外的所有节点的深度和。最后比较所有节点两个深度和相加的值。具体看代码。</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb56-3"><a href="#cb56-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb56-4"><a href="#cb56-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb56-5"><a href="#cb56-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb56-6"><a href="#cb56-6"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb56-7"><a href="#cb56-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb56-8"><a href="#cb56-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb56-9"><a href="#cb56-9"></a></span>
<span id="cb56-10"><a href="#cb56-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb56-11"><a href="#cb56-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb56-12"><a href="#cb56-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb56-13"><a href="#cb56-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb56-14"><a href="#cb56-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb56-15"><a href="#cb56-15"></a>}</span>
<span id="cb56-16"><a href="#cb56-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb56-17"><a href="#cb56-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess;}</span>
<span id="cb56-18"><a href="#cb56-18"></a>ll ds[maxn],sz[maxn],fads[maxn],dep[maxn]; <span class="dt">int</span> n,ans,fa[maxn];</span>
<span id="cb56-19"><a href="#cb56-19"></a><span class="dt">void</span> dfs1(<span class="dt">int</span> x){</span>
<span id="cb56-20"><a href="#cb56-20"></a>    sz[x]=<span class="dv">1</span>; ds[x]=<span class="dv">0</span>;</span>
<span id="cb56-21"><a href="#cb56-21"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]){</span>
<span id="cb56-22"><a href="#cb56-22"></a>        fa[es[i].t]=x; dep[es[i].t]=dep[x]+<span class="dv">1</span>; dfs1(es[i].t);</span>
<span id="cb56-23"><a href="#cb56-23"></a>        sz[x]+=sz[es[i].t]; ds[x]+=ds[es[i].t]+sz[es[i].t];</span>
<span id="cb56-24"><a href="#cb56-24"></a>    }</span>
<span id="cb56-25"><a href="#cb56-25"></a>}</span>
<span id="cb56-26"><a href="#cb56-26"></a><span class="dt">void</span> dfs2(<span class="dt">int</span> x,ll a){</span>
<span id="cb56-27"><a href="#cb56-27"></a>    fads[x]=a+n-sz[x]; ll sm=fads[x];</span>
<span id="cb56-28"><a href="#cb56-28"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x])sm+=ds[es[i].t]+sz[es[i].t];</span>
<span id="cb56-29"><a href="#cb56-29"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x])dfs2(es[i].t,sm-(ds[es[i].t]+sz[es[i].t]));</span>
<span id="cb56-30"><a href="#cb56-30"></a>}</span>
<span id="cb56-31"><a href="#cb56-31"></a><span class="dt">int</span> main(){</span>
<span id="cb56-32"><a href="#cb56-32"></a>    n=read(); inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> x=read(),y=read(); pe(x,y); pe(y,x);} dfs1(<span class="dv">1</span>); dfs2(<span class="dv">1</span>,<span class="dv">0</span>);</span>
<span id="cb56-33"><a href="#cb56-33"></a>    ans=<span class="dv">0</span>; inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(fads[i]+ds[i]&gt;fads[ans]+ds[ans])ans=i; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb56-34"><a href="#cb56-34"></a>}</span></code></pre></div>
<h3 id="bzoj3709pa2014bohater2016.9.20">bzoj3709[PA2014]Bohater*（2016.9.20）</h3>
<h4 id="题意-56">题意</h4>
<p>n只怪物，打死第i只要耗ai血，打死后补bi血。如果你血≤0就会死。你现在有z血，问怎样的顺序可以打死所有怪。n≤100000。</p>
<h4 id="题解-56">题解</h4>
<p>先打bi大于ai的怪攒血，此时按ai升序排序。因为先杀耗血少的再杀耗血多的，则为下一步提供了更高的可能性。因为血量是单增的，所以尽量用较少的血量去杀耗血较少的怪物。再打ai大于bi的怪，此时按bi降序排序，因为先杀补血多的再杀耗血少的，则为下一步提供了更高的可能性。当前这一步的可能性也没有减少，即使补血多的耗血很多，但是由于此时血量已经是单减的了，所以若此时无法杀掉耗血多的，将来也不能。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb57-2"><a href="#cb57-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb57-3"><a href="#cb57-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb57-4"><a href="#cb57-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb57-5"><a href="#cb57-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb57-6"><a href="#cb57-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb57-7"><a href="#cb57-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb57-8"><a href="#cb57-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb57-9"><a href="#cb57-9"></a></span>
<span id="cb57-10"><a href="#cb57-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb57-11"><a href="#cb57-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb57-12"><a href="#cb57-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb57-13"><a href="#cb57-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb57-14"><a href="#cb57-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb57-15"><a href="#cb57-15"></a>}</span>
<span id="cb57-16"><a href="#cb57-16"></a><span class="dt">int</span> n,sz1,sz2; ll z;</span>
<span id="cb57-17"><a href="#cb57-17"></a><span class="kw">struct</span> nd{<span class="dt">int</span> a,b,id;}nds1[maxn],nds2[maxn];</span>
<span id="cb57-18"><a href="#cb57-18"></a><span class="dt">bool</span> cmp1(nd a,nd b){<span class="cf">return</span> a.a&lt;b.a;} <span class="dt">bool</span> cmp2(nd a,nd b){<span class="cf">return</span> a.b&gt;b.b;}</span>
<span id="cb57-19"><a href="#cb57-19"></a><span class="dt">int</span> main(){</span>
<span id="cb57-20"><a href="#cb57-20"></a>    n=read(); z=read();</span>
<span id="cb57-21"><a href="#cb57-21"></a>    inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(),y=read(); <span class="cf">if</span>(y&gt;=x)nds1[++sz1]=(nd){x,y,i};<span class="cf">else</span> nds2[++sz2]=(nd){x,y,i};}</span>
<span id="cb57-22"><a href="#cb57-22"></a>    sort(nds1+<span class="dv">1</span>,nds1+sz1+<span class="dv">1</span>,cmp1); sort(nds2+<span class="dv">1</span>,nds2+sz2+<span class="dv">1</span>,cmp2);</span>
<span id="cb57-23"><a href="#cb57-23"></a>    inc(i,<span class="dv">1</span>,sz1){</span>
<span id="cb57-24"><a href="#cb57-24"></a>        <span class="cf">if</span>(z&lt;=nds1[i].a){printf(<span class="st">&quot;NIE&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;} z-=nds1[i].a; z+=nds1[i].b;</span>
<span id="cb57-25"><a href="#cb57-25"></a>    }</span>
<span id="cb57-26"><a href="#cb57-26"></a>    inc(i,<span class="dv">1</span>,sz2){</span>
<span id="cb57-27"><a href="#cb57-27"></a>        <span class="cf">if</span>(z&lt;=nds2[i].a){printf(<span class="st">&quot;NIE&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;} z-=nds2[i].a; z+=nds2[i].b;</span>
<span id="cb57-28"><a href="#cb57-28"></a>    }</span>
<span id="cb57-29"><a href="#cb57-29"></a>    puts(<span class="st">&quot;TAK&quot;</span>); inc(i,<span class="dv">1</span>,sz1)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>,nds1[i].id); inc(i,<span class="dv">1</span>,sz2)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span>,nds2[i].id); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb57-30"><a href="#cb57-30"></a>}</span></code></pre></div>
<h3 id="bzoj1108poi2007天然气管道gaz2016.9.20">bzoj1108[POI2007]天然气管道Gaz*（2016.9.20）</h3>
<h4 id="题意-57">题意</h4>
<p>n个钻井，n个站，要求两两配对，但站必须在钻井的右下方。配一对的费用为两点的曼哈顿距离，求最小总费用。n≤50000。</p>
<h4 id="题解-57">题解</h4>
<p>发现满足条件站必须在钻井的右下方的所有配对方案的总费用是相同的，所以直接用站横坐标的和减钻井横坐标的和加上钻井纵坐标的和减站纵坐标的和即可。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb58-2"><a href="#cb58-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb58-4"><a href="#cb58-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb58-7"><a href="#cb58-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb58-8"><a href="#cb58-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb58-9"><a href="#cb58-9"></a></span>
<span id="cb58-10"><a href="#cb58-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb58-11"><a href="#cb58-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb58-12"><a href="#cb58-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb58-13"><a href="#cb58-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb58-14"><a href="#cb58-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb58-15"><a href="#cb58-15"></a>}</span>
<span id="cb58-16"><a href="#cb58-16"></a><span class="dt">int</span> n; ll ans;</span>
<span id="cb58-17"><a href="#cb58-17"></a><span class="dt">int</span> main(){</span>
<span id="cb58-18"><a href="#cb58-18"></a>    n=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a=read(),b=read(); ans-=a; ans+=b;}</span>
<span id="cb58-19"><a href="#cb58-19"></a>    inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a=read(),b=read(); ans+=a; ans-=b;} printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb58-20"><a href="#cb58-20"></a>}</span></code></pre></div>
<h3 id="bzoj1682usaco2005-marout-of-hay-干草危机2016.9.20">bzoj1682[Usaco2005 Mar]Out of Hay 干草危机*（2016.9.20）</h3>
<h4 id="题意-58">题意</h4>
<p>给个图，每个节点都和1联通，奶牛要从1到每个节点（可以走回头路），希望经过的最长边最短。</p>
<h4 id="题解-58">题解</h4>
<p>求最小生成树即可。</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb59-3"><a href="#cb59-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb59-4"><a href="#cb59-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb59-5"><a href="#cb59-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb59-6"><a href="#cb59-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb59-7"><a href="#cb59-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb59-8"><a href="#cb59-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb59-9"><a href="#cb59-9"></a></span>
<span id="cb59-10"><a href="#cb59-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb59-11"><a href="#cb59-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb59-12"><a href="#cb59-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb59-13"><a href="#cb59-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb59-14"><a href="#cb59-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb59-15"><a href="#cb59-15"></a>}</span>
<span id="cb59-16"><a href="#cb59-16"></a><span class="dt">int</span> n,m,ans,fa[maxn],tot; <span class="kw">struct</span> e{<span class="dt">int</span> f,t,w;}es[maxn]; <span class="dt">bool</span> cmp(e a,e b){<span class="cf">return</span> a.w&lt;b.w;}</span>
<span id="cb59-17"><a href="#cb59-17"></a><span class="dt">int</span> find(<span class="dt">int</span> x){<span class="cf">return</span> x==fa[x]?x:fa[x]=find(fa[x]);}</span>
<span id="cb59-18"><a href="#cb59-18"></a><span class="dt">int</span> main(){</span>
<span id="cb59-19"><a href="#cb59-19"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(),z=read(); es[i]=(e){x,y,z};} sort(es+<span class="dv">1</span>,es+<span class="dv">1</span>+m,cmp);</span>
<span id="cb59-20"><a href="#cb59-20"></a>    inc(i,<span class="dv">1</span>,n)fa[i]=i;</span>
<span id="cb59-21"><a href="#cb59-21"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb59-22"><a href="#cb59-22"></a>        <span class="dt">int</span> x=find(es[i].f),y=find(es[i].t);</span>
<span id="cb59-23"><a href="#cb59-23"></a>        <span class="cf">if</span>(x!=y){fa[x]=y; tot++; ans=max(ans,es[i].w); <span class="cf">if</span>(tot==n-<span class="dv">1</span>)<span class="cf">break</span>;}</span>
<span id="cb59-24"><a href="#cb59-24"></a>    }</span>
<span id="cb59-25"><a href="#cb59-25"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb59-26"><a href="#cb59-26"></a>}</span></code></pre></div>
<h3 id="bzoj1708usaco2007-octmoney奶牛的硬币2016.9.21">bzoj1708[Usaco2007 Oct]Money奶牛的硬币（2016.9.21）</h3>
<h4 id="题意-59">题意</h4>
<p>n种硬币面值，求凑m元多少种方案。n≤25，m≤10000。</p>
<h4 id="题解-59">题解</h4>
<p>完全背包。f[0][0]=1，f[i][j]=sum(f[i-1][j],f[i][j-a[k]])。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb60-2"><a href="#cb60-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb60-3"><a href="#cb60-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb60-4"><a href="#cb60-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb60-5"><a href="#cb60-5"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb60-6"><a href="#cb60-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb60-7"><a href="#cb60-7"></a></span>
<span id="cb60-8"><a href="#cb60-8"></a>ll f[<span class="dv">30</span>][<span class="dv">10010</span>]; <span class="dt">int</span> v,n;</span>
<span id="cb60-9"><a href="#cb60-9"></a><span class="dt">int</span> main(){</span>
<span id="cb60-10"><a href="#cb60-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d%d</span><span class="st">&quot;</span>,&amp;v,&amp;n); f[<span class="dv">0</span>][<span class="dv">0</span>]=<span class="dv">1</span>;</span>
<span id="cb60-11"><a href="#cb60-11"></a>    inc(i,<span class="dv">1</span>,v){<span class="dt">int</span> x; scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;x); inc(j,<span class="dv">0</span>,n){f[i][j]=f[i-<span class="dv">1</span>][j]; <span class="cf">if</span>(j&gt;=x)f[i][j]+=f[i][j-x];}}</span>
<span id="cb60-12"><a href="#cb60-12"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,f[v][n]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb60-13"><a href="#cb60-13"></a>}</span></code></pre></div>
<h3 id="bzoj1827usaco2010-margather-奶牛大集会2016.9.21">bzoj1827[Usaco2010 Mar]gather 奶牛大集会*（2016.9.21）</h3>
<h4 id="题意-60">题意</h4>
<p>n点树（有边权），找出一个点，使得其它所有点到它的距离和最小。n≤100000。</p>
<h4 id="题解-60">题解</h4>
<p>类似bzoj1131，但维护深度和改为维护距离和。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb61-3"><a href="#cb61-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb61-4"><a href="#cb61-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb61-5"><a href="#cb61-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb61-6"><a href="#cb61-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb61-7"><a href="#cb61-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb61-8"><a href="#cb61-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb61-9"><a href="#cb61-9"></a></span>
<span id="cb61-10"><a href="#cb61-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb61-11"><a href="#cb61-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb61-12"><a href="#cb61-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb61-13"><a href="#cb61-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb61-14"><a href="#cb61-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb61-15"><a href="#cb61-15"></a>}</span>
<span id="cb61-16"><a href="#cb61-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t; ll w; <span class="dt">int</span> n;}es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb61-17"><a href="#cb61-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,ll w){es[++ess]=(e){t,w,g[f]}; g[f]=ess;}</span>
<span id="cb61-18"><a href="#cb61-18"></a>ll ds[maxn],sz[maxn],fads[maxn],dep[maxn],c[maxn],sum; <span class="dt">int</span> n,ans,fa[maxn];</span>
<span id="cb61-19"><a href="#cb61-19"></a><span class="dt">void</span> dfs1(<span class="dt">int</span> x){</span>
<span id="cb61-20"><a href="#cb61-20"></a>    sz[x]=c[x]; ds[x]=<span class="dv">0</span>;</span>
<span id="cb61-21"><a href="#cb61-21"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x]){</span>
<span id="cb61-22"><a href="#cb61-22"></a>        fa[es[i].t]=x; dep[es[i].t]=dep[x]+es[i].w; dfs1(es[i].t);</span>
<span id="cb61-23"><a href="#cb61-23"></a>        sz[x]+=sz[es[i].t]; ds[x]+=ds[es[i].t]+sz[es[i].t]*es[i].w;</span>
<span id="cb61-24"><a href="#cb61-24"></a>    }</span>
<span id="cb61-25"><a href="#cb61-25"></a>}</span>
<span id="cb61-26"><a href="#cb61-26"></a><span class="dt">void</span> dfs2(<span class="dt">int</span> x,ll a,ll b){</span>
<span id="cb61-27"><a href="#cb61-27"></a>    fads[x]=a+b*(sum-sz[x]); ll sm=fads[x];</span>
<span id="cb61-28"><a href="#cb61-28"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x])sm+=ds[es[i].t]+es[i].w*sz[es[i].t];</span>
<span id="cb61-29"><a href="#cb61-29"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=fa[x])dfs2(es[i].t,sm-(ds[es[i].t]+es[i].w*sz[es[i].t]),es[i].w);</span>
<span id="cb61-30"><a href="#cb61-30"></a>}</span>
<span id="cb61-31"><a href="#cb61-31"></a><span class="dt">int</span> main(){</span>
<span id="cb61-32"><a href="#cb61-32"></a>    n=read(); inc(i,<span class="dv">1</span>,n)c[i]=read(),sum+=c[i];</span>
<span id="cb61-33"><a href="#cb61-33"></a>    inc(i,<span class="dv">1</span>,n-<span class="dv">1</span>){<span class="dt">int</span> x=read(),y=read(),z=read(); pe(x,y,z); pe(y,x,z);} dfs1(<span class="dv">1</span>); dfs2(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>);</span>
<span id="cb61-34"><a href="#cb61-34"></a>    ans=<span class="dv">1</span>; inc(i,<span class="dv">2</span>,n)<span class="cf">if</span>(fads[i]+ds[i]&lt;fads[ans]+ds[ans])ans=i; printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,fads[ans]+ds[ans]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb61-35"><a href="#cb61-35"></a>}</span></code></pre></div>
<h3 id="bzoj1592usaco2008-febmaking-the-grade-路面修整2016.9.21">bzoj1592[Usaco2008 Feb]Making the Grade 路面修整*（2016.9.21）</h3>
<h4 id="题意-61">题意</h4>
<p>某条路n段，每段高度hi，现在要将路修成不上升或不下降序列，问最小费用，把高度a修成b费用为|a-b|。n≤2000。</p>
<h4 id="题解-61">题解</h4>
<p>有个结论，每段路修成的高度必定是原序列中已经出现过的高度（因为修好的路是非严格单调）。所以直接离散化，然后dp（修成不下降）：f[i][j]=min(f[i-1][k]+abs(a[j]-a[k])),a[j]&gt;=a[k]。但是这样会T，而a数组因为之前的离散化是单调的，所以可以用前缀最小值数组维护一下f[i-1][1]到f[i-1][n]的最小值，然后就可以递推了。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb62-6"><a href="#cb62-6"></a><span class="pp">#define maxn </span><span class="dv">2010</span></span>
<span id="cb62-7"><a href="#cb62-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb62-8"><a href="#cb62-8"></a><span class="pp">#define INF </span><span class="dv">10000000000000000</span></span>
<span id="cb62-9"><a href="#cb62-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb62-10"><a href="#cb62-10"></a></span>
<span id="cb62-11"><a href="#cb62-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb62-12"><a href="#cb62-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb62-13"><a href="#cb62-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb62-14"><a href="#cb62-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb62-15"><a href="#cb62-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb62-16"><a href="#cb62-16"></a>}</span>
<span id="cb62-17"><a href="#cb62-17"></a><span class="dt">int</span> n,tot,a[maxn],v[maxn]; ll f[maxn],ans,mn[maxn];</span>
<span id="cb62-18"><a href="#cb62-18"></a><span class="kw">struct</span> nd{<span class="dt">int</span> v,id;}nds[maxn]; <span class="dt">bool</span> cmp(nd a,nd b){<span class="cf">return</span> a.v&lt;b.v;}</span>
<span id="cb62-19"><a href="#cb62-19"></a><span class="dt">int</span> main(){</span>
<span id="cb62-20"><a href="#cb62-20"></a>    n=read(); inc(i,<span class="dv">1</span>,n)nds[i]=(nd){read(),i}; sort(nds+<span class="dv">1</span>,nds+n+<span class="dv">1</span>,cmp);</span>
<span id="cb62-21"><a href="#cb62-21"></a>    inc(i,<span class="dv">1</span>,n){<span class="cf">if</span>(i==<span class="dv">1</span>||nds[i].v!=nds[i-<span class="dv">1</span>].v)v[++tot]=nds[i].v; a[nds[i].id]=tot;}</span>
<span id="cb62-22"><a href="#cb62-22"></a>    memset(f,<span class="dv">0</span>,<span class="kw">sizeof</span>(f)); ans=INF;</span>
<span id="cb62-23"><a href="#cb62-23"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb62-24"><a href="#cb62-24"></a>        mn[tot]=f[tot]+abs(v[tot]-v[a[i]]);</span>
<span id="cb62-25"><a href="#cb62-25"></a>        <span class="cf">for</span>(<span class="dt">int</span> j=tot-<span class="dv">1</span>;j&gt;=<span class="dv">1</span>;j--)mn[j]=min(mn[j+<span class="dv">1</span>],f[j]+abs(v[j]-v[a[i]])); inc(j,<span class="dv">1</span>,tot)f[j]=mn[j];</span>
<span id="cb62-26"><a href="#cb62-26"></a>    }</span>
<span id="cb62-27"><a href="#cb62-27"></a>    inc(i,<span class="dv">1</span>,tot)ans=min(ans,f[i]); memset(f,<span class="dv">0</span>,<span class="kw">sizeof</span>(f));</span>
<span id="cb62-28"><a href="#cb62-28"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb62-29"><a href="#cb62-29"></a>        mn[<span class="dv">1</span>]=f[<span class="dv">1</span>]+abs(v[<span class="dv">1</span>]-v[a[i]]);</span>
<span id="cb62-30"><a href="#cb62-30"></a>        inc(j,<span class="dv">2</span>,tot)mn[j]=min(mn[j-<span class="dv">1</span>],f[j]+abs(v[j]-v[a[i]])); inc(j,<span class="dv">1</span>,tot)f[j]=mn[j];</span>
<span id="cb62-31"><a href="#cb62-31"></a>    }</span>
<span id="cb62-32"><a href="#cb62-32"></a>    inc(i,<span class="dv">1</span>,tot)ans=min(ans,f[i]); printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb62-33"><a href="#cb62-33"></a>}</span></code></pre></div>
<h3 id="bzoj1690usaco2007-dec奶牛的旅行2016.9.21">bzoj1690[Usaco2007 Dec]奶牛的旅行*（2016.9.21）</h3>
<h4 id="题意-62">题意</h4>
<p>n点m边有向图，点有点权，边有边权，奶牛想要从某点出发，走一些路使得经过的点权和除以（浮点数除法）边权和最大，求这个小数（保留两位）。n≤1000，m=5000。</p>
<h4 id="题解-62">题解</h4>
<p>01分数规划！太神了，然而我看不懂证明，所以直接给出算法。假设需要所求小数最大，那么二分这个数，然后将所有边的边权改为分母（需要最小化的部分）*二分的数-分子（需要最大化的部分），然后判负环。如果有，说明解合法，否则解不合法。最后把下界输出。如果需要所求小数最小，则把边权改为分子（需要最大化的部分）-分母（需要最小化的部分）*二分的数，同时改变范围缩小的方向。</p>
<p>而判负环用dfs实现的spfa较快，而且每个节点都必须作为起点遍历一遍以防漏判负环。</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb63-3"><a href="#cb63-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb63-4"><a href="#cb63-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb63-5"><a href="#cb63-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb63-6"><a href="#cb63-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb63-7"><a href="#cb63-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb63-8"><a href="#cb63-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb63-9"><a href="#cb63-9"></a></span>
<span id="cb63-10"><a href="#cb63-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb63-11"><a href="#cb63-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb63-12"><a href="#cb63-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb63-13"><a href="#cb63-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb63-14"><a href="#cb63-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb63-15"><a href="#cb63-15"></a>}</span>
<span id="cb63-16"><a href="#cb63-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t; <span class="dt">double</span> w; <span class="dt">int</span> n;}es[maxn*<span class="dv">5</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb63-17"><a href="#cb63-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,<span class="dv">0</span>,g[f]}; g[f]=ess;}</span>
<span id="cb63-18"><a href="#cb63-18"></a><span class="dt">double</span> v[maxn],w[maxn*<span class="dv">5</span>]; <span class="dt">int</span> n,m;</span>
<span id="cb63-19"><a href="#cb63-19"></a><span class="dt">void</span> rebuild(<span class="dt">double</span> x){inc(i,<span class="dv">1</span>,m)es[i].w=w[i]*x-v[es[i].t];}</span>
<span id="cb63-20"><a href="#cb63-20"></a><span class="dt">bool</span> ins[maxn],f; <span class="dt">double</span> d[maxn];</span>
<span id="cb63-21"><a href="#cb63-21"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb63-22"><a href="#cb63-22"></a>    ins[x]=<span class="dv">1</span>;</span>
<span id="cb63-23"><a href="#cb63-23"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n){</span>
<span id="cb63-24"><a href="#cb63-24"></a>        <span class="cf">if</span>(f)<span class="cf">return</span>;</span>
<span id="cb63-25"><a href="#cb63-25"></a>        <span class="cf">if</span>(d[es[i].t]&gt;d[x]+es[i].w){</span>
<span id="cb63-26"><a href="#cb63-26"></a>            <span class="cf">if</span>(ins[es[i].t]){f=<span class="dv">1</span>; <span class="cf">return</span>;} d[es[i].t]=d[x]+es[i].w; dfs(es[i].t);</span>
<span id="cb63-27"><a href="#cb63-27"></a>        }</span>
<span id="cb63-28"><a href="#cb63-28"></a>    }</span>
<span id="cb63-29"><a href="#cb63-29"></a>    ins[x]=<span class="dv">0</span>;</span>
<span id="cb63-30"><a href="#cb63-30"></a>}</span>
<span id="cb63-31"><a href="#cb63-31"></a><span class="dt">bool</span> spfa(){</span>
<span id="cb63-32"><a href="#cb63-32"></a>    memset(ins,<span class="dv">0</span>,<span class="kw">sizeof</span>(ins)); memset(d,<span class="dv">0</span>,<span class="kw">sizeof</span>(d)); f=<span class="dv">0</span>;</span>
<span id="cb63-33"><a href="#cb63-33"></a>    inc(i,<span class="dv">1</span>,n){dfs(i); <span class="cf">if</span>(f)<span class="cf">return</span> <span class="dv">0</span>;} <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb63-34"><a href="#cb63-34"></a>}</span>
<span id="cb63-35"><a href="#cb63-35"></a><span class="dt">int</span> main(){</span>
<span id="cb63-36"><a href="#cb63-36"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n)v[i]=read(); inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(); w[i]=read(); pe(x,y);}</span>
<span id="cb63-37"><a href="#cb63-37"></a>    <span class="dt">double</span> l=<span class="dv">1</span>,r=<span class="dv">10000</span>;</span>
<span id="cb63-38"><a href="#cb63-38"></a>    <span class="cf">while</span>(r-l&gt;<span class="fl">0.001</span>){</span>
<span id="cb63-39"><a href="#cb63-39"></a>        <span class="dt">double</span> mid=(l+r)/<span class="dv">2</span>; rebuild(mid); <span class="cf">if</span>(!spfa())l=mid;<span class="cf">else</span> r=mid;</span>
<span id="cb63-40"><a href="#cb63-40"></a>    }</span>
<span id="cb63-41"><a href="#cb63-41"></a>    printf(<span class="st">&quot;%.2lf&quot;</span>,l); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb63-42"><a href="#cb63-42"></a>}</span></code></pre></div>
<h3 id="bzoj1486hnoi2009最小圈2016.9.22">bzoj1486[HNOI2009]最小圈（2016.9.22）</h3>
<h4 id="题意-63">题意</h4>
<p>定义图中一个环的平均值为环上边权和除以（浮点除法）边数，求一个图中的最小环平均值，保留8位。n≤3000，m≤10000，有负权边。</p>
<h4 id="题解-63">题解</h4>
<h4 id="根据">根据</h4>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb64-3"><a href="#cb64-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb64-4"><a href="#cb64-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb64-5"><a href="#cb64-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb64-6"><a href="#cb64-6"></a><span class="pp">#define maxn </span><span class="dv">3010</span></span>
<span id="cb64-7"><a href="#cb64-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb64-8"><a href="#cb64-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb64-9"><a href="#cb64-9"></a></span>
<span id="cb64-10"><a href="#cb64-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb64-11"><a href="#cb64-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb64-12"><a href="#cb64-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb64-13"><a href="#cb64-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb64-14"><a href="#cb64-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb64-15"><a href="#cb64-15"></a>}</span>
<span id="cb64-16"><a href="#cb64-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> t; <span class="dt">double</span> w; <span class="dt">int</span> n;}es[maxn*<span class="dv">4</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb64-17"><a href="#cb64-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,<span class="dv">0</span>,g[f]}; g[f]=ess;}</span>
<span id="cb64-18"><a href="#cb64-18"></a><span class="dt">double</span> w[maxn*<span class="dv">4</span>]; <span class="dt">int</span> n,m;</span>
<span id="cb64-19"><a href="#cb64-19"></a><span class="dt">void</span> rebuild(<span class="dt">double</span> x){inc(i,<span class="dv">1</span>,m)es[i].w=w[i]-x;}</span>
<span id="cb64-20"><a href="#cb64-20"></a><span class="dt">bool</span> ins[maxn],f; <span class="dt">double</span> d[maxn];</span>
<span id="cb64-21"><a href="#cb64-21"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb64-22"><a href="#cb64-22"></a>    ins[x]=<span class="dv">1</span>;</span>
<span id="cb64-23"><a href="#cb64-23"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n){</span>
<span id="cb64-24"><a href="#cb64-24"></a>        <span class="cf">if</span>(f)<span class="cf">return</span>;</span>
<span id="cb64-25"><a href="#cb64-25"></a>        <span class="cf">if</span>(d[es[i].t]&gt;d[x]+es[i].w){</span>
<span id="cb64-26"><a href="#cb64-26"></a>            <span class="cf">if</span>(ins[es[i].t]){f=<span class="dv">1</span>; <span class="cf">return</span>;} d[es[i].t]=d[x]+es[i].w; dfs(es[i].t);</span>
<span id="cb64-27"><a href="#cb64-27"></a>        }</span>
<span id="cb64-28"><a href="#cb64-28"></a>    }</span>
<span id="cb64-29"><a href="#cb64-29"></a>    ins[x]=<span class="dv">0</span>;</span>
<span id="cb64-30"><a href="#cb64-30"></a>}</span>
<span id="cb64-31"><a href="#cb64-31"></a><span class="dt">bool</span> spfa(){</span>
<span id="cb64-32"><a href="#cb64-32"></a>    memset(ins,<span class="dv">0</span>,<span class="kw">sizeof</span>(ins)); memset(d,<span class="dv">0</span>,<span class="kw">sizeof</span>(d)); f=<span class="dv">0</span>;</span>
<span id="cb64-33"><a href="#cb64-33"></a>    inc(i,<span class="dv">1</span>,n){dfs(i); <span class="cf">if</span>(f)<span class="cf">return</span> <span class="dv">0</span>;} <span class="cf">return</span> <span class="dv">1</span>;</span>
<span id="cb64-34"><a href="#cb64-34"></a>}</span>
<span id="cb64-35"><a href="#cb64-35"></a><span class="dt">int</span> main(){</span>
<span id="cb64-36"><a href="#cb64-36"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(); scanf(<span class="st">&quot;</span><span class="sc">%lf</span><span class="st">&quot;</span>,&amp;w[i]); pe(x,y);}</span>
<span id="cb64-37"><a href="#cb64-37"></a>    <span class="dt">double</span> l=-<span class="dv">10000000</span>,r=<span class="dv">10000000</span>; <span class="dt">int</span> t=<span class="dv">60</span>;</span>
<span id="cb64-38"><a href="#cb64-38"></a>    <span class="cf">while</span>(t--){</span>
<span id="cb64-39"><a href="#cb64-39"></a>        <span class="dt">double</span> mid=(l+r)/<span class="dv">2</span>; rebuild(mid); <span class="cf">if</span>(!spfa())r=mid;<span class="cf">else</span> l=mid;</span>
<span id="cb64-40"><a href="#cb64-40"></a>    }</span>
<span id="cb64-41"><a href="#cb64-41"></a>    printf(<span class="st">&quot;%.8lf&quot;</span>,l); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb64-42"><a href="#cb64-42"></a>}</span></code></pre></div>
<h3 id="bzoj1637usaco2007-marbalanced-lineup2016.9.22">bzoj1637[Usaco2007 Mar]Balanced Lineup*（2016.9.22）</h3>
<h4 id="题意-64">题意</h4>
<p>n头牛，第i头牛位置为ai，种族为bi（只能为0，1），求一个区间（按数轴位置），使得区间两端牛距离差最大且两种种族牛数相等。n≤50000。</p>
<h4 id="题解-64">题解</h4>
<p>按位置排序。然后利用前缀和sum[i][0]-sum[j-1][0]=sum[i][1]-sum[j-1][1]，sum[i][0]-sum[i][1]=sum[j-1][0]-sum[j-1][1]，故用个set维护sum[i][0]-sum[i][1]的值，每次找一下set里有没有与当前两个sum元素差相等的值，距离差和答案比较一下。</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb65-3"><a href="#cb65-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb65-4"><a href="#cb65-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb65-5"><a href="#cb65-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb65-6"><a href="#cb65-6"></a><span class="pp">#define maxn </span><span class="dv">50010</span></span>
<span id="cb65-7"><a href="#cb65-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb65-8"><a href="#cb65-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb65-9"><a href="#cb65-9"></a></span>
<span id="cb65-10"><a href="#cb65-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb65-11"><a href="#cb65-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb65-12"><a href="#cb65-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb65-13"><a href="#cb65-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb65-14"><a href="#cb65-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb65-15"><a href="#cb65-15"></a>}</span>
<span id="cb65-16"><a href="#cb65-16"></a><span class="kw">struct</span> nd{<span class="dt">int</span> id,v; <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd &amp;a)<span class="at">const</span>{<span class="cf">return</span> v&lt;a.v;};};</span>
<span id="cb65-17"><a href="#cb65-17"></a>nd nds[maxn]; set&lt;nd&gt;st; <span class="dt">int</span> n,sm[<span class="dv">2</span>][maxn],ans;</span>
<span id="cb65-18"><a href="#cb65-18"></a><span class="dt">int</span> main(){</span>
<span id="cb65-19"><a href="#cb65-19"></a>    n=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(),y=read(); nds[i]=(nd){x,y};} sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+n);</span>
<span id="cb65-20"><a href="#cb65-20"></a>    inc(i,<span class="dv">1</span>,n)sm[<span class="dv">0</span>][i]=sm[<span class="dv">0</span>][i-<span class="dv">1</span>],sm[<span class="dv">1</span>][i]=sm[<span class="dv">1</span>][i-<span class="dv">1</span>],sm[nds[i].id][i]++;</span>
<span id="cb65-21"><a href="#cb65-21"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb65-22"><a href="#cb65-22"></a>        set&lt;nd&gt;::iterator sti=st.find((nd){<span class="dv">0</span>,sm[<span class="dv">0</span>][i]-sm[<span class="dv">1</span>][i]});</span>
<span id="cb65-23"><a href="#cb65-23"></a>        <span class="cf">if</span>(sti!=st.end()){ans=max(ans,nds[i].v-nds[sti-&gt;id+<span class="dv">1</span>].v);}</span>
<span id="cb65-24"><a href="#cb65-24"></a>        <span class="cf">else</span> st.insert((nd){i,sm[<span class="dv">0</span>][i]-sm[<span class="dv">1</span>][i]});</span>
<span id="cb65-25"><a href="#cb65-25"></a>    }</span>
<span id="cb65-26"><a href="#cb65-26"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb65-27"><a href="#cb65-27"></a>}</span></code></pre></div>
<h3 id="bzoj1691usaco2007-dec挑剔的美食家2016.9.22">bzoj1691[Usaco2007 Dec]挑剔的美食家（2016.9.22）</h3>
<h4 id="题意-65">题意</h4>
<p>m种牧草，每种都有一个价钱和鲜度，n头奶牛，每头都有一个牧草价钱下限和牧草鲜度上限，要求从每头奶牛从m种牧草中选取一种符合要求的牧草，使得总价钱最小，两头奶牛选的种类不能相同。n，m≤100000。</p>
<h4 id="题解-65">题解</h4>
<p>贪心。先将所有牧草按鲜度排序，奶牛按鲜度下限排序，对于每头奶牛，选的应该是鲜度大于等于它要求的牧草中最便宜的那个，这个可以用set维护。</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb66-5"><a href="#cb66-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb66-6"><a href="#cb66-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb66-7"><a href="#cb66-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb66-8"><a href="#cb66-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb66-9"><a href="#cb66-9"></a></span>
<span id="cb66-10"><a href="#cb66-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb66-11"><a href="#cb66-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb66-12"><a href="#cb66-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb66-13"><a href="#cb66-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb66-14"><a href="#cb66-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb66-15"><a href="#cb66-15"></a>}</span>
<span id="cb66-16"><a href="#cb66-16"></a><span class="kw">struct</span> nd{<span class="dt">int</span> a,b; <span class="dt">bool</span> <span class="kw">operator</span> &lt;(<span class="at">const</span> nd &amp;c)<span class="at">const</span>{<span class="cf">return</span> b&lt;c.b;}}cows[maxn],grass[maxn];</span>
<span id="cb66-17"><a href="#cb66-17"></a>multiset&lt;nd&gt;st; <span class="dt">int</span> n,m,j; ll ans;</span>
<span id="cb66-18"><a href="#cb66-18"></a><span class="dt">int</span> main(){</span>
<span id="cb66-19"><a href="#cb66-19"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(),y=read(); cows[i]=(nd){x,y};}</span>
<span id="cb66-20"><a href="#cb66-20"></a>    inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(); grass[i]=(nd){x,y};} sort(cows+<span class="dv">1</span>,cows+<span class="dv">1</span>+n); sort(grass+<span class="dv">1</span>,grass+<span class="dv">1</span>+m);</span>
<span id="cb66-21"><a href="#cb66-21"></a>    <span class="cf">for</span>(j=m;j&gt;=<span class="dv">1</span>&amp;&amp;grass[j].b&gt;=cows[n].b;j--)st.insert((nd){grass[j].b,grass[j].a});</span>
<span id="cb66-22"><a href="#cb66-22"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=n;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb66-23"><a href="#cb66-23"></a>        multiset&lt;nd&gt;::iterator sti=st.lower_bound((nd){cows[i].b,cows[i].a});</span>
<span id="cb66-24"><a href="#cb66-24"></a>        <span class="cf">if</span>(sti==st.end()){printf(<span class="st">&quot;-1&quot;</span>); <span class="cf">return</span> <span class="dv">0</span>;} ans+=sti-&gt;b; st.erase(sti);</span>
<span id="cb66-25"><a href="#cb66-25"></a>        <span class="cf">for</span>(j;j&gt;=<span class="dv">1</span>&amp;&amp;grass[j].b&gt;=cows[i-<span class="dv">1</span>].b;j--)st.insert((nd){grass[j].b,grass[j].a});</span>
<span id="cb66-26"><a href="#cb66-26"></a>    }</span>
<span id="cb66-27"><a href="#cb66-27"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb66-28"><a href="#cb66-28"></a>}</span></code></pre></div>
<h3 id="bzoj1672usaco2005-deccleaning-shifts-清理牛棚2016.9.23">bzoj1672[Usaco2005 Dec]Cleaning Shifts 清理牛棚（2016.9.23）</h3>
<h4 id="题意-66">题意</h4>
<p>n头奶牛，第i头愿意在时刻si到ti打扫牛棚，费用为ci，求打扫S到T时刻的最小费用。n≤10000，时刻≤90000。</p>
<h4 id="题解-66">题解</h4>
<p>最短路，si和ti+1连边，长度为ci，以及所有时刻ai和ai-1连边，长度为0，以保证覆盖的情况被处理。然后求S到T的最短路。好像大部分的神犇用的是线段树。</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb67-4"><a href="#cb67-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb67-5"><a href="#cb67-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb67-6"><a href="#cb67-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb67-7"><a href="#cb67-7"></a><span class="pp">#define INF </span><span class="dv">10000000000000000</span></span>
<span id="cb67-8"><a href="#cb67-8"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb67-9"><a href="#cb67-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb67-10"><a href="#cb67-10"></a></span>
<span id="cb67-11"><a href="#cb67-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb67-12"><a href="#cb67-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb67-13"><a href="#cb67-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb67-14"><a href="#cb67-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb67-15"><a href="#cb67-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb67-16"><a href="#cb67-16"></a>}</span>
<span id="cb67-17"><a href="#cb67-17"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,w,n;}es[maxn]; <span class="dt">int</span> g[maxn],ess,n,be,en; <span class="dt">bool</span> inq[maxn]; queue&lt;<span class="dt">int</span>&gt;q; ll d[maxn];</span>
<span id="cb67-18"><a href="#cb67-18"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t,<span class="dt">int</span> w){es[++ess]=(e){t,w,g[f]}; g[f]=ess;}</span>
<span id="cb67-19"><a href="#cb67-19"></a><span class="dt">void</span> spfa(<span class="dt">int</span> s){</span>
<span id="cb67-20"><a href="#cb67-20"></a>    <span class="cf">while</span>(!q.empty())q.pop(); memset(inq,<span class="dv">0</span>,<span class="kw">sizeof</span>(inq)); inc(i,be,en)d[i]=INF;</span>
<span id="cb67-21"><a href="#cb67-21"></a>    q.push(s); inq[s]=<span class="dv">1</span>; d[s]=<span class="dv">0</span>;</span>
<span id="cb67-22"><a href="#cb67-22"></a>    <span class="cf">while</span>(!q.empty()){</span>
<span id="cb67-23"><a href="#cb67-23"></a>        <span class="dt">int</span> x=q.front(); q.pop(); inq[x]=<span class="dv">0</span>;</span>
<span id="cb67-24"><a href="#cb67-24"></a>        <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(d[es[i].t]&gt;d[x]+es[i].w){</span>
<span id="cb67-25"><a href="#cb67-25"></a>            d[es[i].t]=d[x]+es[i].w;</span>
<span id="cb67-26"><a href="#cb67-26"></a>            <span class="cf">if</span>(!inq[es[i].t])q.push(es[i].t),inq[es[i].t]=<span class="dv">1</span>;</span>
<span id="cb67-27"><a href="#cb67-27"></a>        }</span>
<span id="cb67-28"><a href="#cb67-28"></a>    }</span>
<span id="cb67-29"><a href="#cb67-29"></a>}</span>
<span id="cb67-30"><a href="#cb67-30"></a><span class="dt">int</span> main(){</span>
<span id="cb67-31"><a href="#cb67-31"></a>    n=read(); be=read(); en=read()+<span class="dv">1</span>; inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> a=read(),b=read()+<span class="dv">1</span>,c=read(); pe(a,b,c);}</span>
<span id="cb67-32"><a href="#cb67-32"></a>    inc(i,be,en)pe(i+<span class="dv">1</span>,i,<span class="dv">0</span>); spfa(be); printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,d[en]==INF?-<span class="dv">1</span>:d[en]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb67-33"><a href="#cb67-33"></a>}</span></code></pre></div>
<h3 id="bzoj1589usaco2008-dectrick-or-treat-on-the-farm-采集糖果2016.9.23">bzoj1589[Usaco2008 Dec]Trick or Treat on the Farm 采集糖果（2016.9.23）</h3>
<h4 id="题意-67">题意</h4>
<p>n个节点，每个节点有一个后继节点，问从每个节点出发能到多少个没去过的节点。n≤100000。</p>
<h4 id="题解-67">题解</h4>
<p>因为每个节点只有一个后继节点，所有tarjan缩点后就会变成一堆链，对每条链dfs一下即可。</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb68-3"><a href="#cb68-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb68-5"><a href="#cb68-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb68-6"><a href="#cb68-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb68-7"><a href="#cb68-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb68-8"><a href="#cb68-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb68-9"><a href="#cb68-9"></a></span>
<span id="cb68-10"><a href="#cb68-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb68-11"><a href="#cb68-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb68-12"><a href="#cb68-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb68-13"><a href="#cb68-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb68-14"><a href="#cb68-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb68-15"><a href="#cb68-15"></a>}</span>
<span id="cb68-16"><a href="#cb68-16"></a><span class="kw">struct</span> e{<span class="dt">int</span> f,t,n;}es[maxn]; <span class="dt">int</span> g[maxn],ess,n;</span>
<span id="cb68-17"><a href="#cb68-17"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){f,t,g[f]}; g[f]=ess;}</span>
<span id="cb68-18"><a href="#cb68-18"></a><span class="dt">bool</span> vis[maxn]; <span class="dt">int</span> bel[maxn],sm[maxn],tim,pre[maxn],low[maxn],tot,ins[maxn]; stack&lt;<span class="dt">int</span>&gt;st;</span>
<span id="cb68-19"><a href="#cb68-19"></a><span class="dt">void</span> dfs1(<span class="dt">int</span> x){</span>
<span id="cb68-20"><a href="#cb68-20"></a>    vis[x]=ins[x]=<span class="dv">1</span>; st.push(x); low[x]=pre[x]=++tim;</span>
<span id="cb68-21"><a href="#cb68-21"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)</span>
<span id="cb68-22"><a href="#cb68-22"></a>        <span class="cf">if</span>(!vis[es[i].t])dfs1(es[i].t),low[x]=min(low[x],low[es[i].t]);</span>
<span id="cb68-23"><a href="#cb68-23"></a>        <span class="cf">else</span> <span class="cf">if</span>(ins[es[i].t])low[x]=min(low[x],pre[es[i].t]);</span>
<span id="cb68-24"><a href="#cb68-24"></a>    <span class="cf">if</span>(low[x]==pre[x]){</span>
<span id="cb68-25"><a href="#cb68-25"></a>        tot++;</span>
<span id="cb68-26"><a href="#cb68-26"></a>        <span class="cf">while</span>(!st.empty()){</span>
<span id="cb68-27"><a href="#cb68-27"></a>            <span class="dt">int</span> now=st.top(); st.pop(); bel[now]=tot; sm[tot]++; ins[now]=<span class="dv">0</span>; <span class="cf">if</span>(now==x)<span class="cf">break</span>;</span>
<span id="cb68-28"><a href="#cb68-28"></a>        }</span>
<span id="cb68-29"><a href="#cb68-29"></a>    }</span>
<span id="cb68-30"><a href="#cb68-30"></a>}</span>
<span id="cb68-31"><a href="#cb68-31"></a><span class="dt">void</span> dfs2(<span class="dt">int</span> x){</span>
<span id="cb68-32"><a href="#cb68-32"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n){</span>
<span id="cb68-33"><a href="#cb68-33"></a>        <span class="cf">if</span>(!vis[es[i].t])vis[es[i].t]=<span class="dv">1</span>,dfs2(es[i].t),sm[x]+=sm[es[i].t];<span class="cf">else</span> sm[x]+=sm[es[i].t];</span>
<span id="cb68-34"><a href="#cb68-34"></a>    }</span>
<span id="cb68-35"><a href="#cb68-35"></a>}</span>
<span id="cb68-36"><a href="#cb68-36"></a><span class="dt">int</span> main(){</span>
<span id="cb68-37"><a href="#cb68-37"></a>    n=read(); inc(i,<span class="dv">1</span>,n){<span class="dt">int</span> x=read(); pe(i,x);} inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(!vis[i])dfs1(i);</span>
<span id="cb68-38"><a href="#cb68-38"></a>    <span class="dt">int</span> m=ess; ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb68-39"><a href="#cb68-39"></a>    inc(i,<span class="dv">1</span>,m)<span class="cf">if</span>(bel[es[i].f]!=bel[es[i].t])pe(bel[es[i].f],bel[es[i].t]);</span>
<span id="cb68-40"><a href="#cb68-40"></a>    memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); inc(i,<span class="dv">1</span>,tot)<span class="cf">if</span>(!vis[i])vis[i]=<span class="dv">1</span>,dfs2(i);</span>
<span id="cb68-41"><a href="#cb68-41"></a>    inc(i,<span class="dv">1</span>,n)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,sm[bel[i]]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb68-42"><a href="#cb68-42"></a>}</span></code></pre></div>
<h3 id="bzoj1635usaco2007-jantallest-cow-最高的牛2016.9.23">bzoj1635[Usaco2007 Jan]Tallest Cow 最高的牛*（2016.9.23）</h3>
<h4 id="题意-68">题意</h4>
<p>n头牛，知道所有牛身高不超过h，给出r条关系(a,b)表示第a+1到b-1头牛都比a，b牛矮，且a牛不必b牛高，问每头牛的最高身高。n≤10000，r≤10000。</p>
<h4 id="题解-68">题解</h4>
<p>那个“a牛不必比b牛高”的条件没什么用，且中间那些牛都比左右牛矮直接让它们比两边牛矮1即可。故用差分序列的方法sum[a+1]–,sum[b]++，然后将sum累加起来加上h即可。还有条件可能有重复的要判重。</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb69-2"><a href="#cb69-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb69-3"><a href="#cb69-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb69-4"><a href="#cb69-4"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb69-5"><a href="#cb69-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb69-6"><a href="#cb69-6"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb69-7"><a href="#cb69-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb69-8"><a href="#cb69-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb69-9"><a href="#cb69-9"></a></span>
<span id="cb69-10"><a href="#cb69-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb69-11"><a href="#cb69-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb69-12"><a href="#cb69-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb69-13"><a href="#cb69-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb69-14"><a href="#cb69-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb69-15"><a href="#cb69-15"></a>}</span>
<span id="cb69-16"><a href="#cb69-16"></a><span class="dt">int</span> h[maxn],n,k,m,r; <span class="kw">struct</span> ask{<span class="dt">int</span> a,b;}asks[maxn];</span>
<span id="cb69-17"><a href="#cb69-17"></a><span class="dt">bool</span> cmp(ask a,ask b){<span class="cf">return</span> a.a==b.a?a.b&lt;b.b:a.a&lt;b.a;}</span>
<span id="cb69-18"><a href="#cb69-18"></a><span class="dt">int</span> main(){</span>
<span id="cb69-19"><a href="#cb69-19"></a>    n=read(); k=read(); m=read(); r=read();</span>
<span id="cb69-20"><a href="#cb69-20"></a>    inc(i,<span class="dv">1</span>,r){<span class="dt">int</span> x=read(),y=read(); asks[i]=(ask){min(x,y)+<span class="dv">1</span>,max(x,y)-<span class="dv">1</span>};} sort(asks+<span class="dv">1</span>,asks+r+<span class="dv">1</span>,cmp);</span>
<span id="cb69-21"><a href="#cb69-21"></a>    inc(i,<span class="dv">1</span>,r){</span>
<span id="cb69-22"><a href="#cb69-22"></a>        <span class="cf">if</span>(asks[i].a==asks[i-<span class="dv">1</span>].a&amp;&amp;asks[i].b==asks[i-<span class="dv">1</span>].b)<span class="cf">continue</span>; h[asks[i].a]--; h[asks[i].b+<span class="dv">1</span>]++;</span>
<span id="cb69-23"><a href="#cb69-23"></a>    }</span>
<span id="cb69-24"><a href="#cb69-24"></a>    h[<span class="dv">0</span>]=m; inc(i,<span class="dv">1</span>,n)h[i]+=h[i-<span class="dv">1</span>],printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,h[i]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb69-25"><a href="#cb69-25"></a>}</span></code></pre></div>
<h3 id="bzoj1649usaco2006-deccow-roller-coaster2016.9.23">bzoj1649[Usaco2006 Dec]Cow Roller Coaster*（2016.9.23）</h3>
<h4 id="题意-69">题意</h4>
<p>n条钢轨，第i条起点pi，长度为wi，价钱ci，有趣度fi，要求从0修到l使得总价钱不超过b的前提下有趣度和最大。n≤10000，l≤1000，b≤1000。</p>
<h4 id="题解-69">题解</h4>
<p>首先把钢轨组织成链表。接着dp：f[i][j]表示修到第i处花钱j，则f[i][j]=f[i-wk][j-ck]+fk,k为终点为i的钢轨。边界则设为f[0][j]都为0，f[i][j]都为负无穷，以保证从0开始修。</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb70-2"><a href="#cb70-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb70-3"><a href="#cb70-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb70-5"><a href="#cb70-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb70-6"><a href="#cb70-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb70-7"><a href="#cb70-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb70-8"><a href="#cb70-8"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb70-9"><a href="#cb70-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb70-10"><a href="#cb70-10"></a></span>
<span id="cb70-11"><a href="#cb70-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb70-12"><a href="#cb70-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb70-13"><a href="#cb70-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb70-14"><a href="#cb70-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb70-15"><a href="#cb70-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb70-16"><a href="#cb70-16"></a>}</span>
<span id="cb70-17"><a href="#cb70-17"></a><span class="kw">struct</span> nd{<span class="dt">int</span> w,f,c,n;}nds[maxn*<span class="dv">10</span>]; <span class="dt">int</span> g[maxn];</span>
<span id="cb70-18"><a href="#cb70-18"></a><span class="dt">int</span> f[maxn][maxn],l,n,b;</span>
<span id="cb70-19"><a href="#cb70-19"></a><span class="dt">int</span> main(){</span>
<span id="cb70-20"><a href="#cb70-20"></a>    l=read(); n=read(); b=read();</span>
<span id="cb70-21"><a href="#cb70-21"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb70-22"><a href="#cb70-22"></a>        <span class="dt">int</span> o=read(),p=read(),q=read(),r=read(); nds[i]=(nd){p,q,r,g[o+p]}; g[o+p]=i;</span>
<span id="cb70-23"><a href="#cb70-23"></a>    }</span>
<span id="cb70-24"><a href="#cb70-24"></a>    inc(i,<span class="dv">1</span>,l)inc(j,<span class="dv">0</span>,b)f[i][j]=-INF; inc(i,<span class="dv">0</span>,b)f[<span class="dv">0</span>][i]=<span class="dv">0</span>;</span>
<span id="cb70-25"><a href="#cb70-25"></a>    inc(i,<span class="dv">0</span>,l){</span>
<span id="cb70-26"><a href="#cb70-26"></a>        inc(j,<span class="dv">0</span>,b){</span>
<span id="cb70-27"><a href="#cb70-27"></a>            <span class="cf">for</span>(<span class="dt">int</span> k=g[i];k;k=nds[k].n)</span>
<span id="cb70-28"><a href="#cb70-28"></a>                <span class="cf">if</span>(j&gt;=nds[k].c)f[i][j]=max(f[i][j],f[i-nds[k].w][j-nds[k].c]+nds[k].f);</span>
<span id="cb70-29"><a href="#cb70-29"></a>        }</span>
<span id="cb70-30"><a href="#cb70-30"></a>    }</span>
<span id="cb70-31"><a href="#cb70-31"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,f[l][b]&lt;<span class="dv">0</span>?-<span class="dv">1</span>:f[l][b]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb70-32"><a href="#cb70-32"></a>}</span></code></pre></div>
<h3 id="bzoj1643usaco2007-octbessies-secret-pasture-贝茜的秘密草坪2016.9.26">bzoj1643[Usaco2007 Oct]Bessie’s Secret Pasture 贝茜的秘密草坪*（2016.9.26）</h3>
<h4 id="题意-70">题意</h4>
<p>给出n，问4个整数的平方和为n有多少种方案，顺序不同也算。n≤10000。</p>
<h4 id="题解-70">题解</h4>
<p>神犇们都用dp，我不会……故直接三重循环枚举1到sqrt(n)判断第四个数是不是整数，结果排名倒数。</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb71-2"><a href="#cb71-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb71-3"><a href="#cb71-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb71-4"><a href="#cb71-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb71-5"><a href="#cb71-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb71-6"><a href="#cb71-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb71-7"><a href="#cb71-7"></a></span>
<span id="cb71-8"><a href="#cb71-8"></a><span class="dt">int</span> n,ans;</span>
<span id="cb71-9"><a href="#cb71-9"></a><span class="dt">int</span> main(){</span>
<span id="cb71-10"><a href="#cb71-10"></a>    scanf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,&amp;n);</span>
<span id="cb71-11"><a href="#cb71-11"></a>    inc(i,<span class="dv">0</span>,(<span class="dt">int</span>)sqrt(n))inc(j,<span class="dv">0</span>,(<span class="dt">int</span>)sqrt(n))inc(k,<span class="dv">0</span>,(<span class="dt">int</span>)sqrt(n))</span>
<span id="cb71-12"><a href="#cb71-12"></a>        <span class="cf">if</span>(i*i+j*j+k*k&lt;=n&amp;&amp;(<span class="dt">double</span>)((<span class="dt">int</span>)sqrt(n-i*i-j*j-k*k))==sqrt(n-i*i-j*j-k*k))ans++;</span>
<span id="cb71-13"><a href="#cb71-13"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb71-14"><a href="#cb71-14"></a>}</span></code></pre></div>
<h3 id="bzoj1707usaco2007-novtanning分配防晒霜2016.9.26">bzoj1707[Usaco2007 Nov]tanning分配防晒霜*（2016.9.26）</h3>
<h4 id="题意-71">题意</h4>
<p>n头牛，第i头适应spf值在ai到bi之间的防晒霜。m种防晒霜，每种spf值为ci，有di瓶，问最多多少奶牛能得到合适的防晒霜。n，m≤2500。</p>
<h4 id="题解-71">题解</h4>
<p>贪心，把牛按上限从小到大排序，然后对于每只奶牛，应该选它可以用的spf值最低的防晒霜。这个过程可以用set维护。</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb72-2"><a href="#cb72-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb72-3"><a href="#cb72-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb72-4"><a href="#cb72-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb72-5"><a href="#cb72-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb72-6"><a href="#cb72-6"></a><span class="pp">#define maxn </span><span class="dv">2510</span></span>
<span id="cb72-7"><a href="#cb72-7"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb72-8"><a href="#cb72-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb72-9"><a href="#cb72-9"></a></span>
<span id="cb72-10"><a href="#cb72-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb72-11"><a href="#cb72-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb72-12"><a href="#cb72-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb72-13"><a href="#cb72-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb72-14"><a href="#cb72-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb72-15"><a href="#cb72-15"></a>}</span>
<span id="cb72-16"><a href="#cb72-16"></a><span class="kw">struct</span> nd{<span class="dt">int</span> l,r; <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd &amp;a)<span class="at">const</span>{<span class="cf">return</span> r==a.r?l&lt;a.l:r&lt;a.r;}}nds[maxn];</span>
<span id="cb72-17"><a href="#cb72-17"></a>multiset&lt;nd&gt;st; <span class="dt">int</span> c,l,ans;</span>
<span id="cb72-18"><a href="#cb72-18"></a><span class="dt">int</span> main(){</span>
<span id="cb72-19"><a href="#cb72-19"></a>    c=read(); l=read(); inc(i,<span class="dv">1</span>,c)nds[i].l=read(),nds[i].r=read(); sort(nds+<span class="dv">1</span>,nds+<span class="dv">1</span>+c);</span>
<span id="cb72-20"><a href="#cb72-20"></a>    inc(i,<span class="dv">1</span>,l){<span class="dt">int</span> x=read(),y=read(); st.insert((nd){y,x});} st.insert((nd){<span class="dv">0</span>,INF});</span>
<span id="cb72-21"><a href="#cb72-21"></a>    inc(i,<span class="dv">1</span>,c){</span>
<span id="cb72-22"><a href="#cb72-22"></a>        multiset&lt;nd&gt;::iterator sti=st.lower_bound((nd){<span class="dv">0</span>,nds[i].l}); <span class="cf">if</span>(sti-&gt;r&gt;nds[i].r)<span class="cf">continue</span>;</span>
<span id="cb72-23"><a href="#cb72-23"></a>        <span class="dt">int</span> x=sti-&gt;l,y=sti-&gt;r; st.erase(sti); x--; <span class="cf">if</span>(x)st.insert((nd){x,y}); ans++;</span>
<span id="cb72-24"><a href="#cb72-24"></a>    }</span>
<span id="cb72-25"><a href="#cb72-25"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb72-26"><a href="#cb72-26"></a>}</span></code></pre></div>
<h3 id="bzoj1753usaco2005-quawhos-in-the-middle2016.9.26">bzoj1753[Usaco2005 qua]Who’s in the Middle*（2016.9.26）</h3>
<h4 id="题意-72">题意</h4>
<p>输入N个数,输出升序排列后中间那个数。n≤10000。</p>
<h4 id="题解-72">题解</h4>
<p>本来想交个python的结果莫名奇妙RE了~</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb73-2"><a href="#cb73-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb73-3"><a href="#cb73-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb73-4"><a href="#cb73-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb73-5"><a href="#cb73-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb73-6"><a href="#cb73-6"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb73-7"><a href="#cb73-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb73-8"><a href="#cb73-8"></a></span>
<span id="cb73-9"><a href="#cb73-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb73-10"><a href="#cb73-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb73-11"><a href="#cb73-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb73-12"><a href="#cb73-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb73-13"><a href="#cb73-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb73-14"><a href="#cb73-14"></a>}</span>
<span id="cb73-15"><a href="#cb73-15"></a><span class="dt">int</span> a[maxn],n;</span>
<span id="cb73-16"><a href="#cb73-16"></a><span class="dt">int</span> main(){</span>
<span id="cb73-17"><a href="#cb73-17"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); sort(a+<span class="dv">1</span>,a+n+<span class="dv">1</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,a[(n+<span class="dv">1</span>)/<span class="dv">2</span>]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb73-18"><a href="#cb73-18"></a>}</span></code></pre></div>
<h3 id="bzoj1574usaco2009-jan地震损坏damage2016.9.26">bzoj1574[Usaco2009 Jan]地震损坏Damage*（2016.9.26）</h3>
<h4 id="题意-73">题意</h4>
<p>n点m边无向图，知道p条信息ai，表示ai没被损坏但它和点1不联通（损坏的点不能通行），问有多少点和1联通（不包括损坏的点）。n≤30000，m≤100000。</p>
<h4 id="题解-73">题解</h4>
<p>有一个结论，最优删点方案应该是对每个信息ai，将所有ai的相邻点均设为损坏。在这之后DFS求联通性即可。</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb74-2"><a href="#cb74-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb74-3"><a href="#cb74-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb74-4"><a href="#cb74-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb74-5"><a href="#cb74-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb74-6"><a href="#cb74-6"></a><span class="pp">#define maxn </span><span class="dv">30010</span></span>
<span id="cb74-7"><a href="#cb74-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb74-8"><a href="#cb74-8"></a></span>
<span id="cb74-9"><a href="#cb74-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb74-10"><a href="#cb74-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb74-11"><a href="#cb74-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb74-12"><a href="#cb74-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb74-13"><a href="#cb74-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb74-14"><a href="#cb74-14"></a>}</span>
<span id="cb74-15"><a href="#cb74-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}es[maxn*<span class="dv">8</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb74-16"><a href="#cb74-16"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess;}</span>
<span id="cb74-17"><a href="#cb74-17"></a><span class="dt">bool</span> vis[maxn]; <span class="dt">int</span> n,m,p,ans;</span>
<span id="cb74-18"><a href="#cb74-18"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb74-19"><a href="#cb74-19"></a>    ans++; <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(!vis[es[i].t])vis[es[i].t]=<span class="dv">1</span>,dfs(es[i].t);</span>
<span id="cb74-20"><a href="#cb74-20"></a>}</span>
<span id="cb74-21"><a href="#cb74-21"></a><span class="dt">int</span> main(){</span>
<span id="cb74-22"><a href="#cb74-22"></a>    n=read(); m=read(); p=read(); inc(i,<span class="dv">1</span>,m){<span class="dt">int</span> x=read(),y=read(); pe(x,y); pe(y,x);}</span>
<span id="cb74-23"><a href="#cb74-23"></a>    inc(i,<span class="dv">1</span>,p){<span class="dt">int</span> x=read(); <span class="cf">for</span>(<span class="dt">int</span> j=g[x];j;j=es[j].n)<span class="cf">if</span>(es[j].t!=x)vis[es[j].t]=<span class="dv">1</span>;}</span>
<span id="cb74-24"><a href="#cb74-24"></a>    vis[<span class="dv">1</span>]=<span class="dv">1</span>; dfs(<span class="dv">1</span>); printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,n-ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb74-25"><a href="#cb74-25"></a>}</span></code></pre></div>
<h3 id="bzoj1593usaco2008-febhotel-旅馆2016.9.26">bzoj1593[Usaco2008 Feb]Hotel 旅馆*（2016.9.26）</h3>
<h4 id="题意-74">题意</h4>
<p>给个长度为n的全为0的序列，m种操作，1 di表示求序列中最早出现的长度为di的值为0的连续子序列，并把这个连续子序列赋为1；2 xi，di表示将[xi,xi+di-1]置为0。n，m≤50000。</p>
<h4 id="题解-74">题解</h4>
<p>用一个线段树，维护三个值：最长为0连续子序列，最长为0后缀，最长为0前缀。然后注意一下合并就行了。</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb75-2"><a href="#cb75-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb75-3"><a href="#cb75-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb75-4"><a href="#cb75-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb75-5"><a href="#cb75-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb75-6"><a href="#cb75-6"></a><span class="pp">#define maxn </span><span class="dv">150010</span></span>
<span id="cb75-7"><a href="#cb75-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb75-8"><a href="#cb75-8"></a></span>
<span id="cb75-9"><a href="#cb75-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb75-10"><a href="#cb75-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb75-11"><a href="#cb75-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb75-12"><a href="#cb75-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb75-13"><a href="#cb75-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb75-14"><a href="#cb75-14"></a>}</span>
<span id="cb75-15"><a href="#cb75-15"></a><span class="dt">int</span> ls[maxn],rs[maxn],ms[maxn],len[maxn],tg[maxn],n,m;</span>
<span id="cb75-16"><a href="#cb75-16"></a><span class="dt">void</span> update(<span class="dt">int</span> x){</span>
<span id="cb75-17"><a href="#cb75-17"></a>    ms[x]=max(rs[x&lt;&lt;<span class="dv">1</span>]+ls[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>],max(ms[x&lt;&lt;<span class="dv">1</span>],ms[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]));</span>
<span id="cb75-18"><a href="#cb75-18"></a>    ls[x]=(ms[x&lt;&lt;<span class="dv">1</span>]==len[x&lt;&lt;<span class="dv">1</span>])?len[x&lt;&lt;<span class="dv">1</span>]+ls[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]:ls[x&lt;&lt;<span class="dv">1</span>];</span>
<span id="cb75-19"><a href="#cb75-19"></a>    rs[x]=(ms[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]==len[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>])?len[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]+rs[x&lt;&lt;<span class="dv">1</span>]:rs[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>];</span>
<span id="cb75-20"><a href="#cb75-20"></a>}</span>
<span id="cb75-21"><a href="#cb75-21"></a><span class="dt">void</span> pushdown(<span class="dt">int</span> x){</span>
<span id="cb75-22"><a href="#cb75-22"></a>    <span class="cf">if</span>(len[x]&gt;<span class="dv">1</span>){</span>
<span id="cb75-23"><a href="#cb75-23"></a>        <span class="cf">if</span>(tg[x]==<span class="dv">0</span>){</span>
<span id="cb75-24"><a href="#cb75-24"></a>            ms[x&lt;&lt;<span class="dv">1</span>]=ls[x&lt;&lt;<span class="dv">1</span>]=rs[x&lt;&lt;<span class="dv">1</span>]=len[x&lt;&lt;<span class="dv">1</span>]; tg[x&lt;&lt;<span class="dv">1</span>]=<span class="dv">0</span>;</span>
<span id="cb75-25"><a href="#cb75-25"></a>            ms[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=ls[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=rs[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=len[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]; tg[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=<span class="dv">0</span>; tg[x]=-<span class="dv">1</span>;</span>
<span id="cb75-26"><a href="#cb75-26"></a>        }</span>
<span id="cb75-27"><a href="#cb75-27"></a>        <span class="cf">if</span>(tg[x]==<span class="dv">1</span>){</span>
<span id="cb75-28"><a href="#cb75-28"></a>            ms[x&lt;&lt;<span class="dv">1</span>]=ls[x&lt;&lt;<span class="dv">1</span>]=rs[x&lt;&lt;<span class="dv">1</span>]=<span class="dv">0</span>; tg[x&lt;&lt;<span class="dv">1</span>]=<span class="dv">1</span>;</span>
<span id="cb75-29"><a href="#cb75-29"></a>            ms[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=ls[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=rs[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=<span class="dv">0</span>; tg[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]=<span class="dv">1</span>; tg[x]=-<span class="dv">1</span>;</span>
<span id="cb75-30"><a href="#cb75-30"></a>        }</span>
<span id="cb75-31"><a href="#cb75-31"></a>    }</span>
<span id="cb75-32"><a href="#cb75-32"></a>}</span>
<span id="cb75-33"><a href="#cb75-33"></a><span class="dt">void</span> build(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb75-34"><a href="#cb75-34"></a>    len[x]=r-l+<span class="dv">1</span>; tg[x]=-<span class="dv">1</span>; <span class="cf">if</span>(l==r){ls[x]=rs[x]=ms[x]=<span class="dv">1</span>; <span class="cf">return</span>;}</span>
<span id="cb75-35"><a href="#cb75-35"></a>    <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; build(x&lt;&lt;<span class="dv">1</span>,l,mid); build(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r); update(x);</span>
<span id="cb75-36"><a href="#cb75-36"></a>}</span>
<span id="cb75-37"><a href="#cb75-37"></a><span class="dt">int</span> query(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> v){</span>
<span id="cb75-38"><a href="#cb75-38"></a>    pushdown(x); <span class="cf">if</span>(ms[x]&lt;v)<span class="cf">return</span> <span class="dv">0</span>; <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb75-39"><a href="#cb75-39"></a>    <span class="cf">if</span>(ms[x&lt;&lt;<span class="dv">1</span>]&gt;=v)<span class="cf">return</span> query(x&lt;&lt;<span class="dv">1</span>,l,mid,v); <span class="cf">if</span>(rs[x&lt;&lt;<span class="dv">1</span>]+ls[x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>]&gt;=v)<span class="cf">return</span> mid-rs[x&lt;&lt;<span class="dv">1</span>]+<span class="dv">1</span>;</span>
<span id="cb75-40"><a href="#cb75-40"></a>    <span class="cf">return</span> query(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r,v);</span>
<span id="cb75-41"><a href="#cb75-41"></a>}</span>
<span id="cb75-42"><a href="#cb75-42"></a><span class="dt">void</span> fill(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb75-43"><a href="#cb75-43"></a>    pushdown(x);</span>
<span id="cb75-44"><a href="#cb75-44"></a>    <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr){ms[x]=ls[x]=rs[x]=<span class="dv">0</span>; tg[x]=<span class="dv">1</span>; <span class="cf">return</span>;} <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb75-45"><a href="#cb75-45"></a>    <span class="cf">if</span>(ql&lt;=mid)fill(x&lt;&lt;<span class="dv">1</span>,l,mid,ql,qr); <span class="cf">if</span>(mid&lt;qr)fill(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r,ql,qr);</span>
<span id="cb75-46"><a href="#cb75-46"></a>    update(x);</span>
<span id="cb75-47"><a href="#cb75-47"></a>}</span>
<span id="cb75-48"><a href="#cb75-48"></a><span class="dt">void</span> clear(<span class="dt">int</span> x,<span class="dt">int</span> l,<span class="dt">int</span> r,<span class="dt">int</span> ql,<span class="dt">int</span> qr){</span>
<span id="cb75-49"><a href="#cb75-49"></a>    pushdown(x);</span>
<span id="cb75-50"><a href="#cb75-50"></a>    <span class="cf">if</span>(ql&lt;=l&amp;&amp;r&lt;=qr){ms[x]=ls[x]=rs[x]=len[x]; tg[x]=<span class="dv">0</span>; <span class="cf">return</span>;} <span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>;</span>
<span id="cb75-51"><a href="#cb75-51"></a>    <span class="cf">if</span>(ql&lt;=mid)clear(x&lt;&lt;<span class="dv">1</span>,l,mid,ql,qr); <span class="cf">if</span>(mid&lt;qr)clear(x&lt;&lt;<span class="dv">1</span>|<span class="dv">1</span>,mid+<span class="dv">1</span>,r,ql,qr);</span>
<span id="cb75-52"><a href="#cb75-52"></a>    update(x);</span>
<span id="cb75-53"><a href="#cb75-53"></a>}</span>
<span id="cb75-54"><a href="#cb75-54"></a><span class="dt">int</span> main(){</span>
<span id="cb75-55"><a href="#cb75-55"></a>    n=read(); build(<span class="dv">1</span>,<span class="dv">1</span>,n); m=read();</span>
<span id="cb75-56"><a href="#cb75-56"></a>    inc(i,<span class="dv">1</span>,m){</span>
<span id="cb75-57"><a href="#cb75-57"></a>        <span class="dt">int</span> x=read();</span>
<span id="cb75-58"><a href="#cb75-58"></a>        <span class="cf">if</span>(x==<span class="dv">1</span>){<span class="dt">int</span> y=read(),z=query(<span class="dv">1</span>,<span class="dv">1</span>,n,y); printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,z); <span class="cf">if</span>(z)fill(<span class="dv">1</span>,<span class="dv">1</span>,n,z,z+y-<span class="dv">1</span>);}</span>
<span id="cb75-59"><a href="#cb75-59"></a>        <span class="cf">if</span>(x==<span class="dv">2</span>){<span class="dt">int</span> y=read(),z=read(); clear(<span class="dv">1</span>,<span class="dv">1</span>,n,y,y+z-<span class="dv">1</span>);}</span>
<span id="cb75-60"><a href="#cb75-60"></a>    }</span>
<span id="cb75-61"><a href="#cb75-61"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb75-62"><a href="#cb75-62"></a>}</span></code></pre></div>
<h3 id="bzoj1655usaco2006-jan-dollar-dayz-奶牛商店2016.9.27">bzoj1655[Usaco2006 Jan] Dollar Dayz 奶牛商店*（2016.9.27）</h3>
<h4 id="题意-75">题意</h4>
<p>商场里有K种工具，价格分别为1，2，…，K美元。约翰手里有N美元，必须花完。求购买组合方案。n≤1000，k≤100。</p>
<h4 id="题解-75">题解</h4>
<p>完全背包，不过要高精度。</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb76-2"><a href="#cb76-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb76-3"><a href="#cb76-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb76-4"><a href="#cb76-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb76-5"><a href="#cb76-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb76-6"><a href="#cb76-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb76-7"><a href="#cb76-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb76-8"><a href="#cb76-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb76-9"><a href="#cb76-9"></a></span>
<span id="cb76-10"><a href="#cb76-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb76-11"><a href="#cb76-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb76-12"><a href="#cb76-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb76-13"><a href="#cb76-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb76-14"><a href="#cb76-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb76-15"><a href="#cb76-15"></a>}</span>
<span id="cb76-16"><a href="#cb76-16"></a><span class="kw">struct</span> bigint{</span>
<span id="cb76-17"><a href="#cb76-17"></a>    <span class="dt">int</span> len,num[<span class="dv">100</span>];</span>
<span id="cb76-18"><a href="#cb76-18"></a>    <span class="dt">void</span> <span class="kw">operator</span> = (<span class="dt">int</span> a){len=<span class="dv">0</span>; memset(num,<span class="dv">0</span>,<span class="kw">sizeof</span>(num)); <span class="cf">while</span>(a)num[++len]=a%<span class="dv">10</span>,a/=<span class="dv">10</span>;}</span>
<span id="cb76-19"><a href="#cb76-19"></a>    <span class="dt">void</span> <span class="kw">operator</span> = (bigint a){</span>
<span id="cb76-20"><a href="#cb76-20"></a>        memset(num,<span class="dv">0</span>,<span class="kw">sizeof</span>(num)); inc(i,<span class="dv">1</span>,a.len)num[i]=a.num[i]; len=a.len;</span>
<span id="cb76-21"><a href="#cb76-21"></a>    }</span>
<span id="cb76-22"><a href="#cb76-22"></a>    <span class="dt">void</span> <span class="kw">operator</span> += (bigint a){</span>
<span id="cb76-23"><a href="#cb76-23"></a>        len=max(len,a.len);</span>
<span id="cb76-24"><a href="#cb76-24"></a>        inc(i,<span class="dv">1</span>,len){num[i]+=a.num[i]; <span class="cf">if</span>(num[i]&gt;=<span class="dv">10</span>)num[i+<span class="dv">1</span>]+=num[i]/<span class="dv">10</span>,num[i]%=<span class="dv">10</span>;}</span>
<span id="cb76-25"><a href="#cb76-25"></a>        <span class="cf">if</span>(num[len+<span class="dv">1</span>])len++;</span>
<span id="cb76-26"><a href="#cb76-26"></a>    }</span>
<span id="cb76-27"><a href="#cb76-27"></a>    <span class="dt">void</span> print(){<span class="cf">for</span>(<span class="dt">int</span> i=len;i&gt;=<span class="dv">1</span>;i--)printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,num[i]);}</span>
<span id="cb76-28"><a href="#cb76-28"></a>};</span>
<span id="cb76-29"><a href="#cb76-29"></a><span class="dt">int</span> n,k,x,y; bigint f[<span class="dv">2</span>][maxn];</span>
<span id="cb76-30"><a href="#cb76-30"></a><span class="dt">int</span> main(){</span>
<span id="cb76-31"><a href="#cb76-31"></a>    n=read(); k=read(); x=<span class="dv">0</span>; y=<span class="dv">1</span>; f[x][<span class="dv">0</span>]=<span class="dv">1</span>;</span>
<span id="cb76-32"><a href="#cb76-32"></a>    inc(i,<span class="dv">1</span>,k){</span>
<span id="cb76-33"><a href="#cb76-33"></a>        inc(j,<span class="dv">0</span>,n)f[y][j]=f[x][j]; inc(j,i,n)f[y][j]+=f[y][j-i]; swap(x,y);</span>
<span id="cb76-34"><a href="#cb76-34"></a>    }</span>
<span id="cb76-35"><a href="#cb76-35"></a>    f[x][n].print(); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb76-36"><a href="#cb76-36"></a>}</span></code></pre></div>
<h3 id="bzoj1684usaco2005-octclose-encounter2016.9.27">bzoj1684[Usaco2005 Oct]Close Encounter*（2016.9.27）</h3>
<h4 id="题意-76">题意</h4>
<p>找一个分数它最接近给出一个分数。你要找的分数的分子分母的范围在1..32767。</p>
<h4 id="题解-76">题解</h4>
<p>枚举所求分数的分子，用其乘上给出分数得到一个浮点数分母，比较分母向上/下取整所得分数与答案比较。</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb77-3"><a href="#cb77-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb77-4"><a href="#cb77-4"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb77-5"><a href="#cb77-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb77-6"><a href="#cb77-6"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb77-7"><a href="#cb77-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb77-8"><a href="#cb77-8"></a></span>
<span id="cb77-9"><a href="#cb77-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb77-10"><a href="#cb77-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb77-11"><a href="#cb77-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb77-12"><a href="#cb77-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb77-13"><a href="#cb77-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb77-14"><a href="#cb77-14"></a>}</span>
<span id="cb77-15"><a href="#cb77-15"></a><span class="dt">int</span> n,d,ansa,ansb; <span class="dt">double</span> ans;</span>
<span id="cb77-16"><a href="#cb77-16"></a><span class="dt">int</span> main(){</span>
<span id="cb77-17"><a href="#cb77-17"></a>    n=read(); d=read(); ans=<span class="dv">10</span>;</span>
<span id="cb77-18"><a href="#cb77-18"></a>    inc(i,<span class="dv">1</span>,<span class="dv">32767</span>){</span>
<span id="cb77-19"><a href="#cb77-19"></a>        <span class="dt">int</span> j=n*i/d,k=j+<span class="dv">1</span>;</span>
<span id="cb77-20"><a href="#cb77-20"></a>        <span class="cf">if</span>(fabs((<span class="dt">double</span>)k/(<span class="dt">double</span>)i-(<span class="dt">double</span>)n/(<span class="dt">double</span>)d)&lt;ans)</span>
<span id="cb77-21"><a href="#cb77-21"></a>            ans=fabs((<span class="dt">double</span>)k/(<span class="dt">double</span>)i-(<span class="dt">double</span>)n/(<span class="dt">double</span>)d),ansa=k,ansb=i;</span>
<span id="cb77-22"><a href="#cb77-22"></a>        <span class="cf">if</span>(j*d!=n*i&amp;&amp;fabs((<span class="dt">double</span>)j/(<span class="dt">double</span>)i-(<span class="dt">double</span>)n/(<span class="dt">double</span>)d)&lt;ans)</span>
<span id="cb77-23"><a href="#cb77-23"></a>            ans=fabs((<span class="dt">double</span>)j/(<span class="dt">double</span>)i-(<span class="dt">double</span>)n/(<span class="dt">double</span>)d),ansa=j,ansb=i;</span>
<span id="cb77-24"><a href="#cb77-24"></a>    }</span>
<span id="cb77-25"><a href="#cb77-25"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%d</span><span class="st">&quot;</span>,ansa,ansb); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb77-26"><a href="#cb77-26"></a>}</span></code></pre></div>
<h3 id="bzoj1345baltic2007序列问题sequence2016.9.27">bzoj1345[Baltic2007]序列问题Sequence*（2016.9.27）</h3>
<h4 id="题意-77">题意</h4>
<p>n个数，合并ai和ai+1可以得到max(ai,ai+1)，代价为max(ai,ai+1)。问合并n-1次最小代价为多少。n≤1000000。</p>
<h4 id="题解-77">题解</h4>
<p>（来自题解，因为我不知道为什么这样做）维护一个单调递减栈。对于每个加入的元素，若加入后不满足单调性质，则让其与栈顶-1的元素比较：如果加入的数大，则合并栈顶和栈顶-1的数（把栈顶去掉），费用为栈顶-1；否则合并当前与栈顶的数（把栈顶去掉），费用为当前数。重复上述操作，直到满足单调性后入栈。最后从顶向下合并。</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb78-3"><a href="#cb78-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb78-4"><a href="#cb78-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb78-5"><a href="#cb78-5"></a><span class="pp">#define maxn </span><span class="dv">1000010</span></span>
<span id="cb78-6"><a href="#cb78-6"></a><span class="pp">#define INF </span><span class="bn">0x3fffffff</span></span>
<span id="cb78-7"><a href="#cb78-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb78-8"><a href="#cb78-8"></a></span>
<span id="cb78-9"><a href="#cb78-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb78-10"><a href="#cb78-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb78-11"><a href="#cb78-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb78-12"><a href="#cb78-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb78-13"><a href="#cb78-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb78-14"><a href="#cb78-14"></a>}</span>
<span id="cb78-15"><a href="#cb78-15"></a><span class="dt">int</span> st[maxn]; <span class="dt">int</span> n,top; <span class="dt">long</span> <span class="dt">long</span> ans;</span>
<span id="cb78-16"><a href="#cb78-16"></a><span class="dt">int</span> main(){</span>
<span id="cb78-17"><a href="#cb78-17"></a>    n=read(); st[<span class="dv">0</span>]=INF;</span>
<span id="cb78-18"><a href="#cb78-18"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb78-19"><a href="#cb78-19"></a>        <span class="dt">int</span> x=read();</span>
<span id="cb78-20"><a href="#cb78-20"></a>        <span class="cf">while</span>(top&amp;&amp;x&gt;=st[top]){</span>
<span id="cb78-21"><a href="#cb78-21"></a>            <span class="cf">if</span>(x&gt;=st[top-<span class="dv">1</span>])ans+=st[top-<span class="dv">1</span>],top--;<span class="cf">else</span> ans+=x,top--;</span>
<span id="cb78-22"><a href="#cb78-22"></a>        }</span>
<span id="cb78-23"><a href="#cb78-23"></a>        st[++top]=x;</span>
<span id="cb78-24"><a href="#cb78-24"></a>    }</span>
<span id="cb78-25"><a href="#cb78-25"></a>    <span class="cf">while</span>(top&gt;<span class="dv">1</span>)ans+=st[--top]; printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb78-26"><a href="#cb78-26"></a>}</span></code></pre></div>
<h3 id="bzoj1703usaco2007-marranking-the-cows-奶牛排名2016.9.27">bzoj1703[Usaco2007 Mar]Ranking the Cows 奶牛排名*（2016.9.27）</h3>
<h4 id="题意-78">题意</h4>
<p>n头奶牛，知道n对奶牛之间的产奶量大小，问想知道所有奶牛产奶量大小顺序至少还需知道几对。n≤1000。</p>
<h4 id="题解-78">题解</h4>
<p>每个大小关系看为一条有向边，对每头奶牛进行dfs，求每头奶牛可以到的奶牛数和可以到它的奶牛数之和，用n-1减后就是需要和它比较的奶牛数。最后输出(n*(n-1)-所有牛的结果相加)/2即可。</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb79-2"><a href="#cb79-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb79-3"><a href="#cb79-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb79-4"><a href="#cb79-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb79-5"><a href="#cb79-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb79-6"><a href="#cb79-6"></a><span class="pp">#define maxn </span><span class="dv">1010</span></span>
<span id="cb79-7"><a href="#cb79-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb79-8"><a href="#cb79-8"></a></span>
<span id="cb79-9"><a href="#cb79-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb79-10"><a href="#cb79-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb79-11"><a href="#cb79-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb79-12"><a href="#cb79-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb79-13"><a href="#cb79-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb79-14"><a href="#cb79-14"></a>}</span>
<span id="cb79-15"><a href="#cb79-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}es[maxn*<span class="dv">10</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb79-16"><a href="#cb79-16"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess;}</span>
<span id="cb79-17"><a href="#cb79-17"></a><span class="dt">int</span> f[maxn*<span class="dv">10</span>],t[maxn*<span class="dv">10</span>],n,m,sum[maxn],ans; <span class="dt">bool</span> vis[maxn];</span>
<span id="cb79-18"><a href="#cb79-18"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x,<span class="dt">int</span> s){</span>
<span id="cb79-19"><a href="#cb79-19"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(!vis[es[i].t])sum[s]++,vis[es[i].t]=<span class="dv">1</span>,dfs(es[i].t,s);</span>
<span id="cb79-20"><a href="#cb79-20"></a>}</span>
<span id="cb79-21"><a href="#cb79-21"></a><span class="dt">int</span> main(){</span>
<span id="cb79-22"><a href="#cb79-22"></a>    n=read(); m=read(); inc(i,<span class="dv">1</span>,m)f[i]=read(),t[i]=read(),pe(f[i],t[i]);</span>
<span id="cb79-23"><a href="#cb79-23"></a>    inc(i,<span class="dv">1</span>,n){memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); dfs(i,i);} ess=<span class="dv">0</span>; memset(g,<span class="dv">0</span>,<span class="kw">sizeof</span>(g));</span>
<span id="cb79-24"><a href="#cb79-24"></a>    inc(i,<span class="dv">1</span>,m)pe(t[i],f[i]); inc(i,<span class="dv">1</span>,n){memset(vis,<span class="dv">0</span>,<span class="kw">sizeof</span>(vis)); dfs(i,i);}</span>
<span id="cb79-25"><a href="#cb79-25"></a>    ans=n*(n-<span class="dv">1</span>); inc(i,<span class="dv">1</span>,n)ans-=sum[i]; printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans/<span class="dv">2</span>); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb79-26"><a href="#cb79-26"></a>}</span></code></pre></div>
<h3 id="bzoj1776usaco2010-holcowpol-奶牛政坛2016.9.27">bzoj1776[Usaco2010 Hol]cowpol 奶牛政坛*（2016.9.27）</h3>
<h4 id="题意-79">题意</h4>
<p>给出一个树，每个节点k个政党中的一个。问每个政党间最远的两个节点距离多少。节点数≤200000。</p>
<h4 id="题解-79">题解</h4>
<p>有个结论：每个政党所求两个节点其中一个必然是这个政党中深度最大的节点。因此枚举每个节点，计算该节点与节点所属政党深度最大节点的距离（倍增法），与给政党的答案比较即可。</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb80-2"><a href="#cb80-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb80-3"><a href="#cb80-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb80-4"><a href="#cb80-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb80-5"><a href="#cb80-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb80-6"><a href="#cb80-6"></a><span class="pp">#define maxn </span><span class="dv">200010</span></span>
<span id="cb80-7"><a href="#cb80-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb80-8"><a href="#cb80-8"></a></span>
<span id="cb80-9"><a href="#cb80-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb80-10"><a href="#cb80-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb80-11"><a href="#cb80-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb80-12"><a href="#cb80-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb80-13"><a href="#cb80-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb80-14"><a href="#cb80-14"></a>}</span>
<span id="cb80-15"><a href="#cb80-15"></a><span class="kw">struct</span> e{<span class="dt">int</span> t,n;}es[maxn*<span class="dv">2</span>]; <span class="dt">int</span> g[maxn],ess;</span>
<span id="cb80-16"><a href="#cb80-16"></a><span class="dt">void</span> pe(<span class="dt">int</span> f,<span class="dt">int</span> t){es[++ess]=(e){t,g[f]}; g[f]=ess;}</span>
<span id="cb80-17"><a href="#cb80-17"></a><span class="dt">int</span> n,k,dep[maxn],d[maxn],ans[maxn],type[maxn],f[<span class="dv">21</span>][maxn],l;</span>
<span id="cb80-18"><a href="#cb80-18"></a><span class="dt">void</span> dfs(<span class="dt">int</span> x){</span>
<span id="cb80-19"><a href="#cb80-19"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=g[x];i;i=es[i].n)<span class="cf">if</span>(es[i].t!=f[<span class="dv">0</span>][x])f[<span class="dv">0</span>][es[i].t]=x,dep[es[i].t]=dep[x]+<span class="dv">1</span>,dfs(es[i].t);</span>
<span id="cb80-20"><a href="#cb80-20"></a>}</span>
<span id="cb80-21"><a href="#cb80-21"></a><span class="dt">int</span> lca(<span class="dt">int</span> x,<span class="dt">int</span> y){</span>
<span id="cb80-22"><a href="#cb80-22"></a>    <span class="cf">if</span>(dep[x]&lt;dep[y])swap(x,y); <span class="dt">int</span> t=dep[x]-dep[y]; inc(i,<span class="dv">0</span>,l)<span class="cf">if</span>(t&amp;(<span class="dv">1</span>&lt;&lt;i))x=f[i][x];</span>
<span id="cb80-23"><a href="#cb80-23"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=l;i&gt;=<span class="dv">0</span>;i--)<span class="cf">if</span>(f[i][x]!=f[i][y])x=f[i][x],y=f[i][y];</span>
<span id="cb80-24"><a href="#cb80-24"></a>    <span class="cf">if</span>(x==y)<span class="cf">return</span> x;<span class="cf">else</span> <span class="cf">return</span> f[<span class="dv">0</span>][x];</span>
<span id="cb80-25"><a href="#cb80-25"></a>}</span>
<span id="cb80-26"><a href="#cb80-26"></a><span class="dt">int</span> main(){</span>
<span id="cb80-27"><a href="#cb80-27"></a>    n=read(); k=read(); inc(i,<span class="dv">1</span>,n){type[i]=read(); <span class="dt">int</span> x=read(); <span class="cf">if</span>(x)pe(x,i),pe(i,x);} dfs(<span class="dv">1</span>);</span>
<span id="cb80-28"><a href="#cb80-28"></a>    inc(i,<span class="dv">1</span>,n)<span class="cf">if</span>(dep[d[type[i]]]&lt;dep[i])d[type[i]]=i;</span>
<span id="cb80-29"><a href="#cb80-29"></a>    <span class="cf">for</span>(l=<span class="dv">0</span>;(<span class="dv">1</span>&lt;&lt;l)&lt;=n;l++); l--; inc(i,<span class="dv">1</span>,l)inc(j,<span class="dv">1</span>,n)f[i][j]=f[i-<span class="dv">1</span>][f[i-<span class="dv">1</span>][j]];</span>
<span id="cb80-30"><a href="#cb80-30"></a>    inc(i,<span class="dv">1</span>,n){ans[type[i]]=max(ans[type[i]],dep[i]+dep[d[type[i]]]-<span class="dv">2</span>*dep[lca(i,d[type[i]])]);}</span>
<span id="cb80-31"><a href="#cb80-31"></a>    inc(i,<span class="dv">1</span>,k)printf(<span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span>,ans[i]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb80-32"><a href="#cb80-32"></a>}</span></code></pre></div>
<h3 id="bzoj1676usaco2005-febfeed-accounting-饲料计算2016.9.28">bzoj1676[Usaco2005 Feb]Feed Accounting 饲料计算*（2016.9.28）</h3>
<h4 id="题意-80">题意</h4>
<p>知道草料到来时F1kg，第D天F2kg。同时知道每头牛到来时间和离开时间，一牛一天吃1kg草料，问草料到来是第几天。</p>
<h4 id="题解-80">题解</h4>
<p>直接用区间左端点对应数组元素++，右端点+1对应数组元素–的方法，最后扫一下即可。</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb81-3"><a href="#cb81-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb81-4"><a href="#cb81-4"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb81-5"><a href="#cb81-5"></a><span class="pp">#define maxn </span><span class="dv">10010</span></span>
<span id="cb81-6"><a href="#cb81-6"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb81-7"><a href="#cb81-7"></a></span>
<span id="cb81-8"><a href="#cb81-8"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb81-9"><a href="#cb81-9"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb81-10"><a href="#cb81-10"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb81-11"><a href="#cb81-11"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb81-12"><a href="#cb81-12"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb81-13"><a href="#cb81-13"></a>}</span>
<span id="cb81-14"><a href="#cb81-14"></a><span class="dt">int</span> sum[maxn],c,f1,f2,d;</span>
<span id="cb81-15"><a href="#cb81-15"></a><span class="dt">int</span> main(){</span>
<span id="cb81-16"><a href="#cb81-16"></a>    c=read(); f1=read(); f2=read(); d=read();</span>
<span id="cb81-17"><a href="#cb81-17"></a>    inc(i,<span class="dv">1</span>,c){<span class="dt">int</span> x=read(),y=read(); sum[x]++; sum[y+<span class="dv">1</span>]--;}</span>
<span id="cb81-18"><a href="#cb81-18"></a>    inc(i,<span class="dv">1</span>,d)sum[i]+=sum[i-<span class="dv">1</span>];</span>
<span id="cb81-19"><a href="#cb81-19"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=d;i&gt;=<span class="dv">1</span>;i--){</span>
<span id="cb81-20"><a href="#cb81-20"></a>        f2+=sum[i]; <span class="cf">if</span>(f2==f1){printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,i); <span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb81-21"><a href="#cb81-21"></a>    }</span>
<span id="cb81-22"><a href="#cb81-22"></a>}</span></code></pre></div>
<h3 id="bzoj1652usaco2006-febtreats-for-the-cows2016.9.29">bzoj1652[Usaco2006 Feb]Treats for the Cows*（2016.9.29）</h3>
<h4 id="题意-81">题意</h4>
<p>管子里n个巧克力，第i个价值为ai。每天从左端点或右端点拿一个出来卖，收入为这个巧克力的价值*它是第几天卖出的。问最大价值。n≤2000</p>
<h4 id="题解-81">题解</h4>
<p>dp：f[l][r]=max(f[l+1][r]+a[l]*(n-(r-l+1)+1),f[l][r-1]+a[r]*(n-(r-l+1)+1))。</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb82-2"><a href="#cb82-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb82-3"><a href="#cb82-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb82-4"><a href="#cb82-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb82-5"><a href="#cb82-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb82-6"><a href="#cb82-6"></a><span class="pp">#define maxn </span><span class="dv">2010</span></span>
<span id="cb82-7"><a href="#cb82-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb82-8"><a href="#cb82-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb82-9"><a href="#cb82-9"></a></span>
<span id="cb82-10"><a href="#cb82-10"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb82-11"><a href="#cb82-11"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb82-12"><a href="#cb82-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb82-13"><a href="#cb82-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb82-14"><a href="#cb82-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb82-15"><a href="#cb82-15"></a>}</span>
<span id="cb82-16"><a href="#cb82-16"></a>ll f[maxn][maxn]; <span class="dt">int</span> a[maxn],n;</span>
<span id="cb82-17"><a href="#cb82-17"></a>ll dfs(<span class="dt">int</span> l,<span class="dt">int</span> r){</span>
<span id="cb82-18"><a href="#cb82-18"></a>    <span class="cf">if</span>(l&gt;r)<span class="cf">return</span> <span class="dv">0</span>; <span class="cf">if</span>(f[l][r]!=-<span class="dv">1</span>)<span class="cf">return</span> f[l][r];</span>
<span id="cb82-19"><a href="#cb82-19"></a>    f[l][r]=max(dfs(l+<span class="dv">1</span>,r)+a[l]*(n-(r-l)),dfs(l,r-<span class="dv">1</span>)+a[r]*(n-(r-l)));</span>
<span id="cb82-20"><a href="#cb82-20"></a>    <span class="cf">return</span> f[l][r];</span>
<span id="cb82-21"><a href="#cb82-21"></a>}</span>
<span id="cb82-22"><a href="#cb82-22"></a><span class="dt">int</span> main(){</span>
<span id="cb82-23"><a href="#cb82-23"></a>    n=read(); inc(i,<span class="dv">1</span>,n)a[i]=read(); memset(f,-<span class="dv">1</span>,<span class="kw">sizeof</span>(f));</span>
<span id="cb82-24"><a href="#cb82-24"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,dfs(<span class="dv">1</span>,n)); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb82-25"><a href="#cb82-25"></a>}</span></code></pre></div>
<h3 id="bzoj1734usaco2005-febaggressive-cows-愤怒的牛2016.9.29">bzoj1734[Usaco2005 feb]Aggressive cows 愤怒的牛*（2016.9.29）</h3>
<h4 id="题意-82">题意</h4>
<p>n头牛，第i头坐标为xi，将它们分成c组，要求相邻两组最小距离最大。n≤100000。</p>
<h4 id="题解-82">题解</h4>
<p>二分最小距离。</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb83-2"><a href="#cb83-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb83-3"><a href="#cb83-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb83-4"><a href="#cb83-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb83-5"><a href="#cb83-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb83-6"><a href="#cb83-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb83-7"><a href="#cb83-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb83-8"><a href="#cb83-8"></a></span>
<span id="cb83-9"><a href="#cb83-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb83-10"><a href="#cb83-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb83-11"><a href="#cb83-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb83-12"><a href="#cb83-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb83-13"><a href="#cb83-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb83-14"><a href="#cb83-14"></a>}</span>
<span id="cb83-15"><a href="#cb83-15"></a><span class="dt">int</span> n,c,x[maxn],l,r,ans;</span>
<span id="cb83-16"><a href="#cb83-16"></a><span class="dt">bool</span> check(<span class="dt">int</span> a){</span>
<span id="cb83-17"><a href="#cb83-17"></a>    <span class="dt">int</span> j=c-<span class="dv">1</span>,k=x[<span class="dv">1</span>]; inc(i,<span class="dv">2</span>,n){<span class="cf">if</span>(x[i]-k&gt;=a)k=x[i],j--; <span class="cf">if</span>(!j)<span class="cf">return</span> <span class="dv">1</span>;} <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb83-18"><a href="#cb83-18"></a>}</span>
<span id="cb83-19"><a href="#cb83-19"></a><span class="dt">int</span> main(){</span>
<span id="cb83-20"><a href="#cb83-20"></a>    n=read(); c=read(); inc(i,<span class="dv">1</span>,n)x[i]=read(); sort(x+<span class="dv">1</span>,x+n+<span class="dv">1</span>); l=<span class="dv">1</span>; r=<span class="dv">1000000000</span>;</span>
<span id="cb83-21"><a href="#cb83-21"></a>    <span class="cf">while</span>(l&lt;=r){<span class="dt">int</span> mid=(l+r)&gt;&gt;<span class="dv">1</span>; <span class="cf">if</span>(check(mid))ans=mid,l=mid+<span class="dv">1</span>;<span class="cf">else</span> r=mid-<span class="dv">1</span>;} printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb83-22"><a href="#cb83-22"></a>    <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb83-23"><a href="#cb83-23"></a>}</span></code></pre></div>
<h3 id="bzoj1706usaco2007-novrelays-奶牛接力跑2016.9.29">bzoj1706[usaco2007 Nov]relays 奶牛接力跑*（2016.9.29）</h3>
<h4 id="题意-83">题意</h4>
<p>无向图，求刚好经过n条边的最小距离。边数≤100，n≤1000000。</p>
<h4 id="题解-83">题解</h4>
<p>边数≤100，说明点数不超过200。故可以用floyd。但要用一点技巧，即倍增floyd：定义最短路矩阵之间的乘法为对它们做floyd，则最后答案矩阵为初始边矩阵的“n次幂”，同时这种乘法满足结合律，故可以用快速幂使得复杂度降低。本弱遇到了莫名其妙的问题，快速幂一写成递归形式就爆栈，样例都过不去，写成二进制拆分形式才能不RE。</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb84-2"><a href="#cb84-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb84-3"><a href="#cb84-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb84-4"><a href="#cb84-4"></a><span class="pp">#include </span><span class="im">&lt;map&gt;</span></span>
<span id="cb84-5"><a href="#cb84-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb84-6"><a href="#cb84-6"></a><span class="pp">#define maxn </span><span class="dv">210</span></span>
<span id="cb84-7"><a href="#cb84-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb84-8"><a href="#cb84-8"></a><span class="pp">#define INF </span><span class="dv">10000000000000000</span></span>
<span id="cb84-9"><a href="#cb84-9"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb84-10"><a href="#cb84-10"></a></span>
<span id="cb84-11"><a href="#cb84-11"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb84-12"><a href="#cb84-12"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb84-13"><a href="#cb84-13"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb84-14"><a href="#cb84-14"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb84-15"><a href="#cb84-15"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb84-16"><a href="#cb84-16"></a>}</span>
<span id="cb84-17"><a href="#cb84-17"></a><span class="dt">int</span> tot,n,t,s,e; map&lt;<span class="dt">int</span>,<span class="dt">int</span>&gt;mp;</span>
<span id="cb84-18"><a href="#cb84-18"></a><span class="kw">struct</span> mat{</span>
<span id="cb84-19"><a href="#cb84-19"></a>    ll dis[maxn][maxn];</span>
<span id="cb84-20"><a href="#cb84-20"></a>}f[<span class="dv">25</span>],ans;</span>
<span id="cb84-21"><a href="#cb84-21"></a>mat <span class="kw">operator</span> * (mat a,mat b){</span>
<span id="cb84-22"><a href="#cb84-22"></a>    mat c; inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n)c.dis[i][j]=INF;</span>
<span id="cb84-23"><a href="#cb84-23"></a>    inc(k,<span class="dv">1</span>,n)</span>
<span id="cb84-24"><a href="#cb84-24"></a>        inc(i,<span class="dv">1</span>,n)</span>
<span id="cb84-25"><a href="#cb84-25"></a>            inc(j,<span class="dv">1</span>,n)c.dis[i][j]=min(c.dis[i][j],a.dis[i][k]+b.dis[k][j]);</span>
<span id="cb84-26"><a href="#cb84-26"></a>    <span class="cf">return</span> c;</span>
<span id="cb84-27"><a href="#cb84-27"></a>}</span>
<span id="cb84-28"><a href="#cb84-28"></a><span class="dt">int</span> getnum(<span class="dt">int</span> x){</span>
<span id="cb84-29"><a href="#cb84-29"></a>    <span class="dt">int</span> y=mp[x]; <span class="cf">if</span>(!y){mp[x]=++n; <span class="cf">return</span> n;}<span class="cf">else</span> <span class="cf">return</span> y;</span>
<span id="cb84-30"><a href="#cb84-30"></a>}</span>
<span id="cb84-31"><a href="#cb84-31"></a><span class="dt">int</span> main(){</span>
<span id="cb84-32"><a href="#cb84-32"></a>    tot=read(); t=read(); s=getnum(read()); e=getnum(read());</span>
<span id="cb84-33"><a href="#cb84-33"></a>    inc(i,<span class="dv">1</span>,t){</span>
<span id="cb84-34"><a href="#cb84-34"></a>        <span class="dt">int</span> x=read(),y=getnum(read()),z=getnum(read()); f[<span class="dv">0</span>].dis[y][z]=x; f[<span class="dv">0</span>].dis[z][y]=x;</span>
<span id="cb84-35"><a href="#cb84-35"></a>    }</span>
<span id="cb84-36"><a href="#cb84-36"></a>    inc(i,<span class="dv">1</span>,n)inc(j,<span class="dv">1</span>,n)<span class="cf">if</span>(!f[<span class="dv">0</span>].dis[i][j])f[<span class="dv">0</span>].dis[i][j]=INF;</span>
<span id="cb84-37"><a href="#cb84-37"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">1</span>;(<span class="dv">1</span>&lt;&lt;i)&lt;=tot;i++)f[i]=f[i-<span class="dv">1</span>]*f[i-<span class="dv">1</span>]; <span class="dt">bool</span> fl=<span class="dv">0</span>;</span>
<span id="cb84-38"><a href="#cb84-38"></a>    <span class="cf">for</span>(<span class="dt">int</span> i=<span class="dv">0</span>;(<span class="dv">1</span>&lt;&lt;i)&lt;=tot;i++)<span class="cf">if</span>(tot&amp;(<span class="dv">1</span>&lt;&lt;i)){<span class="cf">if</span>(!fl)ans=f[i],fl=<span class="dv">1</span>;<span class="cf">else</span> ans=ans*f[i];}</span>
<span id="cb84-39"><a href="#cb84-39"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld</span><span class="st">&quot;</span>,ans.dis[s][e]); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb84-40"><a href="#cb84-40"></a>}</span></code></pre></div>
<h3 id="bzoj1702usaco2007-margold-balanced-lineup-平衡的队列2016.9.29">bzoj1702[Usaco2007 Mar]Gold Balanced Lineup 平衡的队列*（2016.9.29）</h3>
<h4 id="题意-84">题意</h4>
<p>N头牛，一共K种特色。每头牛有多种特色。[i,j]段被称为balanced当且仅当K种特色在[i,j]内拥有次数相同。求最大的[i,j]段长度。n≤100000，k≤30。</p>
<h4 id="题解-84">题解</h4>
<p>得到式子：a[i][l]-a[j][l]=a[i][l-1]-a[j][l-1],l在2..k之间，移项得a[i][l]-a[i][l-1]=a[j][l]-a[j][l-1],l在2..k之间，故可以定义一个结构体，里面包含所有的a[i][l]-a[i][l-1],l在2..k之间，然后用set查找满足所有元素相等的最小j即可。</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb85-2"><a href="#cb85-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb85-3"><a href="#cb85-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb85-4"><a href="#cb85-4"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb85-5"><a href="#cb85-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb85-6"><a href="#cb85-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb85-7"><a href="#cb85-7"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb85-8"><a href="#cb85-8"></a></span>
<span id="cb85-9"><a href="#cb85-9"></a><span class="kw">inline</span> <span class="dt">int</span> read(){</span>
<span id="cb85-10"><a href="#cb85-10"></a>    <span class="dt">char</span> ch=getchar(); <span class="dt">int</span> f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb85-11"><a href="#cb85-11"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb85-12"><a href="#cb85-12"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb85-13"><a href="#cb85-13"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb85-14"><a href="#cb85-14"></a>}</span>
<span id="cb85-15"><a href="#cb85-15"></a><span class="dt">int</span> sum[maxn][<span class="dv">50</span>],n,k,ans;</span>
<span id="cb85-16"><a href="#cb85-16"></a><span class="kw">struct</span> nd{</span>
<span id="cb85-17"><a href="#cb85-17"></a>    <span class="dt">int</span> id; <span class="dt">int</span> num[<span class="dv">50</span>];</span>
<span id="cb85-18"><a href="#cb85-18"></a>    <span class="dt">bool</span> <span class="kw">operator</span> &lt; (<span class="at">const</span> nd &amp;a)<span class="at">const</span>{inc(i,<span class="dv">1</span>,k-<span class="dv">1</span>)<span class="cf">if</span>(num[i]!=a.num[i])<span class="cf">return</span> num[i]&lt;a.num[i]; <span class="cf">return</span> <span class="dv">0</span>;}</span>
<span id="cb85-19"><a href="#cb85-19"></a>};</span>
<span id="cb85-20"><a href="#cb85-20"></a>multiset&lt;nd&gt;st; nd a;</span>
<span id="cb85-21"><a href="#cb85-21"></a><span class="dt">int</span> main(){</span>
<span id="cb85-22"><a href="#cb85-22"></a>    n=read(); k=read();</span>
<span id="cb85-23"><a href="#cb85-23"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb85-24"><a href="#cb85-24"></a>        <span class="dt">int</span> x=read(); inc(j,<span class="dv">1</span>,k)sum[i][j]=sum[i-<span class="dv">1</span>][j]; <span class="cf">for</span>(<span class="dt">int</span> j=k-<span class="dv">1</span>;j&gt;=<span class="dv">0</span>;j--)<span class="cf">if</span>(x&amp;(<span class="dv">1</span>&lt;&lt;j))sum[i][j+<span class="dv">1</span>]++;</span>
<span id="cb85-25"><a href="#cb85-25"></a>    }</span>
<span id="cb85-26"><a href="#cb85-26"></a>    inc(j,<span class="dv">1</span>,k-<span class="dv">1</span>)a.num[j]=<span class="dv">0</span>; a.id=<span class="dv">0</span>; st.insert(a);</span>
<span id="cb85-27"><a href="#cb85-27"></a>    inc(i,<span class="dv">1</span>,n){</span>
<span id="cb85-28"><a href="#cb85-28"></a>        inc(j,<span class="dv">1</span>,k-<span class="dv">1</span>)a.num[j]=sum[i][j]-sum[i][j+<span class="dv">1</span>]; a.id=i;</span>
<span id="cb85-29"><a href="#cb85-29"></a>        multiset&lt;nd&gt;::iterator sti=st.find(a); <span class="cf">if</span>(sti==st.end())st.insert(a);<span class="cf">else</span>{</span>
<span id="cb85-30"><a href="#cb85-30"></a>            ans=max(ans,i-sti-&gt;id);</span>
<span id="cb85-31"><a href="#cb85-31"></a>        }</span>
<span id="cb85-32"><a href="#cb85-32"></a>    }</span>
<span id="cb85-33"><a href="#cb85-33"></a>    printf(<span class="st">&quot;</span><span class="sc">%d</span><span class="st">&quot;</span>,ans); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb85-34"><a href="#cb85-34"></a>}</span></code></pre></div>
<h3 id="bzoj3043incdec-sequence2016.9.29">bzoj3043IncDec Sequence（2016.9.29）*</h3>
<h4 id="题意-85">题意</h4>
<p>n个数，每次可以将区间l到r里的数+1或-1，问将它们变成同个数的最小操作次数和保证最小操作次数前提下有多少中可能。n≤100000。</p>
<h4 id="题解-85">题解</h4>
<p>先对原数组差分（得到的数组第一个为原数组第一个元素，之后的元素为原数组相邻元素之差），则原操作变为左右端点对应元素加1减1或减1加1，求最小操作次数使得除第一个元素之外剩下元素均为0。则先将正负数对消，剩下的数可以自己消掉或与第一个数对消，故第一问答案为max(正数之和,负数绝对值之和) 第二问答案为abs(正数之和-负数绝对值之和)+1。</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1"></a><span class="pp">#include </span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb86-2"><a href="#cb86-2"></a><span class="pp">#include </span><span class="im">&lt;cstring&gt;</span></span>
<span id="cb86-3"><a href="#cb86-3"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb86-4"><a href="#cb86-4"></a><span class="pp">#include </span><span class="im">&lt;queue&gt;</span></span>
<span id="cb86-5"><a href="#cb86-5"></a><span class="pp">#define inc</span>(i,j,k)<span class="pp"> </span><span class="cf">for</span>(<span class="dt">int</span><span class="pp"> </span>i=j;i&lt;=k;i++)</span>
<span id="cb86-6"><a href="#cb86-6"></a><span class="pp">#define maxn </span><span class="dv">100010</span></span>
<span id="cb86-7"><a href="#cb86-7"></a><span class="pp">#define ll </span><span class="dt">long</span><span class="pp"> </span><span class="dt">long</span></span>
<span id="cb86-8"><a href="#cb86-8"></a><span class="kw">using</span> <span class="kw">namespace</span> std;</span>
<span id="cb86-9"><a href="#cb86-9"></a></span>
<span id="cb86-10"><a href="#cb86-10"></a><span class="kw">inline</span> ll read(){</span>
<span id="cb86-11"><a href="#cb86-11"></a>    <span class="dt">char</span> ch=getchar(); ll f=<span class="dv">1</span>,x=<span class="dv">0</span>;</span>
<span id="cb86-12"><a href="#cb86-12"></a>    <span class="cf">while</span>(ch&lt;<span class="ch">&#39;0&#39;</span>||ch&gt;<span class="ch">&#39;9&#39;</span>){<span class="cf">if</span>(ch==<span class="ch">&#39;-&#39;</span>)f=-<span class="dv">1</span>; ch=getchar();}</span>
<span id="cb86-13"><a href="#cb86-13"></a>    <span class="cf">while</span>(ch&gt;=<span class="ch">&#39;0&#39;</span>&amp;&amp;ch&lt;=<span class="ch">&#39;9&#39;</span>)x=x*<span class="dv">10</span>+ch-<span class="ch">&#39;0&#39;</span>,ch=getchar();</span>
<span id="cb86-14"><a href="#cb86-14"></a>    <span class="cf">return</span> f*x;</span>
<span id="cb86-15"><a href="#cb86-15"></a>}</span>
<span id="cb86-16"><a href="#cb86-16"></a><span class="dt">int</span> n; ll day,xiy,a,b;</span>
<span id="cb86-17"><a href="#cb86-17"></a><span class="dt">int</span> main(){</span>
<span id="cb86-18"><a href="#cb86-18"></a>    n=read(); a=read(); inc(i,<span class="dv">2</span>,n){b=read(); <span class="cf">if</span>(b-a&gt;<span class="dv">0</span>)day+=(b-a);<span class="cf">else</span> xiy+=(a-b); a=b;}</span>
<span id="cb86-19"><a href="#cb86-19"></a>    printf(<span class="st">&quot;</span><span class="sc">%lld\n%lld</span><span class="st">&quot;</span>,max(day,xiy),abs(day-xiy)+<span class="dv">1</span>); <span class="cf">return</span> <span class="dv">0</span>;</span>
<span id="cb86-20"><a href="#cb86-20"></a>}</span></code></pre></div>
<footer>
    <hr>
    <center>
        Powered by <a href="https://github.com/ZimingYuan/Yblogs" target="_blank">Yblogs</a><br>
        转载请注明出处<br>
        © 2025 VnYzm的博客<br>
        <span id="busuanzi_container_site_uv">2025年10月7日以来总访问量为<span id="busuanzi_value_site_uv"></span>次</span>
    </center>
</footer>
</body>
</html>
