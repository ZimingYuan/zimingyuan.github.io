<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN" data-theme="tufte">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="rCore-Tutorial-Book-v3学习笔记（一）" />
  <meta name="keywords" content="" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/extra/classless.css" />
<style>
html[data-theme='tufte']{
    --rem: 15px;
    --navpos: absolute;
    --width: 70rem;
    --font-p: 1.4rem/2 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-h: 1.4rem/1.5 et-book, Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
    --font-c: .9em/1.4 Consolas,"Liberation Mono","Courier New",monospace;
    --ornament: "";
    --border: 1px solid var(--cmed);
    /* foreground   | background color */
    --cfg:   #111;    --cbg:    #fbf7ec;
    --cdark: #111;    --clight: #fbf7ec;
    --cmed: #b4d5fe;
    --clink: #111;
    --cemph: #111;
}
</style>
  <script>
      let search = () => {
          let word = document.querySelector('input');
          if (word.value.length == 0) {
              word.focus();
          } else {
              location.href = '/search.html?' + word.value;
          }
      };
      window.onload = () => {
          document.querySelector('input').addEventListener(
              'keydown',  (event) => {
                  if (event.key == 'Enter') search();
          });
      }
  </script>
  <link rel="icon" href="/img/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
  <title>rCore-Tutorial-Book-v3学习笔记（一）</title>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
    <nav>
        <ul>
            <li><big>VnYzm的博客</big></li>
            <li><a href="/index.html">主页</a></li>
            <li><a href="/html/随笔.html">随笔</a></li>
            <li><a href="/miscellany.html">杂谈</a></li>
            <li><a href="/friends.html">友链</a></li>
            <li class="float-right sticky"><button style="margin: 0" onclick="search()">Go</button></li>
            <li class="float-right sticky"><input type="search" placeholder="搜索标题" style="margin: 0"></li>
        </ul>
    </nav>
<header id="title-block-header">
<h1 class="title">rCore-Tutorial-Book-v3学习笔记（一）</h1>
<hr>
</header>
<h3 id="概述">概述</h3>
<p>最近看到清华的一个操作系统教程<a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/index.html">rCore-Tutorial-Book</a>，和其他实验不同的是，这个教程介绍的是完全从零开始实现一个Riscv操作系统。教程所用的编程语言是Rust，但是我的Rust水平只到勉强能看懂代码的地步，所以打算用C语言照着实现一遍。虽然说是照着实现，但不同的语言还是会带来不少细节的不同，相比于同个语言照抄代码还是能注意到不少平常没在意的东西。因此开个坑，记录一下遇到的问题，代码放在<a href="https://github.com/ZimingYuan/testos">Github</a>上了。由于是练习，代码写得比较乱。</p>
<p>第一部分是实现一个最小化内核，即能让qemu-system-riscv跑起来并输出Hello world!然后退出就算成功。得益于SBI的帮助，我们可以少研究很多东西。这里大致介绍一下SBI，SBI指的是一套辅助操作系统内核编程的工具，它包含两部分：</p>
<ul>
<li><p><strong>boot loader</strong>：即在机器态里初始化裸机上的一些寄存器和硬件设备，把操作系统内核读取到对应的内存区域，然后进入内核态（Supervisor态，直译为监管者态，因为是操作系统内核主要运行的特权级，后面均称内核态），开始执行内核的第一条指令；</p></li>
<li><p><strong>处理内核态系统调用的机器态代码</strong>：在内核态设置好存储调用号和参数的寄存器，然后执行指令ecall，系统就会进入机器态，由SBI执行一些机器态才能做的操作，然后返回内核态。</p></li>
</ul>
<p>没有SBI，机器态相关的代码就得自己写了，xv6就是这样做的，所以xv6除了进程、文件、内存管理这些模块，还有一些充满晦涩代码的模块，这些就是在处理机器态和硬件相关的操作；riscv-pk的系统引导用的是BBL(Berkeley Boot Loader)，需要机器态做的任务则转发给spike模拟器的htif模块，由宿主系统执行这些任务。</p>
<p>本项目我用的是<a href="https://github.com/luojia65/rustsbi">RustSBI</a>，和教程用的一样，虽然是用Rust写的，但是已经打包成二进制文件了，可以直接使用。原先我打算使用qemu自带的OpenSBI，但是不知道为什么，在调用OpenSBI的退出程序功能时，qemu会报错，没法正常退出，RustSBI则不会。</p>
<h3 id="内容">内容</h3>
<p>首先是SBI的系统调用，由于涉及寄存器操作，需要用到内联汇编：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a>isize sbi_call(usize id, usize a0, usize a1, usize a2) {</span>
<span id="cb1-2"><a href="#cb1-2"></a>    isize ret;</span>
<span id="cb1-3"><a href="#cb1-3"></a>    asm <span class="dt">volatile</span> (</span>
<span id="cb1-4"><a href="#cb1-4"></a>            <span class="st">&quot;mv x10, %1</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>            <span class="st">&quot;mv x11, %2</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>            <span class="st">&quot;mv x12, %3</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>            <span class="st">&quot;mv x17, %4</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>            <span class="st">&quot;ecall</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>            <span class="st">&quot;mv %0, x10</span><span class="sc">\n</span><span class="st">&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>            :<span class="st">&quot;=r&quot;</span>(ret)</span>
<span id="cb1-11"><a href="#cb1-11"></a>            :<span class="st">&quot;r&quot;</span>(a0), <span class="st">&quot;r&quot;</span>(a1), <span class="st">&quot;r&quot;</span>(a2), <span class="st">&quot;r&quot;</span>(id)</span>
<span id="cb1-12"><a href="#cb1-12"></a>            :<span class="st">&quot;memory&quot;</span>, <span class="st">&quot;x10&quot;</span>, <span class="st">&quot;x11&quot;</span>, <span class="st">&quot;x12&quot;</span>, <span class="st">&quot;x17&quot;</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>            );</span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="cf">return</span> ret;</span>
<span id="cb1-15"><a href="#cb1-15"></a>}</span></code></pre></div>
<p>本项目中为了简化代码以及与教程保持一致，把unsigned long long定义成usize，long long定义成isize了。这里要注意的是内联汇编的格式，和Rust不同，C语言不能在内联汇编的函数中绑定变量和寄存器（如果写的是x86汇编好像可以，riscv就不行了）（可以在声明变量的同时指定该变量必须用某寄存器存，但语法比较麻烦），所以需要先把变量存到对应寄存器才可以。这样最后一个冒号右侧的限制符也必须添加上这三个寄存器的名字，否则编译器可能会编译出错误的代码，打个比方说，没有限制符，上面的程序编译出来的结果可能会在内联汇编前面用x10存a2，那么进入内联汇编后程序首先将a0赋给x10，a2就被覆盖掉了，程序就出错了。</p>
<p>然后是教程中说的一个bss段清零的操作：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">extern</span> <span class="dt">char</span> sbss, ebss;</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">void</span> clear_bss() {</span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="cf">for</span> (<span class="dt">char</span> *i = &amp;sbss; i &lt; &amp;ebss; i++) *i = <span class="dv">0</span>;</span>
<span id="cb2-4"><a href="#cb2-4"></a>}</span></code></pre></div>
<p>这里sbss、ebss都是来自linker script的符号。符号可以定义在C程序中，可以定义在汇编代码中，可以定义在linker script中，只要符号的强定义不是在当前C程序，那么对于当前C程序，这个符号可以解释成任何类型，因为它只是一个位置标识。在上面的代码中，我把sbss和ebss解释成linker script中这两个符号指向的第一个字节，那么就只要对这两个字节的地址之间的空间清零就行了。教程里面是把两个符号解释成地址，我觉得C语言应该也一样，即下面的写法和上面应该是等价的：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">void</span> sbss();</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="dt">void</span> ebss();</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="dt">void</span> clear_bss() {</span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="cf">for</span> (<span class="dt">char</span> *i = (<span class="dt">char</span> *)sbss; i &lt; (<span class="dt">char</span> *)ebss; i++) *i = <span class="dv">0</span>;</span>
<span id="cb3-5"><a href="#cb3-5"></a>}</span></code></pre></div>
<p>然后就是这个函数正确编译需要在编译选项里加<code>-mcmodel=medany</code>，不然会报错，具体原因我没看懂，好像是默认对符号地址有什么限制。</p>
<p>最后是编译选项，我写了个makefile：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode makefile"><code class="sourceCode makefile"><span id="cb4-1"><a href="#cb4-1"></a><span class="dv">default:</span><span class="dt"> os.bin</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>    riscv64-unknown-elf-gcc os.c printf.c entry.S -T linker.ld -ffreestanding -nostdlib -g -o os -mcmodel=medany</span>
<span id="cb4-3"><a href="#cb4-3"></a>    riscv64-unknown-elf-objcopy os --strip-all -O binary os.bin</span>
<span id="cb4-4"><a href="#cb4-4"></a>    qemu-system-riscv64 -machine virt -nographic -bios rustsbi-qemu.bin -device loader,file=os.bin,addr=0x80200000</span></code></pre></div>
<p>这里<code>-ffreestanding</code>的意思是允许重新定义标准库里已经有的函数，比如我自己定义了一个printf函数（主要内容是从xv6复制的，这里就显现出Rust的好了，Rust的格式化输出是定义在语言内部的，只需要重写字符串的输出方式，C的整个格式化都得重写），和stdio.h那个同名，不加这个编译选项就会报错。在编译完后，需要用objcopy把程序的elf元信息去掉，因为裸机只能理解代码，不能解析elf格式，经过objcopy后整个文件上来就是二进制代码，裸机可以直接执行。最后是SBI把内核放到的位置，我放在0x8020_0000，和教程的0x8002_0000不太一样，相应的linker script里的内容也要改。</p>
<p>顺便提一下如何使用gdb调试，首先编译的时候必须用<code>-g</code>往二进制文件里添加调试符号表，接着在最后执行qemu的时候添加选项<code>-s -S</code>意思是监听调试端口1234，同时在执行第一句汇编指令前停下来等待gdb连接。然后打开另一个终端，运行<code>riscv-elf-gdb 二进制文件</code>，gdb的程序名不一定是这个，只要是riscv目标版本的都可以，二进制文件指的是没有经过objcopy，gcc直接编译出来的文件。进入gdb后运行命令<code>target remote :1234</code>，连上qemu以后就可以进行查看代码、加断点、单步执行等操作了。</p>
<footer>
    <hr>
    <center>
        Powered by <a href="https://github.com/ZimingYuan/Yblogs" target="_blank">Yblogs</a><br>
        转载请注明出处<br>
        © 2025 VnYzm的博客
    </center>
</footer>
</body>
</html>
